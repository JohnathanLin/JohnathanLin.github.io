[{"content":" 前言：本文想要介绍Synchronized，ReentrantLock和ReentrantLock的Condition的相关用法。\nSynchronized上锁 Synchronized可以修饰实例方法、静态方法和代码块。修饰代码块时，可以对具体的对象上锁，也可以对某个类(.class)上锁。\nSynchronized是非公平锁 以下代码是通过给一个多线程能访问到的变量使用synchronized进行上锁，实现有序打印数字的功能。并且在最后会统计不同线程打印数字的次数：\npackage com.windypath.lockcondition; public class Syn { int count = 0; final Object sth = new Object(); void play() { int loopTimes = 1000; SynThread t1 = new SynThread(loopTimes, \u0026#34;t1\u0026#34;); SynThread t2 = new SynThread(loopTimes, \u0026#34;t2\u0026#34;); SynThread t3 = new SynThread(loopTimes, \u0026#34;t3\u0026#34;); SynThread t4 = new SynThread(loopTimes, \u0026#34;t4\u0026#34;); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Syn syn = new Syn(); syn.play(); } class SynThread extends Thread { int loopTimes; public SynThread(int loopTimes, String threadName) { super(threadName); this.loopTimes = loopTimes; } @Override public void run() { int times = 0; while (count \u0026lt;= 200000) { synchronized (sth) { count++; // System.out.println(getName() + \u0026#34; 输出 \u0026#34; + count); times++; } } System.out.println(getName() + \u0026#34;一共输出了 \u0026#34; + times + \u0026#34; 次\u0026#34;); } } } 输出结果如下：\nt2一共输出了 103061 次 t1一共输出了 37174 次 t4一共输出了 33751 次 t3一共输出了 26018 次 可以看到线程t2输出的次数比其他三个线程加起来还要多。因为synchronized是非公平锁。\nsynchronized的等待队列 使用synchronized上锁的对象的等待队列位于ObjectMonitor中的_waitSet。这个ObjectMonitor是底层native(也就是C/C++)的内容。\nsynchronized锁升级 但并不是一开始就上重量级锁，而是先优化成偏向锁，如有竞争才会升级为轻量级锁，大量的线程参与锁的竞争时，才会从轻量级锁升级到重量级锁。\n上锁的对象使用其对象头中的MarkWord来存储锁的信息。\n一个Java对象在内存中的存储结构包括三个部分：\n对象头 实例变量 填充字节 其中对象头中主要存储一些运行时的数据：\nMarkWord Class Metadata Address (指向对象类型数据的指针) Array Length (是数组的话，记录长度) 锁的信息记录在对象头的MarkWord中。下图是不同的锁的MarkWord的不同位的信息： 偏向锁（biased lock） 偏向锁是为了避免在非多线程环境下，执行synchronized上锁时使用轻量级锁等更高等级的锁消耗资源。 偏向的意思是，被上锁的对象偏向于某个线程。其对象头会存储偏向的线程id。\n轻量级锁（lightweight lock） 轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况。 轻量级锁和偏向锁的区别 轻量级锁的加锁过程需要多次CAS操作，而偏向锁仅需要一次CAS操作。 轻量级锁所适应的场景是线程交替执行同步块的情况。而偏向锁则是在只有一个线程执行同步块时进一步提高性能。\nsynchronized锁升级观察 尝试使用一个对象，多个线程在不同的时间段为其上synchronized锁，来观察其锁状态。 thread1:马上获取，马上释放 thread2:等500ms获取，然后使用1500毫秒再释放 thread3:等待1000ms获取，然后马上释放。\n此时，thread2和thread3会出现锁竞争。\n源代码如下：\npackage com.windypath; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.openjdk.jol.info.ClassLayout; /** * 观察synchronized从偏向锁 -\u0026gt; 轻量级锁 -\u0026gt; 重量级锁 的过程 * 项目使用log4j2 */ public class BiasdLock { final static Logger log = LogManager.getLogger(); public static void main(String[] args) throws InterruptedException { log.debug(Thread.currentThread().getName() + \u0026#34;最开始的状态:\\n\u0026#34; + ClassLayout.parseInstance(new Object()).toPrintable()); // HotSpot 虚拟机在启动后有个 4s 的延迟才会对每个新建的对象开启偏向锁模式 Thread.sleep(4000); // 创建一个对象，用于多个不同的线程上锁用 Object obj = new Object(); log.debug(Thread.currentThread().getName() + \u0026#34;等待4秒后的状态（新对象）:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); //线程1，马上上锁马上释放 new Thread(() -\u0026gt; { log.debug( Thread.currentThread().getName() + \u0026#34;开始执行准备获取锁:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); synchronized (obj) { log.debug(Thread.currentThread().getName() + \u0026#34;获取锁执行中:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); } log.debug(Thread.currentThread().getName() + \u0026#34;释放锁:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); }, \u0026#34;thread1\u0026#34;).start(); // 线程2，等线程1释放锁后再上锁 new Thread(() -\u0026gt; { try { Thread.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } log.debug( Thread.currentThread().getName() + \u0026#34;开始执行准备获取锁:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); synchronized (obj) { log.debug(Thread.currentThread().getName() + \u0026#34;获取锁执行中:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); try { Thread.sleep(1500); } catch (InterruptedException e) { throw new RuntimeException(e); } } log.debug(Thread.currentThread().getName() + \u0026#34;释放锁:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); }, \u0026#34;thread2\u0026#34;).start(); // 线程3，在线程2拥有锁的时候尝试上锁 new Thread(() -\u0026gt; { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } log.debug( Thread.currentThread().getName() + \u0026#34;开始执行准备获取锁:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); synchronized (obj) { log.debug(Thread.currentThread().getName() + \u0026#34;获取锁执行中:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); } log.debug(Thread.currentThread().getName() + \u0026#34;释放锁:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); }, \u0026#34;thread3\u0026#34;).start(); //主线程等待所有线程运行结束，查看状态 Thread.sleep(5000); log.debug(Thread.currentThread().getName() + \u0026#34;结束状态:\\n\u0026#34; + ClassLayout.parseInstance(obj).toPrintable()); } } 输出如下(精简之后):\n15:53:58.436 [main] main最开始的状态:non-biasable 15:54:02.854 [main] 等待4秒后的状态（新对象）:biasable 15:54:02.858 [thread1] thread1开始执行准备获取锁:biasable 15:54:02.858 [thread1] thread1获取锁执行中:biased 15:54:02.859 [thread1] thread1释放锁:biased 15:54:03.367 [thread2] thread2开始执行准备获取锁:biased 15:54:03.368 [thread2] thread2获取锁执行中:thin lock 15:54:03.869 [thread3] thread3开始执行准备获取锁:thin lock 15:54:04.872 [thread3] thread3获取锁执行中:fat lock 15:54:04.872 [thread2] thread2释放锁:fat lock 15:54:04.873 [thread3] thread3释放锁:fat lock 15:54:07.868 [main] main结束状态:non-biasable 可以分析得到以下结论：\n对于hotspot虚拟机，刚启动时创建的对象是不可偏向(non-biasable)的 4秒后创建的对象，状态为可偏向(biasable) thread1获取锁时，由于仅有一个线程为此对象上synchronized锁，因此转为偏向锁状态(biased) thread1释放锁时，锁对象状态依旧为偏向锁(biased)，并不会回到可偏向(biasable) 500ms后，thread2获取锁时，锁对象的状态会升级为轻量级锁(thin lock) 再过500ms后，thread3也开始获取锁，未执行到synchronized代码块时，状态为轻量级锁(thin lock)，执行到synchronized时，阻塞，直到thread2释放的同时马上获取锁(倒数第三第四行的日志时间一模一样都是15:54:04.872) thread3马上释放锁，这一刻还是重量级锁(fat lock) 主线程等待5秒后，锁状态恢复，但是是变为不可偏向(non-biasable)状态。 可以尝试把前面的等待4秒注释，这样的话一上来就会获取轻量级锁 ReentrantLock上锁 ReentrantLock是轻量级、可重入锁。在创建时可指定是否是公平锁。 ReentrantLock可以和Condition配套使用。 ReentrantLock提供了多个并发编程相关的函数可供使用，相比于synchronized而言，灵活性更高。\nReentrantLock可支持锁是否是公平锁 ReentrantLock提供了常规的lock()上锁的函数之外，还提供了用于轮询使用的tryLock()函数和可被打断的lockInterruptly()函数 ReentrantLock上锁之后，可以根据业务等待不同的Condition ReentrantLock，可以是公平锁 package com.windypath.lockcondition; import java.util.concurrent.locks.ReentrantLock; public class Reen { int count = 0; final ReentrantLock lock = new ReentrantLock(true); void play() { int loopTimes = 1000; ReenThread t1 = new ReenThread(loopTimes, \u0026#34;t1\u0026#34;); ReenThread t2 = new ReenThread(loopTimes, \u0026#34;t2\u0026#34;); ReenThread t3 = new ReenThread(loopTimes, \u0026#34;t3\u0026#34;); ReenThread t4 = new ReenThread(loopTimes, \u0026#34;t4\u0026#34;); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Reen reen = new Reen(); reen.play(); } class ReenThread extends Thread { int loopTimes; public ReenThread(int loopTimes, String threadName) { super(threadName); this.loopTimes = loopTimes; } @Override public void run() { int times = 0; while (count \u0026lt;= 200000) { try { lock.lock(); count++; // System.out.println(getName() + \u0026#34; 输出 \u0026#34; + count); times++; } finally { lock.unlock(); } } System.out.println(getName() + \u0026#34;一共输出了 \u0026#34; + times + \u0026#34; 次\u0026#34;); } } } 输出结果如下：\nt3一共输出了 49953 次 t4一共输出了 49988 次 t1一共输出了 50077 次 t2一共输出了 49986 次 可以看到4个线程的输出基本都在50000左右。\nReentrantLock不使用Condition模拟哲学家就餐 哲学家就餐问题，即5个哲学家围在一个圆桌吃饭，但桌上只有5只筷子。哲学家思考结束后，需要同时获取左手边的筷子和右手边的筷子才能吃饭。 在这里，我们使用线程来模拟哲学家，使用ReentrantLock模拟筷子。\npackage com.windypath; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class DiningPhilosopher { public static void main(String[] args) { int numPhilosophers = 5; Philosopher[] philosophers = new Philosopher[numPhilosophers]; Chopstick[] chopsticks = new Chopstick[numPhilosophers]; for (int i = 0; i \u0026lt; numPhilosophers; i++) { chopsticks[i] = new Chopstick(); } for (int i = 0; i \u0026lt; numPhilosophers; i++) { Chopstick leftChopstick = chopsticks[i]; Chopstick rightChopstick = chopsticks[(i + 1) % numPhilosophers]; // philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); if (i % 2 == 0) { philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); } else { philosophers[i] = new Philosopher(i, rightChopstick, leftChopstick); } Thread thread = new Thread(philosophers[i]); thread.start(); } } static class Philosopher implements Runnable { private final int id; private final Chopstick leftChopstick; private final Chopstick rightChopstick; private int eatTimes = 0; public Philosopher(int id, Chopstick leftChopstick, Chopstick rightChopstick) { this.id = id; this.leftChopstick = leftChopstick; this.rightChopstick = rightChopstick; } private void think() throws InterruptedException { System.out.println(\u0026#34;Philosopher \u0026#34; + id + \u0026#34; is thinking.\u0026#34;); Thread.sleep((long) ( 1000)); } private void eat() throws InterruptedException { leftChopstick.pickUp(); rightChopstick.pickUp(); System.out.println(\u0026#34;Philosopher \u0026#34; + id + \u0026#34; picks up both chopsticks and eats.\u0026#34;); Thread.sleep((long) ( 1000)); System.out.println(\u0026#34;Philosopher \u0026#34; + id + \u0026#34; puts down both chopsticks.\u0026#34;); rightChopstick.putDown(); leftChopstick.putDown(); eatTimes++; if (eatTimes % 10 == 0) { System.out.println(\u0026#34;Philosopher \u0026#34; + id + \u0026#34; 目前吃了\u0026#34; + eatTimes + \u0026#34;次\u0026#34;); } } @Override public void run() { try { while (true) { think(); eat(); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } static class Chopstick { private final Lock lock = new ReentrantLock(); public void pickUp() { lock.lock(); } public void putDown() { lock.unlock(); } } } 在上面的代码中，筷子只需要在被哲学家拿起时调用lock()函数，在放下时调用unlock()函数即可完成“同时拥有左手边的筷子和右手边的筷子”的目标。\n使用Condition的代码： package com.windypath; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class DiningPhilosophers { public static void main(String[] args) { int numPhilosophers = 5; Philosopher[] philosophers = new Philosopher[numPhilosophers]; Chopstick[] chopsticks = new Chopstick[numPhilosophers]; for (int i = 0; i \u0026lt; numPhilosophers; i++) { chopsticks[i] = new Chopstick(); } for (int i = 0; i \u0026lt; numPhilosophers; i++) { Chopstick leftChopstick = chopsticks[i]; Chopstick rightChopstick = chopsticks[(i + 1) % numPhilosophers]; // philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); if (i % 2 == 0) { philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); } else { philosophers[i] = new Philosopher(i, rightChopstick, leftChopstick); } Thread thread = new Thread(philosophers[i]); thread.start(); } } static class Philosopher implements Runnable { private final int id; private final Chopstick leftChopstick; private final Chopstick rightChopstick; private int eatTimes = 0; public Philosopher(int id, Chopstick leftChopstick, Chopstick rightChopstick) { this.id = id; this.leftChopstick = leftChopstick; this.rightChopstick = rightChopstick; } private void think() throws InterruptedException { System.out.println(\u0026#34;Philosopher \u0026#34; + id + \u0026#34; is thinking.\u0026#34;); Thread.sleep((long) ( 1000)); } private void eat() throws InterruptedException { leftChopstick.pickUp(); rightChopstick.pickUp(); System.out.println(\u0026#34;Philosopher \u0026#34; + id + \u0026#34; picks up both chopsticks and eats.\u0026#34;); Thread.sleep((long) ( 1000)); System.out.println(\u0026#34;Philosopher \u0026#34; + id + \u0026#34; puts down both chopsticks.\u0026#34;); rightChopstick.putDown(); leftChopstick.putDown(); eatTimes++; if (eatTimes % 10 == 0) { System.out.println(\u0026#34;Philosopher \u0026#34; + id + \u0026#34; 目前吃了\u0026#34; + eatTimes + \u0026#34;次\u0026#34;); } } @Override public void run() { try { while (true) { think(); eat(); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } static class Chopstick { private final Lock lock = new ReentrantLock(true); private final Condition condition = lock.newCondition(); private boolean taken = false; public void pickUp() throws InterruptedException { lock.lock(); try { while (taken) { condition.await(); } taken = true; } finally { lock.unlock(); } } public void putDown() { lock.lock(); try { taken = false; condition.signal(); } finally { lock.unlock(); } } } } 可以看到，筷子类Chopstick加上了状态taken，用于判定目前筷子是否被某个哲学家拥有。 当第一个哲学家拥有某一只筷子的时候，taken为true；锁释放。当第二个哲学家拿起这只筷子时，还是会获得相同的锁，但会因为taken为true而进入condition.await()等待，此时也会释放锁，让其他哲学家能够获取这只筷子。 当筷子被放下时，调用signal()方法，此时之前await()函数的线程会被唤醒，执行其后序逻辑。\n如果不使用公平锁，那么输出里你可能会看到有两个哲学家很晚才吃10次。如果使用公平锁，则5个哲学家几乎是同步吃到10次。\n注意到在初始化哲学家时，奇数号哲学家的筷子是左右反过来拿的。这是因为在后续的获取筷子的逻辑中，我们总是先拿左手边的筷子，再拿右手边的筷子。如果不这样让一部分哲学家左右相反，那么会出现5个哲学家同时拿起左手边的筷子，然后等待右手边的筷子，造成死锁。（当然我们也可以通过随机数来让哲学家选择先左后右，还是先右后左。）\n","permalink":"https://windypath.com/posts/java_juc_briefly/","summary":"前言：本文想要介绍Synchronized，ReentrantLock和ReentrantLock的Condition的相关用法。\nSynchronized上锁 Synchronized可以修饰实例方法、静态方法和代码块。修饰代码块时，可以对具体的对象上锁，也可以对某个类(.class)上锁。\nSynchronized是非公平锁 以下代码是通过给一个多线程能访问到的变量使用synchronized进行上锁，实现有序打印数字的功能。并且在最后会统计不同线程打印数字的次数：\npackage com.windypath.lockcondition; public class Syn { int count = 0; final Object sth = new Object(); void play() { int loopTimes = 1000; SynThread t1 = new SynThread(loopTimes, \u0026#34;t1\u0026#34;); SynThread t2 = new SynThread(loopTimes, \u0026#34;t2\u0026#34;); SynThread t3 = new SynThread(loopTimes, \u0026#34;t3\u0026#34;); SynThread t4 = new SynThread(loopTimes, \u0026#34;t4\u0026#34;); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Syn syn = new Syn(); syn.play(); } class SynThread extends Thread { int loopTimes; public SynThread(int loopTimes, String threadName) { super(threadName); this.","title":"Java并发编程中上锁的几种方式"},{"content":"前言 在上机面试的时候，遇到了一道题，它的输入是两行字符串，每行字符串有未知数量的数字（两行数字数量一致），用空格分隔开，输入形如：\n12 34 567 888 99 100 358 74 58454 742 4469 88 并不提前提供每行的数字数量。而是让用户自己切分。\n当时在上机考试时，我没有使用C++实现这一功能，而是使用Java里的split()进行处理。\n后来，考试结束后，我上网查询C++切分字符串的写法，发现C++并没有原生提供类似split(某个字符)的写法。\n那么有什么方法能替代呢？\n方法1：使用string的find等函数()配合substr()进行切分 根据知乎大佬的回答，他提供的第一种解决方案是：\nC++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/36642771/answer/865135551\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; void split(const std::string\u0026amp; s, std::vector\u0026lt;std::string\u0026gt;\u0026amp; tokens, const std::string\u0026amp; delimiters = \u0026#34; \u0026#34;) { std::string::size_type lastPos = s.find_first_not_of(delimiters, 0); std::string::size_type pos = s.find_first_of(delimiters, lastPos); while (std::string::npos != pos || std::string::npos != lastPos) { tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s.find_first_not_of(delimiters, pos); pos = s.find_first_of(delimiters, lastPos); } } int main() { std::string str = \u0026#34;12 34 567 888 99 100\u0026#34;; std::vector\u0026lt;std::string\u0026gt; res; split(str, res, \u0026#34; \u0026#34;); for (auto r: res) { printf(\u0026#34;%s\\n\u0026#34;, r.c_str()); } return 0; } 输出结果：\n12 34 567 888 99 100 这个split()函数，通过记录两个下标来确定需要裁出的字符串。\n第一个下标lastPos，寻找从字符串开始后，第一个不是分隔符的字符下标； 第二个下标pos，寻找从lastPos之后，第一个是分隔符的字符下标。 如此一来，从lastPos到pos之间的字符串，就是我们需要裁出的字符串。 裁出第一个字符串后，将两个下标按之前的逻辑往后移动，直到两个下标都找不到合适的值（返回string::npos）时，结束。\n函数介绍： find_first_of() string的find_first_of()接收两个参数，第一个参数是要寻找的字符，它可能是string，char*或者char，第二个参数是开始寻找的下标（可以不传，默认传0）。 从第二个参数所指的字符串数组下标开始，往后寻找，直到找到要寻找的字符时，返回找到字符的下标。\nfind_first_not_of() string的find_first_not_of()接收的参数与find_first_of()一致，但它是寻找直到不是寻找字符时，返回不是寻找字符的下标。\nsubstr() 用于切分字符串，接收两个参数pos和len，从pos位置开始，切出往后len个长度的字符。不会修改原字符串。\n具体的C++文档位置：\nfind_first_of()：https://cplusplus.com/reference/string/string/find_first_of/ find_first_not_of()：https://cplusplus.com/reference/string/string/find_first_not_of/ substr()：https://cplusplus.com/reference/string/string/substr/\n方法2：C++11 正则表达式 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;regex\u0026gt; int main() { std::string str = \u0026#34;12 34 567 888 99 100\u0026#34;; std::regex ws_re(\u0026#34;\\\\s+\u0026#34;); std::vector\u0026lt;std::string\u0026gt; res( std::sregex_token_iterator( str.begin(), str.end(), ws_re, -1 ), std::sregex_token_iterator() ); for (auto r: res) { printf(\u0026#34;%s\\n\u0026#34;, r.c_str()); } return 0; } 这个例子是来自regex_token_iterator的介绍中。\nhttps://en.cppreference.com/w/cpp/regex/regex_token_iterator\n使用sregex_token_iterator()迭代器来进行切分操作（前面的s指代使用字符串类型string）。在这个例子中，9-11行中，构造了一个sregex_token_iterator迭代器，传入了4个参数，分别是：字符串的开始位置的迭代器，字符串结束的迭代器，正则表达式对象，是否使用匹配的部分（0使用，-1不使用）。\n构造sregex_token_iterator()时，确定了要从字符串开始位置，查找到字符串末尾，通过正则表达式匹配，然后查找不匹配的部分。\n该迭代器的末尾，是一个默认构造的sregex_token_iterator()对象。\nvector的构造函数中，可以通过传入两个迭代器，获取迭代器之间的元素。\n方法3：使用stringstream分割字符串（仅支持空格、回车、tab换行） 信息来源：https://www.cnblogs.com/narjaja/p/10044157.html\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::string str = \u0026#34;12 34 567 888 99 100\u0026#34;; std::vector\u0026lt;std::string\u0026gt; res; std::istringstream ss(str); std::string word; while(ss\u0026gt;\u0026gt;word) { res.push_back(word); } for (auto r: res) { printf(\u0026#34;%s\\n\u0026#34;, r.c_str()); } return 0; } 通过C++的 \u0026raquo; ，像用户cin一样，将字符串“输入”，从而得到切分的效果。\n如果要支持自定义分隔符，则可以使用getline()进行处理\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { std::string data = \u0026#34;1_2_3_4_5_6\u0026#34;; std::stringstream ss(data); std::string item; cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; while (std::getline(ss, item, \u0026#39;_\u0026#39;)) cout \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } 方法4：通过C语言的strtok()函数实现 第一种错误写法 还有一种做法是通过C语言的strtok()函数进行处理。 在网上能找到类似这样结构的代码：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { char str[] = \u0026#34;A B C D\u0026#34;; char* p = strtok(str, \u0026#34; \u0026#34;); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; while (p != NULL) { p = strtok(NULL, \u0026#34; \u0026#34;); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; } return 0; } 也能正常得到结果：\nA B C D 但是，当我打算在第11行进行cout输出时，发现结果并不会正常输出：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { char str[] = \u0026#34;A B C D\u0026#34;; char* p = strtok(str, \u0026#34; \u0026#34;); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; while (p != NULL) { p = strtok(NULL, \u0026#34; \u0026#34;); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;abc\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 此时输出的结果还是：\nA B C D 并没有最后的abc。\n问了ChatGPT后，得到的解释是：\n这段C++代码中的问题是在循环输出切割后的子字符串时，先打印p的值再进行下一次循环。这会导致在最后一次循环结束后，p被设置为NULL，然后再尝试打印p的值，导致未定义行为。\n在第8行，你打印了p的值，然后在第9行将其设置为下一个切割后的子字符串。接下来，在第10行的循环开始时，你再次打印p的值，但此时它可能已经为NULL，导致未定义行为。\n为了修复这个问题，你可以将打印语句移到循环的末尾，这样先进行下一次循环再打印p的值，确保p不为NULL。\n以下是修正后的代码：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { char str[] = \u0026#34;A B C D\u0026#34;; char* p = strtok(str, \u0026#34; \u0026#34;); while (p != NULL) { std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; p = strtok(NULL, \u0026#34; \u0026#34;); } std::cout \u0026lt;\u0026lt; \u0026#34;abc\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 这样修改后，代码将正常输出切割后的子字符串，然后输出\u0026quot;abc\u0026quot;。请注意，std::endl用于在输出后添加换行符，以保证输出结果的正确格式。\n第二种错误写法 #include \u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { char s[] = \u0026#34;A B C D\u0026#34;; char *p; const char *d = \u0026#34; \u0026#34;; p = strtok(s, d); while(p) { printf(\u0026#34;%s\\n\u0026#34;, p); p = strtok(NULL, \u0026#34; \u0026#34;); } printf(\u0026#34;abc\u0026#34;); return 0; } 这一次我们在循环体中，先输出上一次切分的p，再读取下一次的p。但字符串“abc”还是没有正常输出。ChatGPT解答如下：\nChatGPT\n这段代码中无法正常输出\u0026quot;abc\u0026quot;的原因是因为在使用strtok函数对字符串进行分割时，它会将原字符串中的分隔符替换为\u0026rsquo;\\0\u0026rsquo;（空字符）来分割子字符串。这导致原字符串s被修改，后续的printf语句在遇到\u0026rsquo;\\0\u0026rsquo;时会提前结束。\n在代码中，原字符串s的内容为\u0026quot;A B C D\u0026quot;，而strtok(s, d)会将它分割成\u0026quot;A\u0026quot;、\u0026ldquo;B\u0026rdquo;、\u0026ldquo;C\u0026quot;和\u0026quot;D\u0026quot;四个子字符串。因此，循环中的printf语句会输出这四个子字符串，分别为\u0026quot;A\u0026rdquo;、\u0026ldquo;B\u0026rdquo;、\u0026ldquo;C\u0026quot;和\u0026quot;D\u0026rdquo;。\n然后，在最后一次调用strtok(NULL, \u0026quot; \u0026ldquo;)时，由于已经没有分隔符了，strtok会返回NULL，结束循环。然后，代码中的printf(\u0026ldquo;abc\u0026rdquo;)会尝试输出\u0026quot;abc\u0026rdquo;，但是由于之前的strtok调用修改了原字符串s，将其中的空格替换为了\u0026rsquo;\\0\u0026rsquo;，所以在输出\u0026quot;abc\u0026quot;之前，printf函数遇到了\u0026rsquo;\\0\u0026rsquo;字符，将其视为字符串的结尾，导致输出提前结束。\n如果你希望能够输出\u0026quot;abc\u0026quot;，你可以在printf语句中添加换行符\\n，如下所示：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char s[] = \u0026#34;A B C D\u0026#34;; char *p; const char *d = \u0026#34; \u0026#34;; p = strtok(s, d); while (p) { printf(\u0026#34;%s\\n\u0026#34;, p); p = strtok(NULL, \u0026#34; \u0026#34;); } printf(\u0026#34;abc\\n\u0026#34;); // 在\u0026#34;abc\u0026#34;后添加换行符\\n return 0; } 通过上述修改，代码将能够正常输出\u0026quot;A\u0026quot;、\u0026ldquo;B\u0026rdquo;、\u0026ldquo;C\u0026rdquo;、\u0026ldquo;D\u0026quot;和\u0026quot;abc\u0026rdquo;。\nstrtok()函数 strtok()函数切割后，会在切断的位置上填充\\0，会修改原字符串。所以一定要多加注意，慎用这个函数。\n","permalink":"https://windypath.com/posts/how_to_split_a_string_in_cpp/","summary":"前言 在上机面试的时候，遇到了一道题，它的输入是两行字符串，每行字符串有未知数量的数字（两行数字数量一致），用空格分隔开，输入形如：\n12 34 567 888 99 100 358 74 58454 742 4469 88 并不提前提供每行的数字数量。而是让用户自己切分。\n当时在上机考试时，我没有使用C++实现这一功能，而是使用Java里的split()进行处理。\n后来，考试结束后，我上网查询C++切分字符串的写法，发现C++并没有原生提供类似split(某个字符)的写法。\n那么有什么方法能替代呢？\n方法1：使用string的find等函数()配合substr()进行切分 根据知乎大佬的回答，他提供的第一种解决方案是：\nC++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/36642771/answer/865135551\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; void split(const std::string\u0026amp; s, std::vector\u0026lt;std::string\u0026gt;\u0026amp; tokens, const std::string\u0026amp; delimiters = \u0026#34; \u0026#34;) { std::string::size_type lastPos = s.find_first_not_of(delimiters, 0); std::string::size_type pos = s.find_first_of(delimiters, lastPos); while (std::string::npos != pos || std::string::npos != lastPos) { tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s.","title":"如何用C++分割一个字符串？"},{"content":" 23年3月23日，我在公司进行了一次分享会，内容是本文的内容。在分享前，我重新对文章知识点进行了梳理，补充了很多细节。现将补充的细节重新编写到本文中。\n什么是二进制数？ 我们日常使用的是十进制，数字包括0,1,2,3,4,5,6,7,8,9 再往下数，就得向前进一位，变成10，然后从个位数开始继续增加11,12,13…19 计算机最底层使用的是二进制，数字包括0和1，再往下数，也是前进一位，变成10。注意，这个10并不是十进制的十，而是十进制的二。 如何用二进制来表示一个整数？ 二进制 十进制（无符号） 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15 二进制如何表示负数？ 原码 我们把最高位(最左边的位)作为符号位，后面剩余的位代表的数作为数值具体的大小。 比如：四位原码二进制表示数字\n— 3\n1 011\n开头的1代表负号，后面的011表示3。这样拼起来就是负3了 但是这么表示可能会有什么问题？\n原码表示负数存在的问题 0000和1000，都是表示数字0，但是一个是正0，一个是负0。这显然不符合我们对零的理解。 无法进行加减运算：观察以下式子1(0001) + (-3(1011)) = -4(1100) 0001 +1011 -\u0026mdash;\u0026mdash;- 1100 那么如何用二进制表示一个数字，才能处理加减操作呢？\n补码 以时钟为例，拨动时钟理解补码\n把红色指针从指向“8”拨动到“6”， 有几种方式？ 有两种方式，如图所示： 以此图为例，如果指针目前指向8(红色指针)，要把它拨到6（绿色指针），有两种方式：\n把8往逆时针方向旋转到6（蓝色）这种方式就是进行8-2=6 把8往顺时针方向旋转到6（黄色）这种方式是进行8+10=18，但是时钟只能显示12个数字，所以18-12=6 补码减法的逻辑是：通过加法，给数字加上一个超过表示上限的数，使其最高位“丢失”的方式来实现减法。\n如同我们调整时钟的时针，如果调整时针的转轴只能向顺时针方向调整，那么我们可以通过多转大半圈的方式来实现任意小时的调整。\n尝试用补码进行运算 考虑求解一个方程: 1 + x = 0\n0001\n+ x\n-\u0026mdash;\u0026mdash;\u0026ndash;\n0000\nX只能表示正数的话，那么这是一个无解的方程。 但是如果我们假设答案存在第五位的1，那么就可以进行运算\n0001\n+ x\n-\u0026mdash;\u0026mdash;\u0026ndash;\n10000\n计算结果 x = 1111。 由此，我们可以推断一件事：十进制的-1 ，可以用二进制的1111表示。\n让我们再做一题： 2 + x = -1 (十进制)\n0010\n+ x\n-\u0026mdash;\u0026mdash;\u0026ndash;\n1111\n对于二进制数，1111 \u0026gt; 0010， 所以我们不需要假设有“第5位”的存在，直接运算得到x = 1101,而其十进制答案为-3。\n找到规律了吗？ 至此我们发现了以下4个数的十进制和二进制的表示：\n二进制 十进制 1111 -1 0001 1 1101 -3 0011 3 我们发现，对负数的二进制，取反，再加1，就能得到负数的数值。\n如-3的二进制数1101取反为0010, 0010再加1得到0011，0011是3。\n解决问题的关键是我们人为划定了二进制表示整数的范围仅有4位，对于更高的第5位自然舍弃。\n提问：在四位二进制下，所有数字的相反数都能被表示吗？\n答：不是的，二进制1000这个数字，在四位二进制时没有办法被表示。\n至此，我们可以总结得到四位二进制下表示十进制（无符号）和十进制（补码）的情况：\n二进制 十进制（无符号） 十进制（补码） 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 -8 1001 9 -7 1010 10 -6 1011 11 -5 1100 12 -4 1101 13 -3 1110 14 -2 1111 15 -1 补码表示的新理解 关于补码，为了计算某个正数的相反数，可以用过取反+1的方式计算得到负数的补码表示。但是还有另一种方式能够更好的理解补码。 如果用5位来表示一个数：\n下标 4 3 2 1 0 代表的十进制数 每个下标的数值 -16 8 4 2 1 二进制数1 0 1 1 0 1 13 二进制数2 1 1 1 0 1 -3 二进制数3 1 1 1 1 1 -1 二进制数3 0 1 1 1 1 15 可以看到其实如果按照补码的逻辑，当使用5个位来存储数字时，最高位第5位作为符号位，它的数值为-16，其他第1到4位的数值为1、2、4、8，然后再对二进制数的各个位，乘以其对应的数值，再累加，就能得到十进制数的大小。 比如二进制数1，其十进制数=0*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = 13。 而负数二进制2，其十进制数=1*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = -3。\n我们现在已经知道-3的二进制补码表示是：11101，很容易能通过这个数值表得到正3的二进制补码表示是00011。 使用上面的“取反后+1”的公式，也可以将-3转为正3：~11101 + 1 = 00010 + 1 = 00011\n另外，还有两个比较有意思的内容：\n想获得某个二进制补码表示的最小的数，只需要让其符号位为1，其他位为0即可。 比如在5位表示数的情况下，最小的数是-16，即10000。 想获取-1，只需要让所有位都为1即可，那么想获得-1，可以直接用0按位取反。 二进制数的加法和乘法 二进制数的加法 二进制的加法与十进制的计算规则是一样的，当某一位的数大于1时，往前进一位。 对于无符号二进制数和补码二进制数，将数的每一位进行加法运算。 在不溢出的情况下，考虑两个4位无符号二进制数的加法：4+6=10： 0100\n+0110\n-\u0026mdash;\u0026mdash;\u0026ndash;\n1010\n加法溢出 再考虑两个四位无符号二进制数的加法\n1000\n+1000\n-\u0026mdash;\u0026mdash;\u0026ndash;\n10000\n但是最高位的1要被舍去，得到的二进制结果是0000，所以计算机在经过运算后，得到的结果是0。\n二进制数的乘法 二进制的乘法与十进制数的乘法的计算规则是一样的。\n十进制乘法 12\nx 34\n-\u0026mdash;\u0026mdash;\u0026ndash;\n48\n36\n-\u0026mdash;\u0026mdash;\u0026ndash;\n408\n二进制乘法 0011\nx 0101\n-\u0026mdash;\u0026mdash;\u0026ndash;\n0011\n0011\n-\u0026mdash;\u0026mdash;\u0026ndash;\n001111\n发生溢出，开头的00被舍弃。\n二进制按位左移和右移 按位左移 按位左移运算符 ( \u0026laquo;) 将其第一个操作数的位向左移动其第二个操作数中指定的位数。它还负责插入足够的零位以填充新位模式右边缘出现的间隙： 如图所示，100111 \u0026laquo; 1, 按位左移后，在最右侧补0，得到1001110\n对于无符号二进制数，左移n位，可以视为其乘以2的n次方(不考虑溢出情况)\n左移后，最高位丢失 但是一个数的位数是有限的，比如之前我们在讨论补码的时候，认为规定了是四位二进制数。 按位左移会丢失那些超过左边界的位，如图： 在这个由8个位组成的二进制数中，左移1位后， 最左边的1丢失，在最右边补0。\n逻辑右移 逻辑右移，也称为无符号右移或零填充右移，移动整个二进制序列，包括符号位，并用零填充左边的结果间隙：\n算数右移 算数右移，有时称为有符号右移运算符，通过在向右移动位之前复制其符号位来保持数字的符号： 在右移一位后，左边的符号位被复制之后保留下来。原来是负数的数，现在依旧还是负数 对于补码二进制数，算数右移n位，视为除以2的n次方（整除）。如1100(-4) \u0026raquo; 1 = 1110(-2)；1100 \u0026raquo; 2 = 1111(-1) 按位移动位的数量，系统默认帮你取模 来源：https://www.jianshu.com/p/304bfdda6b6a 控制硬件时，常涉及打开/关闭特定的位或查看他们的状态，一般都会使用到按位运算符技术。\n一个面试题：\nint a = 1, b = 32; print(\u0026#34;%d, %d\u0026#34;, a\u0026lt;\u0026lt;b, 1\u0026lt;\u0026lt;32); 答案是 1，0\na \u0026laquo; b 的结果是1，是因为运行时会将操作数b对32取模，然后在进行移位操作。\n布尔代数 所谓布尔代数，就是按位与（\u0026amp;），或（|），非（~），异或（^）。 需要注意和强调的是（应该已经强调无数遍了），\u0026amp;和\u0026amp;\u0026amp;不一样，|和||不一样，~和负号-不一样。\n按位与 一假即假\n0 \u0026amp; 0 = 0；1 \u0026amp; 0 = 0；0 \u0026amp; 1 = 0；1 \u0026amp; 1 = 1。\n按位或 一真即真\n0 | 0 = 0；1 | 0 = 1；0 | 1 = 1；1 | 1 = 1。\n按位非 ~1 = 0；~0 = 1。\n按位异或 相同为假，不同为真\n0 ^ 0 = 0；1 ^ 0 = 1; 0 ^ 1 = 1; 1 ^ 1 = 0。\n比较有意思性质：\n异或有一个性质是：a ^ a = 0， (a ^ b) ^ a = b（因为0 ^ b = b） (x | -x) \u0026raquo; 31 ，当x为0时依旧为0，当x不为0时，为-1 小端和大端字节序 简单记的话，就记一个数 0x12345678 存储地址从小到大依次从左到右（有语病，但意思是那个意思） 大端存的是12 34 56 78 小端存的是78 56 34 12\nC语言unsigned int，会导致问题 一般来说数组的长度是大于等于0的，所以在设计过程中，为了能多获得一位存储空间，有的人会设计使用unsigned int存储。在C语言有一个size_t类型，其定义就是long unsigned int 但在遍历过程中，有可能会出现肉眼难以察觉的bug。\n正常的代码：\nint a[5] = { 1, 2, 3, 4, 5 }; int cnt = 5; printf(\u0026#34;show values\\n\u0026#34;); for (int j = 0;j \u0026lt; cnt;j++) { printf(\u0026#34;a[%d]=%d\\n\u0026#34;, j, a[j]); } int i; printf(\u0026#34;start loop\\n\u0026#34;); for (i = cnt -2;i \u0026gt;= 0;i--) { printf(\u0026#34;in loop,%u %u\\n\u0026#34;, i, cnt); a[i] += a[i+1]; } printf(\u0026#34;end loop\\n\u0026#34;); printf(\u0026#34;show values\\n\u0026#34;); for (int j = 0;j \u0026lt; cnt;j++) { printf(\u0026#34;a[%d]=%d\\n\u0026#34;, j, a[j]); } 此段代码给出一个数组a，该数组有5个元素。然后进行的操作是从数组的后面往前累加，最终a数组的第一个元素是之前a数组各元素的总和。\n其运行结果如下：\nshow values a[0]=1 a[1]=2 a[2]=3 a[3]=4 a[4]=5 start loop in loop,3 5 in loop,2 5 in loop,1 5 in loop,0 5 end loop show values a[0]=15 a[1]=14 a[2]=12 a[3]=9 a[4]=5 如果我们把代码“int i”改成“size_t i”会如何呢？ 需要修改的错误代码：\nint a[5] = { 1, 2, 3, 4, 5 }; int cnt = 5; printf(\u0026#34;show values\\n\u0026#34;); for (int j = 0;j \u0026lt; cnt;j++) { printf(\u0026#34;a[%d]=%d\\n\u0026#34;, j, a[j]); } size_t i; printf(\u0026#34;start loop\\n\u0026#34;); for (i = cnt -2;i \u0026gt;= 0;i--) { printf(\u0026#34;in loop,%u %u\\n\u0026#34;, i, cnt); a[i] += a[i+1]; } printf(\u0026#34;end loop\\n\u0026#34;); printf(\u0026#34;show values\\n\u0026#34;); for (int j = 0;j \u0026lt; cnt;j++) { printf(\u0026#34;a[%d]=%d\\n\u0026#34;, j, a[j]); } 输出结果：\nshow values a[0]=1 a[1]=2 a[2]=3 a[3]=4 a[4]=5 start loop in loop,3 5 in loop,2 5 in loop,1 5 in loop,0 5 in loop,4294967295 5 in loop,4294967294 5 Segmentation fault (core dumped) 根据文章https://blog.csdn.net/wang93IT/article/details/72782379所说：\n有些时候我们在一段 C/C++ 代码的时候，由于对一个非法内存进行了操作，在程序运行的过程中，出现了“Segmentation fault (core dumped)”——段错误。\n可以看到当i为0的时候，i\u0026ndash;操作使i变成了一个特别大的数字，然后取a[i]时没有找到了非法内存，于是报错。 解决办法就是不要用size_t，也就是不要用无符号类型去作为下标索引。但如果a数组本身非常大呢？因为sizeof()函数的返回值类型就是size_t。\n不要担心，在CSAPP课上，老教授给出了一种解决方案，虽然不是很符合正常逻辑： 修改后的正常代码：\nint a[5] = { 1, 2, 3, 4, 5 }; int cnt = 5; printf(\u0026#34;show values\\n\u0026#34;); for (int j = 0;j \u0026lt; cnt;j++) { printf(\u0026#34;a[%d]=%d\\n\u0026#34;, j, a[j]); } size_t i; printf(\u0026#34;start loop\\n\u0026#34;); for (i = cnt -2;i \u0026lt; cnt;i--) { printf(\u0026#34;in loop,%u %u\\n\u0026#34;, i, cnt); a[i] += a[i+1]; } printf(\u0026#34;end loop\\n\u0026#34;); printf(\u0026#34;show values\\n\u0026#34;); for (int j = 0;j \u0026lt; cnt;j++) { printf(\u0026#34;a[%d]=%d\\n\u0026#34;, j, a[j]); } 仔细对比可以发现，在第二个for循环for (i = cnt -2;i \u0026lt; cnt;i--)中，其第二格判断条件从i \u0026gt;= 0改成了i \u0026lt; cnt。\n运行结果：\nshow values a[0]=1 a[1]=2 a[2]=3 a[3]=4 a[4]=5 start loop in loop,3 5 in loop,2 5 in loop,1 5 in loop,0 5 end loop show values a[0]=15 a[1]=14 a[2]=12 a[3]=9 a[4]=5 输出结果正常了。这是因为它借助了“无符号数减到（有符号数意义下的）负数时，会变成一个非常大的数”的性质。\n为什么无符号的0再减一个正数就会变成很大的数呢？ 以无符号0减去1为例： 假设有一个5位表示的数00000，如果这个数是二进制补码，则当00000减去1时，会得到11111。 11111在二进制补码中，指的是-1，但如果在无符号数中，它指的是UMax，也就是无符号数能表示的最大数。\n浮点数 浮点数，翻译自英文floating point，中文意思是漂浮不定的点。这里的“点”是“小数点”的意思。与浮点数相对应的是定点数。\n什么是定点数？ 定点数，也就是固定好小数点的位置，然后小数点前的位都用来表示整数部分，小数点后的位都用来表示小数部分。\n假设我们有1个字节，里面有8个二进制位：\n二进制位的数字 0 1 1 0 0 1 0 0 对应十进制的值 8 4 2 1 0.5 0.25 0.125 0.0625 现在，我用八位二进制表示了一个小数: 6.25\n十进制的科学计数法 浮点数表示小数的方式，使用了和十进制的科学计数法相似的思路，让我们先来复习一下十进制的科学计数法： 1234 -\u0026gt; 1.234 * 103 87.65 -\u0026gt; 8.765 * 101 -214.748 -\u0026gt; -2.14748 * 102 0.00314 -\u0026gt; 3.14 * 10-3\n可以看到通过乘以10的n次方，小数点被移动，可以被规范化的定义为：\na * 10b\nIEEE754规范下的浮点数 在IEEE754规范中，二进制小数也被定义为类似科学计数法的形式。 (-1)s * M * 2E\n其中：\ns是符号位，0为正数，1为负数 M是尾数，是一个二进制小数。在规格化的浮点数中，1\u0026lt;=M\u0026lt;2；在非规格化的浮点数中，0\u0026lt;=M\u0026lt;1。 E是阶码，是一个有符号整数 十进制与二进制对比 十进制 公式： a * 10b 要求：1≤|a|\u0026lt;10，a不为分数形式，n为整数\n二进制 公式：(-1)s * M * 2E 要求： s 用来表示符号，0正1负 M 尾数，是二进制小数，规格化浮点数下，1 ≤ M \u0026lt;2 E 阶码 是一个整数 二进制表示 将浮点数的位表示划分为三个字段，分别对这些值进行编码：\n一个单独的符号位s直接编码符号s n位的小数字段frac编码尾数M，但编码出来的值也依赖于解码字段的值是否等于0 k位的阶码字段exp编码阶码E 符号位s 公式：(-1)s * M * 2E\n当s为0时，此浮点数为正数；当s为1时，此浮点数为负数。\n因为M≥0，所以表示正负的特征就转移到s上。\n尾数M 在规格化浮点数下，1 ≤M\u0026lt;2，即M是一个1.xxxxx(2)的数，其中xxxxx代表小数部分。\nIEEE754规定，在计算机内部保存M时，默认这个数的整数部分总是1，所以可以被舍去，只保留后面的xxxxx小数部分。\n比如当M=1.01(2)时，只需要保存01(2)，等到读取的时候再把1加上去。\n这么做是为了节省一个位的空间。\n尾数M具体怎么表示？ M在二进制中存储在frac区域，其读数方式，是假定在frac位部分前已经有一个固定的小数点。\n由此读出下图绿色部分，frac位部分的小数的数值。\n最后在计算M时，将1 +frac部分代表的小数。\n比如，当M = 1.75(10)时，frac部分为110000…..00(2)\nfrac为110000…00(2) ，计算 .110000..00(2) 的十进制值为0.75(10),再加上1，为1.75(10)\n二进制位 符号位s 阶码位exp Frac位 Frac位 Frac位 Frac位 对应十进制小数的值 \u0026hellip;\u0026hellip; \u0026hellip;\u0026hellip; 0.5 0.25 0.125 0.0625 阶码E 阶码E可能是正数、0和负数。\n在IEEE754规定，计算机内部保存E时，存储的区域exp是表示一个无符号二进制数。\n如果exp的位数为8位，那么exp能表示的十进制值在0-255之间。为了能表示负数，IEEE754规定，exp的值需要减去一个中间数。\n对于8位exp，这个中间数是127。\n阶码E具体怎么表示？ E在二进制中存在exp区域，其读数方式是将其作为一个无符号二进制数读出数值。\n之后再减去一个“中间数”，也叫偏置(bias)。\nBias = 2k-1 – 1 , 其中k是exp区域的位数。当k为8时，bias=127\nE = exp – bias\n比如，当E=10时，exp区域有8位，bias=127，则exp要存储的十进制数位137(10), 对应的无符号二进制数为10001001\n阶码E的几种情况 exp部分表示的位，在以下几种不同的情况，表示的数和计算方式略有不同。\nexp不全为0也不全为1时，浮点数采用之前的读数方式，减去bias得到E。（规格化的数） exp全为0时，这时候的计算E的公式变为E=1-bias，与此同时，计算M的公式也改为M=frac。这么做是为了表示0，和数值非常接近于0的数。（非规格化的数） exp全为1时，当frac部分全为0时，表示无穷大；当frac部分不全为0时，表示“不是一个数” 无穷大 IEEE754浮点数可以表示无穷大，当exp 的所有位全为1，frac的所有位全为0时即可表示无穷大。\n如果s为0则表示正无穷大，s为1为负无穷大。\n通常用于处理一些无法用实数表示的结果，比如 1/0 = 无穷大。\n不是一个数（NaN） 当exp 的所有位全为1，frac的所有位不全为0时表示“不是一个数”。用于表示一个无法表示的数，如“根号下的-1” 或者 “无穷 - 无穷”。\n为什么会有非规格化的数？ 规格化的数无法表示0\n浮点数公式：(-1)s * M * 2E\n其中， 1 ≤ M \u0026lt;2，M不会等于0，因此IEEE754另外定义了非规格化的数，M=frac，使M的区间为0 ≤ M s\u0026lt; 1。如此一来，M就可以等于0了。\n接着，在二进制补码中，我们做到了用00000…000来代表0。因此我们希望在s和exp都为0时，浮点数的00000…000也代表0\n因此，在IEEE754有两种计算浮点数的规则，非规格化和规格化。\n在这两种数中，规格化的最小数为，exp为00000001，E为-126，M为1.0，即 1.0 * 2-126\n在非规格化的数中，M的最大值为0.11111(2)。如果按照规格化的数来计算阶码E，那么exp为00000000，E为-127，这样得到的值为\n0.111…111* 2-127\n比较0.111…111* 2-127 和1.0 * 2-126 ，我们发现这两个数如果不看E，只看M的话，是非常接近的。如果非规格化的数的E是-126的话，在最大的非规格化数与最小的规格化数之间，可以实现比较平滑的过渡。因此，IEEE754规定非规格化数的E=1-bias\n关于浮点数，非常形象的一张图 浮点数有五部分：\n0 非规格化部分 规格化部分 无穷 不是一个正数（NaN） 图片来自《深入理解计算机系统》第三版第80页。\n举个例子计算浮点数 计算规格化的值 前提：当exp的位模式既不全为0，也不全为1时。（既不是0000\u0026hellip;.0000，也不是1111\u0026hellip;.1111） 此时：\n尾数M=1+frac 阶码E=exp-Bias 其中偏置Bias = 2k-1 - 1 ， 注意，这里的k是指exp阶码位的位数 如0.875在8位浮点数（s符号-1位 exp阶码位-4位 frac尾数位-3位）中，如下表可查二进制位表示为： 00110110\n以下是计算过程： 列出公式：\n(-1)s * M * 2E\n第一部分，符号位s 符号位直接从二进制中读取：\ns=0\n第二部分：尾数M 尾数计算公式：\n尾数M=1+frac\n其中需要计算frac的具体数值：\nfrac位=110。我们假设在110前方有一个二进制的小数点，那么frac为 .110\n1 1 0 0.5 0.25 0.125 frac 二进制.110=十进制0.5+0.25=0.75 M = 1 + frac = 1 + 0.75 = 1.75\n第三部分：阶码E 阶码计算公式：\nE=exp-Bias\nk = 4（因为exp阶码是4位）；\nBias = 2k-1 - 1 = 2 4-1 -1 = 8-1=7\nexp = 0110 = 6\nE = exp - Bias = 6 - 7 = -1\n进行计算 至此，对于公式\n(-1)s * M * 2E\n我们有：\ns = 0 M = 1.75 E = -1 代入计算，V = (-1)^0 * 1.75 * 2 ^(-1) = 1.75 * 0.5 = 1.75 / 2 = 0.875\n计算非规格化的值 前提：当exp的位模式全为0时 此时：\n尾数M=frac 阶码E=1-Bias 偏置Bias = 2^（k-1） - 1 如0.005859在8位浮点数（s符号-1位 exp阶码位-4位 frac尾数位-3位）中，如下表可查二进制位表示为：\n00000011\n以下是计算过程：\n列出公式：\n(-1)s * M * 2E\n第一部分，符号位s 符号位直接从二进制中读取： s=0\n第二部分：尾数M 在非规格化的值中，尾数计算公式： 尾数M=frac 需要计算frac的具体数值： frac位=011。我们假设在011前方有一个二进制的小数点，那么frac为 .011\n0 1 1 0.5 0.25 0.125 frac 二进制.110=十进制0.25+0.125=0.375\nM = frac = 0.375\n第三部分：阶码E 非规格化数中，exp部分为0。\n公式为：\n阶码E=1-Bias\nk = 4（因为exp阶码是4位）；\nBias = 2k-1 - 1 = 2 4-1 -1 = 8-1=7\n因此：\nE = 1-7 = -6\n进行计算\n至此，对于公式\n(-1)s * M * 2E 我们有：\ns = 0 M = 0.375 E = -6 代入计算，V = (-1)^0 * 0.375 * 2 ^(-6) =0.375 * 0.015625 = 0.005859375。\n浮点数的“舍入” 因为浮点数有精度限制，所以在运算中，需要进行一定的舍入，从而用有限的位来表示最接近目标实数的浮点数。 IEEE标准要求使用“向偶数舍入”，不是我们常说的四舍五入，而是四舍六入，五向偶数舍入。 四舍六入下： 1.4 -\u0026gt; 1 1.6 -\u0026gt; 2\n向偶数舍入下： 1.5 -\u0026gt; 2 -1.5 -\u0026gt; -2 因为1.5两边的数字是1和2，要向偶数舍入，所以取2；同理，-1.5两边的数字是-1和-2，向偶数舍入，取-2。 关于二进制向偶数舍入，书上描述为：\n图片来自《深入理解计算机系统》第三版第84页。\n之所以这么做，是因为如果全部向上舍入/向下舍入，会出现统计偏差。而向偶数/奇数舍入，则有50%的几率向上舍入，50%向下舍入，从而避免统计偏差。\n关于溢出 不管是二进制补码、无符号数或者浮点数，都会存在溢出的情况。而溢出这个行为本身，C语言不会给出任何警告。所以只能通过良好的编程习惯和思维去避免。\n溢出部分在计算机中会舍去。这带来了一些问题。比如加法和乘法，很有可能超过了Tmax或者Umax。\n关于除法 除法运算是十分消耗资源和时间的。计算机发展到现在，除法依旧需要消耗大量的CPU时钟。 但由于我们存储整数使用的是二进制补码/无符号数，所以如果我们的除数是2的幂，则可以通过位移来进行除法运算。\n当负数需要进行除2的幂的时候，需要加上偏移量，来保证舍入正确。\n","permalink":"https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/","summary":"23年3月23日，我在公司进行了一次分享会，内容是本文的内容。在分享前，我重新对文章知识点进行了梳理，补充了很多细节。现将补充的细节重新编写到本文中。\n什么是二进制数？ 我们日常使用的是十进制，数字包括0,1,2,3,4,5,6,7,8,9 再往下数，就得向前进一位，变成10，然后从个位数开始继续增加11,12,13…19 计算机最底层使用的是二进制，数字包括0和1，再往下数，也是前进一位，变成10。注意，这个10并不是十进制的十，而是十进制的二。 如何用二进制来表示一个整数？ 二进制 十进制（无符号） 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15 二进制如何表示负数？ 原码 我们把最高位(最左边的位)作为符号位，后面剩余的位代表的数作为数值具体的大小。 比如：四位原码二进制表示数字\n— 3\n1 011\n开头的1代表负号，后面的011表示3。这样拼起来就是负3了 但是这么表示可能会有什么问题？\n原码表示负数存在的问题 0000和1000，都是表示数字0，但是一个是正0，一个是负0。这显然不符合我们对零的理解。 无法进行加减运算：观察以下式子1(0001) + (-3(1011)) = -4(1100) 0001 +1011 -\u0026mdash;\u0026mdash;- 1100 那么如何用二进制表示一个数字，才能处理加减操作呢？\n补码 以时钟为例，拨动时钟理解补码\n把红色指针从指向“8”拨动到“6”， 有几种方式？ 有两种方式，如图所示： 以此图为例，如果指针目前指向8(红色指针)，要把它拨到6（绿色指针），有两种方式：\n把8往逆时针方向旋转到6（蓝色）这种方式就是进行8-2=6 把8往顺时针方向旋转到6（黄色）这种方式是进行8+10=18，但是时钟只能显示12个数字，所以18-12=6 补码减法的逻辑是：通过加法，给数字加上一个超过表示上限的数，使其最高位“丢失”的方式来实现减法。","title":"CSAPP第二章-信息的表示与处理"},{"content":"欢迎 你好啊，我是本站的站长，我的花名是凌虚。\n“凌虚”是动漫《秦时明月》中，张良的佩剑名。凌虚剑身修长秀美,通体晶莹夺目,虽为利器却不见血腥之气,剑身之上有一十八颗碧血丹心,高贵儒雅之风浓重。而其持剑人为张良。取此花名，有暗含自己才智比肩张良之嫌。\n本站叫“风萧古道”，英文名是“WindyPath”。\n“风萧”来自于“风萧萧兮易水寒”；“古道”来自于“古道西风瘦马”。为了押韵，我把两个词拼在了一起，就是“风萧古道”。为了让外国友人能体会这个词的优雅，我翻遍英语词典，找到了两个单词，“Windy”和“Path”，然后将它们也拼起来，就是“WindyPath”。\n我 我目前是一个游戏服务器开发。之前还做过网页Web的全栈开发。现在已经不摆弄html标签了。 我19年毕业，20年底来到中国上海。我和计算机的其他故事可以到这里查阅。\n理想主义 有很长一段时间，我不知道要为何而学习软件开发。如果是为了挣钱，那么我现在也已经在挣钱了。那么在我漫长的软件开发生涯中，我要为了什么而继续前行呢？\nFor Chinese Software 为了中国软件。\n文章 本站文章更新频率不高，但是我经常查阅互联网上其他独立博客站长的文章。有的站长帖子多，但是大多是发牢骚(当微博发)，或者是转载(当笔记本/csdn)。这样的博客对于软件开发技术的水平的提升是没有什么效果的。\n所以我的博客里，只有一种文章：\n技术文章\n哪怕是牢骚，也必须是与软件行业相关的牢骚，确保所有来访者能从中了解或者学习一些东西。\n其他的日常生活的吐槽和牢骚就放到Twitter里。\n联系方式 Email: windypathblog@gmail.com Telegram: @windypath\n","permalink":"https://windypath.com/posts/about_myself/","summary":"欢迎 你好啊，我是本站的站长，我的花名是凌虚。\n“凌虚”是动漫《秦时明月》中，张良的佩剑名。凌虚剑身修长秀美,通体晶莹夺目,虽为利器却不见血腥之气,剑身之上有一十八颗碧血丹心,高贵儒雅之风浓重。而其持剑人为张良。取此花名，有暗含自己才智比肩张良之嫌。\n本站叫“风萧古道”，英文名是“WindyPath”。\n“风萧”来自于“风萧萧兮易水寒”；“古道”来自于“古道西风瘦马”。为了押韵，我把两个词拼在了一起，就是“风萧古道”。为了让外国友人能体会这个词的优雅，我翻遍英语词典，找到了两个单词，“Windy”和“Path”，然后将它们也拼起来，就是“WindyPath”。\n我 我目前是一个游戏服务器开发。之前还做过网页Web的全栈开发。现在已经不摆弄html标签了。 我19年毕业，20年底来到中国上海。我和计算机的其他故事可以到这里查阅。\n理想主义 有很长一段时间，我不知道要为何而学习软件开发。如果是为了挣钱，那么我现在也已经在挣钱了。那么在我漫长的软件开发生涯中，我要为了什么而继续前行呢？\nFor Chinese Software 为了中国软件。\n文章 本站文章更新频率不高，但是我经常查阅互联网上其他独立博客站长的文章。有的站长帖子多，但是大多是发牢骚(当微博发)，或者是转载(当笔记本/csdn)。这样的博客对于软件开发技术的水平的提升是没有什么效果的。\n所以我的博客里，只有一种文章：\n技术文章\n哪怕是牢骚，也必须是与软件行业相关的牢骚，确保所有来访者能从中了解或者学习一些东西。\n其他的日常生活的吐槽和牢骚就放到Twitter里。\n联系方式 Email: windypathblog@gmail.com Telegram: @windypath","title":"我的自我介绍"},{"content":"在这里直接下载我最后完成的虚拟机镜像 虚拟机镜像下载：\n链接：https://pan.baidu.com/s/1yfY0SjDrtOeuTiEWf7YizA?pwd=374l\n提取码：374l\n我本地的VirtualBox 版本：6.1\n我可以先聊聊怀旧吗 也许对于老外来说，Win95是他们的青春，所以他们做了React95这样的UI库，或者大家一起努力写了个操作系统serenity。但是对于咱们国内的用户而言，当家用PC走进千家万户时，映入眼帘的是——Windows XP。\n一位中国台湾同胞sh1zuku编写开发了一个网页版的Windows XP模拟器:项目链接，在线演示，还有另一位来自越南的老哥khang-nd写了Windows 7的网页模拟器在线演示。\n我自然没有能力和时间去编写类似系统的开发，但是有一个想法从我的脑中浮现：那么我就装一个Windows XP虚拟机到电脑上就好了。\n你可能会选择的做法 安装VirtualBox； 下载镜像：从MSDN Itellyou中找到Windows XP的镜像，下载； 在VirtualBox中安装镜像; 启动镜像，安装系统 那么你会发现，安装的Windows XP只有30天试用。在二十一世纪初期，盗版泛滥，微软采取了非常强硬的措施限制盗版。即使你安装时输入了正确的序列号，微软也会要求你使用电话等方式进行激活。\n但是我们是来怀旧的啊！\n正确的做法 不能再使用这种正版的镜像了，需要使用别人处理好的，不需要激活的镜像。\n这里我找到了github上的一位老哥提供的链接github WinXPImage，但是他的镜像是位于谷歌云盘上的。我把它下载之后放进百度网盘里了：\n链接：https://pan.baidu.com/s/1ypKeaZixJXnbqAo4ZT0YLQ?pwd=30dd 提取码：30dd\n在VirtualBox安装此镜像后，你将获得一个无限期使用的，英文版的Windows XP。\n但你不一定能启动起来，你需要在导入OVA文件后，在OVA文件的目录下，执行以下命令：\nvbox-img geometry --filename Windows_XP_Professional-disk1.vdi --format VDI --cylinders 5874 --heads 255 --sectors 56 来自于github issue streeg 老哥给出的解决方案。\n如何汉化Windows XP？ 如果只是用英文版Windows XP，那么就达不到我们“怀旧”的目的了。 Windows XP英文版默认没有中文语言包。 我翻遍互联网，终于在一个犄角旮旯里找到了语言包mui_win_xp_pro_n_cd1.iso。\n我把它下载之后放进百度网盘里了：\n链接：https://pan.baidu.com/s/18mW9OCRejMDoEpUcih-zlA?pwd=peu4 提取码：peu4\n然后,\n设置VirtualBox里Windows XP虚拟机和物理机共享文件夹，具体方法 将mui_win_xp_pro_n_cd1.iso通过共享文件夹从物理机传进虚拟机中 安装，具体方法 最后重启虚拟机即可。\n上图! ","permalink":"https://windypath.com/posts/nostalgic_winxp/","summary":"在这里直接下载我最后完成的虚拟机镜像 虚拟机镜像下载：\n链接：https://pan.baidu.com/s/1yfY0SjDrtOeuTiEWf7YizA?pwd=374l\n提取码：374l\n我本地的VirtualBox 版本：6.1\n我可以先聊聊怀旧吗 也许对于老外来说，Win95是他们的青春，所以他们做了React95这样的UI库，或者大家一起努力写了个操作系统serenity。但是对于咱们国内的用户而言，当家用PC走进千家万户时，映入眼帘的是——Windows XP。\n一位中国台湾同胞sh1zuku编写开发了一个网页版的Windows XP模拟器:项目链接，在线演示，还有另一位来自越南的老哥khang-nd写了Windows 7的网页模拟器在线演示。\n我自然没有能力和时间去编写类似系统的开发，但是有一个想法从我的脑中浮现：那么我就装一个Windows XP虚拟机到电脑上就好了。\n你可能会选择的做法 安装VirtualBox； 下载镜像：从MSDN Itellyou中找到Windows XP的镜像，下载； 在VirtualBox中安装镜像; 启动镜像，安装系统 那么你会发现，安装的Windows XP只有30天试用。在二十一世纪初期，盗版泛滥，微软采取了非常强硬的措施限制盗版。即使你安装时输入了正确的序列号，微软也会要求你使用电话等方式进行激活。\n但是我们是来怀旧的啊！\n正确的做法 不能再使用这种正版的镜像了，需要使用别人处理好的，不需要激活的镜像。\n这里我找到了github上的一位老哥提供的链接github WinXPImage，但是他的镜像是位于谷歌云盘上的。我把它下载之后放进百度网盘里了：\n链接：https://pan.baidu.com/s/1ypKeaZixJXnbqAo4ZT0YLQ?pwd=30dd 提取码：30dd\n在VirtualBox安装此镜像后，你将获得一个无限期使用的，英文版的Windows XP。\n但你不一定能启动起来，你需要在导入OVA文件后，在OVA文件的目录下，执行以下命令：\nvbox-img geometry --filename Windows_XP_Professional-disk1.vdi --format VDI --cylinders 5874 --heads 255 --sectors 56 来自于github issue streeg 老哥给出的解决方案。\n如何汉化Windows XP？ 如果只是用英文版Windows XP，那么就达不到我们“怀旧”的目的了。 Windows XP英文版默认没有中文语言包。 我翻遍互联网，终于在一个犄角旮旯里找到了语言包mui_win_xp_pro_n_cd1.iso。\n我把它下载之后放进百度网盘里了：\n链接：https://pan.baidu.com/s/18mW9OCRejMDoEpUcih-zlA?pwd=peu4 提取码：peu4\n然后,\n设置VirtualBox里Windows XP虚拟机和物理机共享文件夹，具体方法 将mui_win_xp_pro_n_cd1.iso通过共享文件夹从物理机传进虚拟机中 安装，具体方法 最后重启虚拟机即可。\n上图! ","title":"Windows XP虚拟机中文版无需激活下载"},{"content":"先看一个例子（kotlin实现） import java.util.TreeSet /** * 定义一个用于测试TreeSet集合的结构 * 用TreeSet进行排名 * id: 玩家id * score: 玩家得分 */ data class PlayerScore(var id: Int, var score: Int): Comparable\u0026lt;PlayerScore\u0026gt; { override fun compareTo(other: PlayerScore): Int { return if (score \u0026gt; other.score) { 1 } else if (score \u0026lt; other.score) { -1 } else { 0 } } } fun main() { //创建一个TreeSet val treeSet: TreeSet\u0026lt;PlayerScore\u0026gt; = TreeSet() //创建3个PlayerScore，其中对id为101的对象存一个引用 //将3个PlayerScore装入set中 val id101Obj = PlayerScore(101,100) //按不同的顺序加入TreeSet treeSet.add(PlayerScore(102,200)) treeSet.add(id101Obj) treeSet.add(PlayerScore(103,300)) println(\u0026#34;按不同的顺序加入TreeSet，按score从小到大输出:\u0026#34;) showTreeSet(treeSet) println(\u0026#34;再加入重复id，但分数不同的对象，按score从小到大输出:\u0026#34;) treeSet.add(PlayerScore(101,500)) showTreeSet(treeSet) println(\u0026#34;直接修改id为101的对象的分数为400，按score从小到大输出:\u0026#34;) id101Obj.score = 400 showTreeSet(treeSet) } private fun showTreeSet(treeSet: TreeSet\u0026lt;PlayerScore\u0026gt;) { treeSet.forEachIndexed { index, s -\u0026gt; println(\u0026#34;排名:${index+1} 分数:${s.score} id:${s.id}\u0026#34;) } println() } 运行结果：\n按不同的顺序加入TreeSet，按score从小到大输出: 排名:1 分数:100 id:101 排名:2 分数:200 id:102 排名:3 分数:300 id:103 再加入重复id，但分数不同的对象，按score从小到大输出: 排名:1 分数:100 id:101 排名:2 分数:200 id:102 排名:3 分数:300 id:103 排名:4 分数:500 id:101 直接修改id为101的对象的分数为400，按score从小到大输出: 排名:1 分数:400 id:101 排名:2 分数:200 id:102 排名:3 分数:300 id:103 排名:4 分数:500 id:101 分析 首先，PlayerScore继承Comparable接口，实现了从小到大排序。在最开始只有3条数据时，按照不同的顺序插入TreeSet，可以正常的完成排序。\n之后玩家101的分数发生改变，需要重新给玩家进行排名，我们分别通过两种方式进行操作：\n通过id101Obj的引用来对这个对象的分数进行修改； 通过再往TreeSet中加入一个id为101，分数不同于之前的分数的对象。 结果： 第一种方式：玩家的积分被修改了，但是排名依旧为第1； 第二种方式：虽然积分正常排序，但是有两个id为101的对象。\n所以如果我们的玩家积分发生改变的时候，要如何才能正常排序呢？\n可以对某个对象先从TreeSet中删除，再往TreeSet中插入。这是因为TreeSet的底层是红黑树，在删除和插入的时候，会对树结构进行调整。 代码如下：\n//创建一个TreeSet val treeSet: TreeSet\u0026lt;PlayerScore\u0026gt; = TreeSet() //创建3个PlayerScore，其中对id为101的对象存一个引用 //将3个PlayerScore装入set中 val id101Obj = PlayerScore(101,100) //按不同的顺序加入TreeSet treeSet.add(PlayerScore(102,200)) treeSet.add(id101Obj) treeSet.add(PlayerScore(103,300)) println(\u0026#34;按不同的顺序加入TreeSet，按score从小到大输出:\u0026#34;) showTreeSet(treeSet) treeSet.remove(id101Obj) id101Obj.score = 400 treeSet.add(id101Obj) println(\u0026#34;先将id101Obj从TreeSet中删除，修改值，然后再插入TreeSet中，按score从小到大输出:\u0026#34;) showTreeSet(treeSet) 结果如下：\n按不同的顺序加入TreeSet，按score从小到大输出: 排名:1 分数:100 id:101 排名:2 分数:200 id:102 排名:3 分数:300 id:103 先将id101Obj从TreeSet中删除，修改值，然后再插入TreeSet中，按score从小到大输出: 排名:1 分数:200 id:102 排名:2 分数:300 id:103 排名:3 分数:400 id:101 更进一步 先删后加的方式是可以完成排序，但是TreeSet本身是线程不安全的。如果有多个线程都要更新玩家积分和排名，那么大概率会存在问题。 TreeSet虽然可以边插边排序，但是它只允许一次插入，插入之后积分的修改并不会修改排序。\n对于排行榜上的排名经常变动的情况，用TreeSet是不太合理的。\n另一种排行榜实现 本来选用TreeSet，是因为TreeSet拥有“边插入边排序”的特点，但在排行榜需要更新时并不方便。 那么换一种思路，如果只用变长的ArrayList来存储玩家积分对象，同样是在插入/更新/删除时进行排序？\n先插入/更新/删除，对ArrayList内的数据进行修改，然后进行排序。\n","permalink":"https://windypath.com/posts/about_java_treeset/","summary":"先看一个例子（kotlin实现） import java.util.TreeSet /** * 定义一个用于测试TreeSet集合的结构 * 用TreeSet进行排名 * id: 玩家id * score: 玩家得分 */ data class PlayerScore(var id: Int, var score: Int): Comparable\u0026lt;PlayerScore\u0026gt; { override fun compareTo(other: PlayerScore): Int { return if (score \u0026gt; other.score) { 1 } else if (score \u0026lt; other.score) { -1 } else { 0 } } } fun main() { //创建一个TreeSet val treeSet: TreeSet\u0026lt;PlayerScore\u0026gt; = TreeSet() //创建3个PlayerScore，其中对id为101的对象存一个引用 //将3个PlayerScore装入set中 val id101Obj = PlayerScore(101,100) //按不同的顺序加入TreeSet treeSet.add(PlayerScore(102,200)) treeSet.","title":"Java TreeSet的一些用法和特性"},{"content":" 本文主要介绍Linux C++ 基础Socket网络编程。 大部分知识来自于网站：https://www.geeksforgeeks.org/socket-programming-cc/\nSocket编程状态图 从图中可以看到，服务端这边需要处理四步才能进入等待连接的状态，而客户端只要两步。\nSocket编程中各函数简单解析 本解析仅为自己理解所用，可能有些纰漏，有则改之。 原文中的知识总结得比我更好，尽量参考原文，我的理解仅做辅助之用。\n服务端 先说服务端。服务端需要指定好端口并监听，所以需要bind()绑定好端口，需要listen()进入监听状态，然后通过accept()阻塞等待客户端的消息。\n引用表：\n#include \u0026lt;sys/socket\u0026gt; socket() setsockopt() bind() listen() accept() #include \u0026lt;netinet/in.h\u0026gt; struct sockaddr_in #include \u0026lt;unistd.h\u0026gt; read() #include \u0026lt;arpa/inet.h\u0026gt; inet_pton() socket() 这个函数是用来创建一个socket，3个参数中，需要特别传的就是前两个。返回一个socket编号，是个int值。\nint sockfd = socket(domain, type, protocol)\ndomain: IPV4 用 AF_INET， IPV6 用 AF_INET6 type: TCP 用 SOCK_STREAM, UDP 用 SOCK_UGRAM\nsetsockopt() 这个函数用来给上面那个socket()函数返回的socket设置属性，作为服务端，为了方便？ 可以设置重用地址和端口号。\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 为了重用地址和端口号，需要这么做：\nlevel传SOL_SOCKET，代表你这次设置的属性值是给哪个模块用的 optname传SO_REUSEADDR|SO_REUSEPORT，代表你打算同时设置这两个属性 optval传一个int*指针，指向某一个数字 optlen传sizeof()上面的optval C++ socket很多函数都需要你再传一个length长度，以确定你真正想传给这个函数的数据是多长。\nsockaddr_in 那么地址在socket编程中是怎么表示的呢？是使用struct sockaddr_in来定义的。 用的时候需要设置3个值：sin_family, sin_addr的s_addr, sin_port\nsin_family：和前面socket()的domain一样，AF_INET sin_addr.s_addr：这个属性是将我们的点分十进制ip地址转化为一个数字，需要使用专门的函数来处理，比如inet_pton() sin_port: 指定端口号，但是不是直接传一个int数字，需要用htons转成16进制的数字 bind() 这个函数用来给socket绑定地址信息。\n上一节已经说了地址怎么设置，这一节讲socket绑定地址。\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n照例将sockFd和address关联即可。\n注意 这里的addr的类型是struct sockaddr * 而不是struct sockaddr_in *。 struct sockaddr的结构里并没有提供存放ip地址，端口号的属性，所以需要用struct sockaddr_in来强制类型转换。 在文档中，作者说struct sockaddr和struct sockaddr_in长度一定是一样的，所以一定可以强制类型转换，让大家不要担心。 https://www.gta.ufrj.br/ensino/eel878/sockets/sockaddr_inman.html 注意，后面的addrlen是一个值，不是指针。\nlisten() int listen(int sockfd, int backlog); 这个函数将socket切换为被动模式，进入监听状态。第二个参数backlog指定消息等待队列的最大长度。\naccept() int new_socket= accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 函数执行之后，socket就会等待客户端的连接。当连接建立之后，返回一个用于通信的新的socket，这个新的socket用于客户端与服务端之间的通信。\n注意：accept()的第三个参数socklen_t *addrlen和bind()的第三个参数socklen_t addrlen不一样，accept需要一个指针。 有人说是accept()的参数是双向参数，会更新地址的长度值，但也有人说是在accept()函数里，它不知道int能不能存的下这个长度，万一长度特别大就不好存了，为了统一存储结构，仅传一个指针即可。\nsend() send()用于通过socket来给对方发送消息。\nread() read()函数是放在#include \u0026lt;unistd.h\u0026gt;中的。函数通过一个char数组来存储接收到的消息\n客户端 再说服务端。客户端需要指定好ip地址和端口号，然后发起连接。\nconnect() int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n客户端也要创建一个socket，指定sockaddr_in然后强转。这个socket不仅负责发起连接，也负责发送，接收数据。\n示例代码（没有错误处理） 目前我只想学习这些socket底层api，所以不想浪费过多精力去记住api的返回值可能意味着什么错误，仅专注于能正常实现一个最简单的server和client。\n服务器server端 server.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; #define PORT 8000 int main() { int sockFd, newSockFd, valread; int opt = 1; char buffer[1024] = {0}; char* helloFromServer = \u0026#34;hello from server\u0026#34;; struct sockaddr_in address; sockFd = socket(AF_INET, SOCK_STREAM, 0); setsockopt(sockFd, SOL_SOCKET, SO_REUSEADDR|SO_REUSEPORT, \u0026amp;opt, sizeof(opt)); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); int addrlen = sizeof(address); bind(sockFd, (struct sockaddr*)\u0026amp;address, addrlen); listen(sockFd, 3); newSockFd = accept(sockFd, (struct sockaddr*)\u0026amp;address, (socklen_t*)\u0026amp;addrlen); read(newSockFd, buffer, 1024); printf(\u0026#34;receive: %s\\n\u0026#34;, buffer); send(newSockFd, helloFromServer, strlen(helloFromServer), 0); printf(\u0026#34;server sent message\\n\u0026#34;); return 0; } 客户端client端 client.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define PORT 8000 using namespace std; int main() { int sockFd = 0; char buffer[1024] = {0}; char* helloFromClient = \u0026#34;hello from client\u0026#34;; struct sockaddr_in address; address.sin_family = AF_INET; inet_pton(AF_INET, \u0026#34;127.0.0.1\u0026#34;, \u0026amp;address.sin_addr.s_addr); address.sin_port = htons(PORT); sockFd = socket(AF_INET, SOCK_STREAM, 0); connect(sockFd, (struct sockaddr*)\u0026amp;address, sizeof(address)); send(sockFd, helloFromClient, strlen(helloFromClient), 0); printf(\u0026#34;client sent\\n\u0026#34;); read(sockFd, buffer, 1024); printf(\u0026#34;read message:%s\\n\u0026#34;, buffer); return 0; } 编译、运行和目标输出 在linxu命令行下，分别输入：\ng++ -o server server.cpp g++ -o client client.cpp 然后开两个控制台，分别输入：\n./server ./client 目标输出为： server输出：\nreceive: hello from client server sent message client输出：\nclient sent message receive: hello from server ","permalink":"https://windypath.com/posts/linux_socket_programming/","summary":"本文主要介绍Linux C++ 基础Socket网络编程。 大部分知识来自于网站：https://www.geeksforgeeks.org/socket-programming-cc/\nSocket编程状态图 从图中可以看到，服务端这边需要处理四步才能进入等待连接的状态，而客户端只要两步。\nSocket编程中各函数简单解析 本解析仅为自己理解所用，可能有些纰漏，有则改之。 原文中的知识总结得比我更好，尽量参考原文，我的理解仅做辅助之用。\n服务端 先说服务端。服务端需要指定好端口并监听，所以需要bind()绑定好端口，需要listen()进入监听状态，然后通过accept()阻塞等待客户端的消息。\n引用表：\n#include \u0026lt;sys/socket\u0026gt; socket() setsockopt() bind() listen() accept() #include \u0026lt;netinet/in.h\u0026gt; struct sockaddr_in #include \u0026lt;unistd.h\u0026gt; read() #include \u0026lt;arpa/inet.h\u0026gt; inet_pton() socket() 这个函数是用来创建一个socket，3个参数中，需要特别传的就是前两个。返回一个socket编号，是个int值。\nint sockfd = socket(domain, type, protocol)\ndomain: IPV4 用 AF_INET， IPV6 用 AF_INET6 type: TCP 用 SOCK_STREAM, UDP 用 SOCK_UGRAM\nsetsockopt() 这个函数用来给上面那个socket()函数返回的socket设置属性，作为服务端，为了方便？ 可以设置重用地址和端口号。\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 为了重用地址和端口号，需要这么做：\nlevel传SOL_SOCKET，代表你这次设置的属性值是给哪个模块用的 optname传SO_REUSEADDR|SO_REUSEPORT，代表你打算同时设置这两个属性 optval传一个int*指针，指向某一个数字 optlen传sizeof()上面的optval C++ socket很多函数都需要你再传一个length长度，以确定你真正想传给这个函数的数据是多长。","title":"Linux C++ Socket实战"},{"content":" 项目 智能客服 爬虫 SLG游戏 语言 java python kotlin 模型 异步事件驱动 可能没什么模型可言 actor模型 传输协议 http http tcp + netty 传输结构 json json protobuf 数据库 oracle，redis mongodb mysql,redis 数据库框架 mybatis python库（类似jdbc） hibernate 缓存架构 管理员登录状态用redis 可能只缓存了页码 所有游戏用的数据全部缓存，每隔一段时间写到数据库中 配置信息 只有application.properties config.ini zookeeper，启动前需要将策划表信息刷到zk 并发 无并发（所以根本没用到锁） python多线程同时爬多个网站 无并发actor模型保证一次只做一件事 热更 直接重启 无 继承某个类的某个方法，替换掉线上的类 架构一览 智能客服服务端整体架构 SLG游戏整体架构 典型案例 智能客服聊天 graph LR A[客户端]--\u003e|http聊天消息|B[智能客服系统]--\u003e|将聊天信息放入mq|C[智能问答模型]--\u003e|问答信息记录|D[Oracle数据库] SLG游戏士兵出征 graph LR A[客户端]--\u003e|tcp发送的protobuf|B[Gate的Netty解包]--\u003e|actor内部消息转发|C[WorldActor校验外城沙盘各种状态]--\u003e|actor内部消息转发|D[playerActor内城校验和获取buff] 其中worldActor和playerActor都通过读取内存的方式读取到需要的数据，并不直接读取mysql数据库。 内存里的数据每隔一段时间（30秒左右）将变化的数据通过hibernate的方法更新到mysql中。\n配置信息读取 对于智能客服来说，由于并发量业务量很少（因为投放的平台比较少，且晚上凌晨基本没什么人使用，且重启速度很快），有一些需求上的配置数值（比如发送几次“转人工”才进入转人工通道）是直接硬写在业务里的；也有一些配置信息是其他系统的请求地址url，会配在application.properties里。没有使用excel统一存储各个功能模块的配置信息，也确实不需要。\n但对于游戏来说，数值这块的配置至关重要，与玩法，奖励，游戏内生态息息相关。因此在游戏服务器里，所有的数值几乎都要从配置表中读取。目前Excel应该是处理数据能力最强的软件了，策划可以通过Excel非常快速的把数值配好。 启动服务器的时候要读取配置表到内存（广义上的）里。但在有了zookeeper这样的工具出现之后，配置表数据可以放在zk中，需要的时候再取出来。\n游戏服务器优势 传输结构为protobuf 服务器接收和发送的数据都是ProtoBuf转成的二进制，从而实现客户端服务器端统一的传输结构。protobuf自己有编码解码二进制的功能，从而实现消息数据的大小达到最小，编码解码是由netty执行的，使用上只需要将protobuf生成的对象传给netty即可。这边用的protobuf是v2版本的，有required，optional和repeated三种关键字，分别对传输message里的属性作出了约束。\nAkka Actor架构 Actor架构实现单线程的业务逻辑，开发过程中不需要对一些公用的属性上锁；通过内部消息的通讯，让数据处理有序进行。Akka cluster集群有动态负载均衡的功能，可以进行平行扩展，也就是说，如果一台服务器扛不住并发，只要再配置一台或几台新服务器，加入集群就可以完成负载均衡。\n配置表信息Zookeeper存储 通过将Excel数据表信息读取到java代码中，再转成二进制放入zk里，随时读取，从而完成了配置表的热更新。\n数据在服务器启动后，缓存在内存中，间隔一定时间刷入库中 游戏服务器不直接操作数据库，而是操作内存中的数据。内存中的数据每隔一段时间，将数据变化更新到数据库中。如此一来，并发IO特别大的时候，也只是对内存中的数据进行修改，不会直接操作数据库。\n两个系统中存在的问题 智能客服 抽取报表时直接用Oracle关联查询，效率太低，且没有读写分离 智能客服的报表是实时的，是通过一个特别长的，用union拼接的sql写的。所以查询速度非常慢。在线上环境，选定一个超过14天的时间区间，勾选多个报表评估项，查询时间超过30秒。也就是说sql执行了近30秒。当时一直说要优化优化，但是最后也没想出什么办法。\n后来我也接触了一些报表，一般是将生的，未处理过的数据通过消息队列发给另一个日志收集库，可能会叫它数据仓库。然后另外有一个系统从数据仓库里抽取并统计数据。 另一种是抽取报表时只查询今天以前的数据，然后每天结束时24点之后执行某一个定时任务，统计更新报表数据。\n当然了这些举措都导致了不能实时展示最新报表数据了，这也是一种取舍。\n聊天记录日志设计不合理 聊天记录表每一行记录都包含了发送人和聊天会话的各种信息，存储了过多的状态（因为存在聊天记录评价这种特殊消息，所以结构发生了很大变化）。 有可能是最初只考虑了文字，后面加入了图片（支持html又有html注入风险），后面又出了“猜你想问”气泡，但猜你想问本身不计入聊天记录，又需要特殊处理。\n由于没有安排重构，导致开发到后期，前后端代码都非常混乱。\nSLG游戏服务器 热更问题 项目越庞大，遇到的问题就会越多。问题越多，修复更新到线上的速度当然要越快越好。得益于java的继承功能，我们可以通过继承某个装有业务逻辑的类，重新重写某个之前有问题的函数，修正为正确的业务逻辑，以完成线上玩家无感知的热更新。但是这并不能完全覆盖每一个线上问题。除了业务逻辑类之外，还有数据处理存储类，而数据处理存储类是不能热更的，因为它们是与定时落库逻辑强关联的类。有的业务逻辑被开发人员写在数据处理存储类中，就不能热更修改了。 还有一些属性被加上了private标识符，导致没办法直接取出来，只能用反射拿。\n节点之间通信 Akka Actor是单线程，但不意味着整个系统都是单线程的。为了提高效率，我们根据业务逻辑，按照功能模块，分出了维护不同数据的Actor，比如网关Gate，外城沙盘World，内城玩家本身Home，联盟Alliance，全服排行榜Rank\u0026hellip;.但是这么一来，会有一些本应该由多个节点共享的数据，不得不需要用服务器内部消息来回同步。\n比如说有一个运营活动，是关于某个人打沙盘上的某个怪，然后给自己和联盟增加积分。那么这时候，World，Home，Alliance三个节点都需要各自保存一份活动的开启时间和关闭时间。当然还有一种办法，是在zookeeper上分配一个json对象，存储当前的活动信息。但是这么一来，如果所有比较复杂的活动都使用这种方式，到最后zookeeper会存储过多的不常用的数据。\n其他系统 智能客服边缘系统：知识库系统 本来的目的是将智能客服的语料信息单独抽出作为一个独立的子系统，但后来由于语料信息与智能客服本体关联太紧，导致没有办法抽出来。\n为了实现模糊查询，使用了es作为存储数据库。 其中存在一个问题，就是关系型数据库与非关系型数据库的矛盾之处。 大概是用关系型数据库可以方便管理数据，减少数据冗余，但失去了es模糊查询倒排索引的能力。 但直接用菲关系型数据库的话，会让系统中其他数据库的表无法直接关联，被迫需要用服务的方式来获取资源，增加系统开销 如果在关系型的oracle和非关系型的es各存一份，则会出现数据不同步的问题，被迫需要定时任务去同步两个库，甚至还需要从两个库中作出鉴别，类似于git，svn等做版本管理。\n游戏服务器：运维GM 发送补丁到线上服务器，替换线上服务器的某个类的某个方法的实现，从而完成玩家无感知的热更新 发送groovy脚本到线上服务器，在线上服务器上执行一段通过groovy编写的业务逻辑 ","permalink":"https://windypath.com/posts/compare_web_with_game_server/","summary":"项目 智能客服 爬虫 SLG游戏 语言 java python kotlin 模型 异步事件驱动 可能没什么模型可言 actor模型 传输协议 http http tcp + netty 传输结构 json json protobuf 数据库 oracle，redis mongodb mysql,redis 数据库框架 mybatis python库（类似jdbc） hibernate 缓存架构 管理员登录状态用redis 可能只缓存了页码 所有游戏用的数据全部缓存，每隔一段时间写到数据库中 配置信息 只有application.properties config.ini zookeeper，启动前需要将策划表信息刷到zk 并发 无并发（所以根本没用到锁） python多线程同时爬多个网站 无并发actor模型保证一次只做一件事 热更 直接重启 无 继承某个类的某个方法，替换掉线上的类 架构一览 智能客服服务端整体架构 SLG游戏整体架构 典型案例 智能客服聊天 graph LR A[客户端]--\u003e|http聊天消息|B[智能客服系统]--\u003e|将聊天信息放入mq|C[智能问答模型]--\u003e|问答信息记录|D[Oracle数据库] SLG游戏士兵出征 graph LR A[客户端]--\u003e|tcp发送的protobuf|B[Gate的Netty解包]--\u003e|actor内部消息转发|C[WorldActor校验外城沙盘各种状态]--\u003e|actor内部消息转发|D[playerActor内城校验和获取buff] 其中worldActor和playerActor都通过读取内存的方式读取到需要的数据，并不直接读取mysql数据库。 内存里的数据每隔一段时间（30秒左右）将变化的数据通过hibernate的方法更新到mysql中。\n配置信息读取 对于智能客服来说，由于并发量业务量很少（因为投放的平台比较少，且晚上凌晨基本没什么人使用，且重启速度很快），有一些需求上的配置数值（比如发送几次“转人工”才进入转人工通道）是直接硬写在业务里的；也有一些配置信息是其他系统的请求地址url，会配在application.properties里。没有使用excel统一存储各个功能模块的配置信息，也确实不需要。\n但对于游戏来说，数值这块的配置至关重要，与玩法，奖励，游戏内生态息息相关。因此在游戏服务器里，所有的数值几乎都要从配置表中读取。目前Excel应该是处理数据能力最强的软件了，策划可以通过Excel非常快速的把数值配好。 启动服务器的时候要读取配置表到内存（广义上的）里。但在有了zookeeper这样的工具出现之后，配置表数据可以放在zk中，需要的时候再取出来。\n游戏服务器优势 传输结构为protobuf 服务器接收和发送的数据都是ProtoBuf转成的二进制，从而实现客户端服务器端统一的传输结构。protobuf自己有编码解码二进制的功能，从而实现消息数据的大小达到最小，编码解码是由netty执行的，使用上只需要将protobuf生成的对象传给netty即可。这边用的protobuf是v2版本的，有required，optional和repeated三种关键字，分别对传输message里的属性作出了约束。\nAkka Actor架构 Actor架构实现单线程的业务逻辑，开发过程中不需要对一些公用的属性上锁；通过内部消息的通讯，让数据处理有序进行。Akka cluster集群有动态负载均衡的功能，可以进行平行扩展，也就是说，如果一台服务器扛不住并发，只要再配置一台或几台新服务器，加入集群就可以完成负载均衡。","title":"传统软件服务器与游戏服务器架构区别"},{"content":"在写文章前容许我啰嗦一下：对于软件开发，我走了不少弯路，有时觉得自己作为API侠，无所不能，有时又觉得自己很多LeetCode题写不出来，无能为力。我有一个博客，但是写满了自己的絮絮叨叨，真正有本领的东西九牛一毛。\n我甚至没有自己的“代表作”，因为我是一个急性子，想马上得到结果（事实上计算机真能马上给出结果，但开发过程不行）。我经常在“造自己的轮子”和“用别人的轮子”之间徘徊，“造自己的轮子”比较有成就感，但是难度其实很大，需要踩很多别人踩过的坑；“用别人的轮子”则没有什么成就感，做出来也不像是自己做的。而平时工作中，每天都在用别人的轮子，自己真正从比较底层开始实现的情况是非常少的，导致我在闲暇时间也不想用别人的轮子。\n啰嗦一下自己的经历： 2004年，我家买了电脑，我也接触了很多电脑上的游戏。但是也许是我心浮气躁或者没有游戏天赋，我总是在游戏里输，总是追不上邻居小伙伴；\n2008年，我萌生了“自己写一个什么东西”的想法。\n2009年夏，小学毕业的我开始摆弄魔兽地图编辑器，虽然一点脚本都没写，做出来的游戏也粗制滥造。也开始查找“如何创建一个个人网站”。\n2010年，在和初中新同学混熟之后，我们打算做一个班级网站，我找了一圈发现5566和phpwindy有免费的论坛可以注册，我们注册了一个论坛，并且想把每天的作业更新发布上去。但事实上那位同学仅发布过一次作业。\n2011年，我利用爸妈给我的打游戏的时间，将网页保存下来，咬着牙研读里面的html标签，然后给我当时加入的一个魔兽争霸群做了一个纯html的“官网”。在某免费空间上注册了一个只支持asp和基础web的免费空间，用8uFTP把网站上传上去。\n2014年，在学校的图书室，我昧着良心在寻找Dreamweaver的教程书，还真给我找到了。但是我根本没有自己的电脑，只能对着书发呆脑补。\n2015年夏，我高中毕业，填志愿的时候几乎把“软件工程”和“计算机科学与技术”都填的满满的。我查了资料发现“软件工程”比“计算机科学与技术”学费更贵，在询问了父母的意见之后，我把“软件工程”填到了第一位，然后和父母说，一定会考上。最后我考上了一个普通的本科，开始学习软件工程专业。\n2015年暑假，还有一件事情，我自己注册了（已经失效了的）域名，购买了阿里云的虚拟主机，配置了WordPress服务器，在上面写博客文章。仅仅是备份就花了一周，然后终于拿到了自己的备案号。我永远不会忘记第一次用自己的域名打开自己的网站那一刻的快乐。\n2016年春，我推开软件学院大楼某间实验室的大门，然后就我大学一年级就和学长们一起做项目，当时团队里缺人写html页面，而我正好已经算是html css入门了（完全不会js），开始仿写各大网站。然后想自己写一个象棋游戏，结果找资料就找了一个下午，最后不了了之。\n2017年夏，我跟着课程开始研究蚁群算法，最后实现了论文的内容。现在回想起来，对着论文依葫芦画瓢其实没什么技术含量，当打包运行并且在台上汇报之后，我真的觉得很快乐。不过，我并没有学到什么“真才实学”。\n2017年秋，在Java课上，我带领团队（其实开发就我一个人）用Bmob作为后端，安卓作为前端，开发了一个“今日特价” app。我对着github上的一个高仿微博的项目，拼命的抄各种代码。而最后我觉得写的太差，而把代码都删除了，真是太可惜了。\n2018年，我有了很多很多想法，但是都没有执行下去。\n我想自己从零搭建一个博客，用新学的SpringMVC，替换掉WordPress。 我想做一个网站，叫做“预言”，简单来说就是让用户发表一些对未来的猜测，并且定一个时间，然后系统到了那个时间会提醒用户确认是否预言成功 我想做一个安卓app，像三国志11一样，将所有三国的人物，历史事件，城池信息，战役，单挑，舌战都完整地汇总在里面，然后再像游戏一样，将“官渡之战”、“赤壁之战”、“夷陵之战”都像三国志11一样活灵活现地展示在地图上。 当时我觉得做网页做系统已经很没有意思了，所以我决定做机器学习，深度学习。 我想考研，因为不太满意自己的双非学历。 那时候LPL竞猜挺火的，我和朋友商量写一个统计各队伍各选手的评分的系统。当时我先用jQuery写了前端，拼命的append html标签，导致我自己写完的时候都不知道自己在写什么。 2019年春，考研没考上，但是数学二确实也让我复习了高数和线代。借助这点基础，我选了一个“手写汉字识别的研究”的题目，然后开始学习吴恩达的机器学习入门，学习深度学习Tensorflow，学习卷积神经网络等等，然后由于自己的电脑的显卡是1050ti，有点不够用，我就花钱去租专门用于训练的服务器，印象中要6块1小时。那时候为了一个好的结果，，花了不少家里的钱。\n2019年春夏之交，我的论文提交给了一个不太懂机器学习的老师，老师一看就觉得我在抄别人的论文。给我的建议是，我要么一意孤行继续这样答辩，但可能延毕；要么就把手写汉字识别改成某个系统，走需求分析，UML设计，数据库设计，开发，测试，结论的框架。当时我感到了深刻的绝望，自信心几乎被击垮，支离破碎。仗着自己之前也曾一个人咬着牙实现过不少系统，我决定把这个算法的研究都丢掉，转用百度提供的手写汉字识别api，包装成一个笔记系统，手写的笔记拍个照就转储成汉字。\n2019年秋，我入职某软件公司，我终于会写Vue了。在之前我总是写jQuery。我甚至以为jQuery是最好的解决方案。也许2015年前是，2015年后就不是了。\n2020年，我虽然是Java开发工程师，但是做了很多很多前端的内容。我被迫花很多时间去调CSS，去抄别人的js来完成移动端的h5网页的展示效果。我感到非常的厌恶，觉得自己的能力被封锁了。领导想弄区块链，想提供API接口给其他公司使用，但现在看来根本没有任何优势，仅仅是困兽之斗。另外，为了能把智能客服的问答预料快速查找，我学习了ElasticSearch数据库的用法。为了爬取一些信息，我学习了Python开发。\n2020年秋，我被“发配”北京，每天都过得很不开心，回家遥遥无期。本来说好的出差一个月，到了地方之后却要求长期驻地开发。而那套系统的代码很乱，找到机会我马上就离职了。\n2021年，我来到上海，接触了游戏服务器开发。我第一次发现服务器是如此的庞大。\n我学习了新的架构：Actor架构。 我受到网上的信息“蛊惑”，觉得hibernate已经过时，但在游戏这个场景里，hibernate比mybatis更适合。 我以前不理解Zookeeper到底用来做什么，他们总是只教我存和取，现在我知道可以配置系统信息； 我自学过netty，但是不理解为什么要用netty，现在我知道了，封包解包，NIO这些情况用netty确实快人一步。 我以前觉得mysql能力有限，但是在mysql前加一层缓存的话，速度就会成倍提高。还有索引和主键的配置也是有考究的，慢查询也是可以分析的。并不能武断的认为mysql能力不行。 还有一些完全没听过的，比如protobuf，akka，集群，ticker，在我之前的认知里只有json是唯一通信的结构。 2022年，我回过头来发现，我好像是从2021年之后，才真正打破“啥都会，啥都不会”的尴尬局面。在此之前，我好像什么都会：\nWeb前端：html，css，js基础语法，jQuery的用法，简单的WebPack打包，简单的Vue Java后端：SpringMVC过渡到SpringBoot，MyBatis 移动端：基础的Android开发 数据库：使用过关系型的Oracle，mysql，也使用过非关系型的mongodb和ElasticSearch Python：爬虫相关 服务器：只会简单的java -jar部署，netstat -nlp看端口，然后给我所有的电脑都装好双系统。 又啥都不会：\nWeb前端不会最有技术含量的React Java后端不会hibernate，HashMap的底层逻辑，Java虚拟机的垃圾回收机制都是用背的。 移动端：不会用kotlin写安卓，也不知道最新的安卓有什么内容 数据库：从没有仔细学习mysql背后的存储优化原理，也没有上手实操过 服务器：以为服务器只是java -jar，而没有研究过docker，zookeeper，jenkins等更优秀的工具和中间件。装双系统也就装的那一刻用一下，真要做事还是用虚拟机多开…… 没有研究过消息队列。 总的来说就是，都是浅尝辄止。当跑完hello world，把环境搭起来的时候，我就觉得自己行了，牛了，然后关掉编译器去玩了。\n不过有意思的是，2021年我在10年工作经验的主程面前点开8uFTP的时候，他惊讶地问：“woc你怎么在用这个东西？太老了这个，可以换一下Filezila”。而我会心一笑。后来团队发生了变动，换了个新主程。在闲暇时间我和他攀谈“网页三剑客”，向他展示我2015年就搭建起来的博客，和他开玩笑说，我和他是同一个软件开发时代的人，我是Young OG！\n但也仅此而已了。也许我真的是Young OG，但是我总是缺了点什么很关键的东西。以前我觉得自己不懂坚持，总是半途而废，而现在，在上海工作了一年多之后，我发现我的能力并没有任何问题，我的问题在于不知道怎么将工作切分，不知道怎么保存自己的体力，不知道自己的目标是什么。\n不管是写LeetCode，写项目，还是研究某个新框架，都需要安排时间，都需要统筹自己拥有的资源。特别是写项目，写项目有一点像写小说。只有将小说里每个章节都完成并且有所关联（长篇小说），才能是一部优秀的小说。长篇小说家也不是一朝一夕能写完一部大作，我们软件开发人员自然也不能一朝一夕写好一个系统，更何况我们还需要测试自己的代码。\n所以我们需要对任务进行切分。\n任务切分的方法和意义 最近两三个月，在工作中，我开始使用画图工具来画一些流程图或者架构图。这些图不是标准的UML图，但是是我自己能看懂的图。\n简单说一下本次系统做了什么。 我平常会看LPL比赛，尤其是季后赛或者国际赛事。这些赛事一般是BO5（五局三胜制），一局比赛一般30分钟，加上休息的10分钟，如果打满5局大概4个小时多。如果中途出了点差错，还有暂停的时间。 而最好看的比赛往往不是前两三局，而是第四局或者第五局。因为如果第三局就结束这场BO5，只有可能是3-0碾压，没什么意思。而如果打到第四局，必然是2-1，这时领先方再加把劲就赢下整场比赛，而落后方已经站到悬崖边，这时候的比赛是最好看的。 但要打完3局，至少也要两个多小时了。如果我手头上有一件其他的事情要做，那么我就需要经常点开某个APP检查比赛是否到了2-1？又或者我对两队的实力很信任，我相信他们一定能打到2-2进决胜局，那我就很可能需要在三个小时内不断的抽时间查看比赛进度。这会影响我手上的事的效率。 所以，不如写一个系统，每隔好几分钟去请求一下LPL的接口，和数据库的预定比赛信息比对，如果到达了我预定的比赛比分，或者到不了我预定的比分，就发邮件提醒我。我只需要开着QQ，等着右下角提示就好了。\n技术选型 回到上一节说的“造自己的轮子”和“用别人的轮子”的讨论，我平时的工作用Java进行开发，如果用SpringBoot，在路由，操作数据库逻辑，发送邮件那几块的内容，在数据库设计好了的情况下，我会写的很快。 在这个情况下，“用别人的轮子”就是用SpringBoot，“造自己的轮子”就是用某个自己没学过的语言或者框架，边做边学。 本次我选用的是Go语言和Gin，对标Java和SpringBoot。\n语言 路由 ORM Java SpringBoot MyBatis Go Gin Gorm 系统切分 在这次开发中，我不再像过去一样无头苍蝇乱撞，而是先画了好几个框框，来分析到底自己想做什么事情。 别看内容不多，事实上这一步是非常重要的。我们对于某个需求，可能仅仅是觉得“这个拿出来，然后和那个比一下，有就做这个，没有就做那个”，最后加一句“不就好了吗？”。但在实际操作的过程中，大概率会发现“这个”不好拿出来，“那个”也不太好取出来，取出来不知道在哪里“比一下”，“有”的情况可能不方便“做这个”，“没有”的情况可能不方便“做那个”。\n所以不要说“不就好了吗”，对于自己不熟悉的领域来说，做什么都会遇到问题。如果用的是自己熟悉的内容，那么就失去了提升自己的机会了。\n首先我先用一句话把我脑中的需求写明白。只要自己看懂就好。 然后我开始幻想前端，前端要做几件事？我列出了5件事：\n获取预约信息 创建预约 删除预约 执行预约 取消预约 在这个简单的需求中，这5件事就是5个接口（最后开发的时候发现“执行预约”和“创建预约”的功能是重合的，但是无所谓，这里更多的是提供思路）。 而在后端那块，我从前端要做的事情反推后端应该要有什么功能：要发送请求肯定需要路由，要落库肯定要操作数据库和设计数据库。在需求里需要读取比赛到达的某个比分，那么就需要一个轮询的定时器，每隔一段时间发送请求问一下，然后通知就用邮件，因为邮件协议是通用的，而且QQ邮箱的提醒非常醒目。最后业务逻辑也是需要时间进行设计的。\n基于前后端的内容，我开始排工作：\n前端页面框架搭建 前端页面开发及设计（边做边弄） gin路由基础框架搭建 基础请求框架编写 获取赛事接口编写 数据库设计 gorm数据库操作 邮件发送逻辑 ticker研究及实现 开发所有请求 自己联调前后端 事实上这个工作安排，虽然是11条，但是每一条的工作量并不平均。我感觉在任何项目组，切分工作也不代表工作量是平均的。 现在做完回头看，发现go语言对邮件发送和ticker有自带的支持，然后gorm的逻辑和gin解析json的逻辑几乎一致。其实并没有浪费多久时间。 这次我没有预估具体时间，因为我心里没底。事实上更好的做法是稍微评估一个时间长度。\n任务切分的意义在于，任务有时候不像买来的蛋糕，你可以用肉眼看到蛋糕的大小和形状。你手上只有一把塑料刀，对着盲盒里切。 但是有意思的地方在于，任务这块“蛋糕”的结构虽然乱七八糟，但是你大概能找到你知道的位置，然后胡乱的“划一刀”。这种切分可能并不准确，你并不知道你的蛋糕具体是什么样的，但是当你用这种方式多“划好几刀”之后，你的图中会有一个大概的系统模型，这会反过来指导你接下来要怎么划分工作内容。当工作内容越来越细，你就越能准确的评估每一块的时间和困难点。 也就是一件事变成了好几件事。而每一件事都有单独的内容，有单独的评判标准。从而能清楚的知道自己做了多少内容。\n关于评估时间，我发现自己经常落入一个陷阱里：认为简单的事情一定能很快做完。但实际情况是，一个任务的时间长度，既取决于难易，也取决于工作量。我经常忽视工作量的大小，乐观的估计比较简单的工作任务。其实在拿不准时间的情况下，可以把时间评估的更长一些，是没有问题的。\n挑战性 如果说在公司工作是为了谋生，那么在业余时间做自己的项目就是为了取乐。 如果不是为了取乐，那么也没有必要再浪费时间了。 经过这次的开发，我发现自己的开发内容其实也不少，但是我没有觉得很不开心，相反，我感到很兴奋。 在21年10月我有自学Go语言的语法，但是我不知道怎么去应用于实践。而编写一些基础语法的训练代码，让我觉得很像读书时看着例题做例题。 挑战性不能太高，比如写一个完整的用户注册登录找回密码的体系，然后提供第三方token登录这种，对于一个人开发来说，太难，而且也是重复造轮子的工作。 也不能太低，比如写一个golang的Hello world，包装一个在网页上发邮件的功能等，做出来没有意义。 自己的项目，应该是有点挑战，然后尽可能实用，能在生活中用得到。如此一来，才不会陷入“我做这玩意又没钱赚，学不到东西，我不知道为了什么而写”的错误想法中。\n结合上一节写的“任务切分”，当有一个想法在脑中亮起，请你拿出纸笔或者打开画图软件，花一个晚上或者一天做一做简单的功能设计和任务划分，你就能知道自己的想法值不值得做，需要什么资源，做出来是为了什么。\n实用性 如果一个需求没有实际的作用，那么就没有必要浪费时间了。如果“实用性”仅仅是为了“让大家知道我有本领”，而没有办法在生活中应用到，或者是让人感到很快乐，又或者能带来收入，那么尽早停止吧。（当然了如果“让大家知道我有本领”能让你升职加薪跳槽，那么就属于“能带来收入”的范畴了）\n半途而废 翻看github和gitee，我有很多想法和点子。\n凌天战队：2016年最爱玩LOL的时候，想给我们宿舍和隔壁宿舍组个战队，读取他们游戏账号的数据接口，把他们的数据列出来。然后搞个官网招摇显摆； 中国象棋：想自己写一个象棋，能让玩家消耗道具，让电脑帮忙走一步棋，或者悔棋等 自己完整写一个博客 睡眠宠物：安卓应用，根据睡觉时间来提升宠物等级，然后白天宠物出去游历（旅行青蛙） 预言家的网站：写预言然后定时，时间到了发邮件询问预言是否成真 英雄联盟数据平台：记录BO5的双方赢下第几局的胜率最高 三国数据平台：想整理所有三国人物，事件，城池，战役 想学Unity做一个RPG游戏 但真实的情况是，我每次花了一天做一点内容，就觉得浑身难受，没有任何正反馈。比如自己的博客那个，我花了一晚上调style样式，然后已经没力气写后端了；中国象棋我把基础的棋盘和走子逻辑对着书里翻译成kotlin就花了一周的休息时间，界面是用命令行print的，而这一周我一点游戏都没玩！预言家的网站也是用bootstrap写了个基础的主页和个人中心，后端那块就没体力做了。Unity和UE根本不知道怎么入门，或者说看看教程自己弄一下一天也就过去了。\n我属于是又想学，又想做，但更想玩的人。我无数次觉得自己是很糟糕的人，因为我有这些想法和点子，却从未付诸实践。\n而从前两节的分析上来讲，这几个需求大多都属于挑战性逆天高，实用性几乎没有的需求。而我其实并不特别喜欢这些需求做完之后的具体效果。 自己写网站（凌天战队、自己的博客、预言家的网站）对我来说其实还是很消耗时间的，即使我现在有能力能做的很快。自己的用户体系就算建起来也需要维护，还不如直接作为一个信息发布平台+邮箱联系的模式，作为自己的名片； 中国象棋则是属于做出来就是为了自娱自乐，但是也没有多有趣，因为象棋游戏现在多如牛毛，我要的功能现在天天象棋也有了，如果是为了学习剪枝算法，倒是值得一学，但是为了做一个游戏系统，又不打算捞钱，就是浪费时间了； 睡眠宠物是属于难度特别特别大，需要自己测很多很多轮，但是没什么收益的东西。而且还需要美工的支持，不然就毫无用处和趣味了； 英雄联盟数据平台是属于爬虫爬到数据库+命令行展示结果即可的功能，做一整套系统属实是为了装逼，但事实上代码放到github上，然后在Readme里贴出结果，反而更有范儿； 三国数据平台属实是劳民伤财，挑战性拉满，而实用性还不如百度百科。 学习Unity或者UE，首先应该先学基础，而不是先做RPG，现在根本没办法做好系统设计和切分需求。\n有想法是好事，但是现在的情况是，你想到的东西，前人肯定有人也想到了，他们没有做成功，所以才轮到你想到。\n而这次做的赛事预约平台，则是我第一次用正确的方式分析、设计、排期、开发、测试，还差一步上线。整个过程里我不觉得有多辛苦，而是觉得这个系统还可以有很多地方可以优化，让他更人性化，甚至让他不再依赖接口爬虫等，保障系统数据来源正常提供。并且这个系统真真切切能为我提供便利，让我能更专注于我的工作内容，又不落下比赛。\n我接触代码已有14年之久，但为自己开发一个完整的系统（包括前后端和测试），并且真正用于实际，是头一回。一起拿我不过是个“雇佣兵”，为了学校的学分，为了公司的工资而疲于奔命，而自己的想法又太过庞大。\n以此次经验为鉴，今后一定可以有很多有意思的想法，在“任务切分刀”切分之后，逐步完善。成为我自己的“代表作”。\n","permalink":"https://windypath.com/posts/individual_project_experience/","summary":"在写文章前容许我啰嗦一下：对于软件开发，我走了不少弯路，有时觉得自己作为API侠，无所不能，有时又觉得自己很多LeetCode题写不出来，无能为力。我有一个博客，但是写满了自己的絮絮叨叨，真正有本领的东西九牛一毛。\n我甚至没有自己的“代表作”，因为我是一个急性子，想马上得到结果（事实上计算机真能马上给出结果，但开发过程不行）。我经常在“造自己的轮子”和“用别人的轮子”之间徘徊，“造自己的轮子”比较有成就感，但是难度其实很大，需要踩很多别人踩过的坑；“用别人的轮子”则没有什么成就感，做出来也不像是自己做的。而平时工作中，每天都在用别人的轮子，自己真正从比较底层开始实现的情况是非常少的，导致我在闲暇时间也不想用别人的轮子。\n啰嗦一下自己的经历： 2004年，我家买了电脑，我也接触了很多电脑上的游戏。但是也许是我心浮气躁或者没有游戏天赋，我总是在游戏里输，总是追不上邻居小伙伴；\n2008年，我萌生了“自己写一个什么东西”的想法。\n2009年夏，小学毕业的我开始摆弄魔兽地图编辑器，虽然一点脚本都没写，做出来的游戏也粗制滥造。也开始查找“如何创建一个个人网站”。\n2010年，在和初中新同学混熟之后，我们打算做一个班级网站，我找了一圈发现5566和phpwindy有免费的论坛可以注册，我们注册了一个论坛，并且想把每天的作业更新发布上去。但事实上那位同学仅发布过一次作业。\n2011年，我利用爸妈给我的打游戏的时间，将网页保存下来，咬着牙研读里面的html标签，然后给我当时加入的一个魔兽争霸群做了一个纯html的“官网”。在某免费空间上注册了一个只支持asp和基础web的免费空间，用8uFTP把网站上传上去。\n2014年，在学校的图书室，我昧着良心在寻找Dreamweaver的教程书，还真给我找到了。但是我根本没有自己的电脑，只能对着书发呆脑补。\n2015年夏，我高中毕业，填志愿的时候几乎把“软件工程”和“计算机科学与技术”都填的满满的。我查了资料发现“软件工程”比“计算机科学与技术”学费更贵，在询问了父母的意见之后，我把“软件工程”填到了第一位，然后和父母说，一定会考上。最后我考上了一个普通的本科，开始学习软件工程专业。\n2015年暑假，还有一件事情，我自己注册了（已经失效了的）域名，购买了阿里云的虚拟主机，配置了WordPress服务器，在上面写博客文章。仅仅是备份就花了一周，然后终于拿到了自己的备案号。我永远不会忘记第一次用自己的域名打开自己的网站那一刻的快乐。\n2016年春，我推开软件学院大楼某间实验室的大门，然后就我大学一年级就和学长们一起做项目，当时团队里缺人写html页面，而我正好已经算是html css入门了（完全不会js），开始仿写各大网站。然后想自己写一个象棋游戏，结果找资料就找了一个下午，最后不了了之。\n2017年夏，我跟着课程开始研究蚁群算法，最后实现了论文的内容。现在回想起来，对着论文依葫芦画瓢其实没什么技术含量，当打包运行并且在台上汇报之后，我真的觉得很快乐。不过，我并没有学到什么“真才实学”。\n2017年秋，在Java课上，我带领团队（其实开发就我一个人）用Bmob作为后端，安卓作为前端，开发了一个“今日特价” app。我对着github上的一个高仿微博的项目，拼命的抄各种代码。而最后我觉得写的太差，而把代码都删除了，真是太可惜了。\n2018年，我有了很多很多想法，但是都没有执行下去。\n我想自己从零搭建一个博客，用新学的SpringMVC，替换掉WordPress。 我想做一个网站，叫做“预言”，简单来说就是让用户发表一些对未来的猜测，并且定一个时间，然后系统到了那个时间会提醒用户确认是否预言成功 我想做一个安卓app，像三国志11一样，将所有三国的人物，历史事件，城池信息，战役，单挑，舌战都完整地汇总在里面，然后再像游戏一样，将“官渡之战”、“赤壁之战”、“夷陵之战”都像三国志11一样活灵活现地展示在地图上。 当时我觉得做网页做系统已经很没有意思了，所以我决定做机器学习，深度学习。 我想考研，因为不太满意自己的双非学历。 那时候LPL竞猜挺火的，我和朋友商量写一个统计各队伍各选手的评分的系统。当时我先用jQuery写了前端，拼命的append html标签，导致我自己写完的时候都不知道自己在写什么。 2019年春，考研没考上，但是数学二确实也让我复习了高数和线代。借助这点基础，我选了一个“手写汉字识别的研究”的题目，然后开始学习吴恩达的机器学习入门，学习深度学习Tensorflow，学习卷积神经网络等等，然后由于自己的电脑的显卡是1050ti，有点不够用，我就花钱去租专门用于训练的服务器，印象中要6块1小时。那时候为了一个好的结果，，花了不少家里的钱。\n2019年春夏之交，我的论文提交给了一个不太懂机器学习的老师，老师一看就觉得我在抄别人的论文。给我的建议是，我要么一意孤行继续这样答辩，但可能延毕；要么就把手写汉字识别改成某个系统，走需求分析，UML设计，数据库设计，开发，测试，结论的框架。当时我感到了深刻的绝望，自信心几乎被击垮，支离破碎。仗着自己之前也曾一个人咬着牙实现过不少系统，我决定把这个算法的研究都丢掉，转用百度提供的手写汉字识别api，包装成一个笔记系统，手写的笔记拍个照就转储成汉字。\n2019年秋，我入职某软件公司，我终于会写Vue了。在之前我总是写jQuery。我甚至以为jQuery是最好的解决方案。也许2015年前是，2015年后就不是了。\n2020年，我虽然是Java开发工程师，但是做了很多很多前端的内容。我被迫花很多时间去调CSS，去抄别人的js来完成移动端的h5网页的展示效果。我感到非常的厌恶，觉得自己的能力被封锁了。领导想弄区块链，想提供API接口给其他公司使用，但现在看来根本没有任何优势，仅仅是困兽之斗。另外，为了能把智能客服的问答预料快速查找，我学习了ElasticSearch数据库的用法。为了爬取一些信息，我学习了Python开发。\n2020年秋，我被“发配”北京，每天都过得很不开心，回家遥遥无期。本来说好的出差一个月，到了地方之后却要求长期驻地开发。而那套系统的代码很乱，找到机会我马上就离职了。\n2021年，我来到上海，接触了游戏服务器开发。我第一次发现服务器是如此的庞大。\n我学习了新的架构：Actor架构。 我受到网上的信息“蛊惑”，觉得hibernate已经过时，但在游戏这个场景里，hibernate比mybatis更适合。 我以前不理解Zookeeper到底用来做什么，他们总是只教我存和取，现在我知道可以配置系统信息； 我自学过netty，但是不理解为什么要用netty，现在我知道了，封包解包，NIO这些情况用netty确实快人一步。 我以前觉得mysql能力有限，但是在mysql前加一层缓存的话，速度就会成倍提高。还有索引和主键的配置也是有考究的，慢查询也是可以分析的。并不能武断的认为mysql能力不行。 还有一些完全没听过的，比如protobuf，akka，集群，ticker，在我之前的认知里只有json是唯一通信的结构。 2022年，我回过头来发现，我好像是从2021年之后，才真正打破“啥都会，啥都不会”的尴尬局面。在此之前，我好像什么都会：\nWeb前端：html，css，js基础语法，jQuery的用法，简单的WebPack打包，简单的Vue Java后端：SpringMVC过渡到SpringBoot，MyBatis 移动端：基础的Android开发 数据库：使用过关系型的Oracle，mysql，也使用过非关系型的mongodb和ElasticSearch Python：爬虫相关 服务器：只会简单的java -jar部署，netstat -nlp看端口，然后给我所有的电脑都装好双系统。 又啥都不会：\nWeb前端不会最有技术含量的React Java后端不会hibernate，HashMap的底层逻辑，Java虚拟机的垃圾回收机制都是用背的。 移动端：不会用kotlin写安卓，也不知道最新的安卓有什么内容 数据库：从没有仔细学习mysql背后的存储优化原理，也没有上手实操过 服务器：以为服务器只是java -jar，而没有研究过docker，zookeeper，jenkins等更优秀的工具和中间件。装双系统也就装的那一刻用一下，真要做事还是用虚拟机多开…… 没有研究过消息队列。 总的来说就是，都是浅尝辄止。当跑完hello world，把环境搭起来的时候，我就觉得自己行了，牛了，然后关掉编译器去玩了。\n不过有意思的是，2021年我在10年工作经验的主程面前点开8uFTP的时候，他惊讶地问：“woc你怎么在用这个东西？太老了这个，可以换一下Filezila”。而我会心一笑。后来团队发生了变动，换了个新主程。在闲暇时间我和他攀谈“网页三剑客”，向他展示我2015年就搭建起来的博客，和他开玩笑说，我和他是同一个软件开发时代的人，我是Young OG！\n但也仅此而已了。也许我真的是Young OG，但是我总是缺了点什么很关键的东西。以前我觉得自己不懂坚持，总是半途而废，而现在，在上海工作了一年多之后，我发现我的能力并没有任何问题，我的问题在于不知道怎么将工作切分，不知道怎么保存自己的体力，不知道自己的目标是什么。\n不管是写LeetCode，写项目，还是研究某个新框架，都需要安排时间，都需要统筹自己拥有的资源。特别是写项目，写项目有一点像写小说。只有将小说里每个章节都完成并且有所关联（长篇小说），才能是一部优秀的小说。长篇小说家也不是一朝一夕能写完一部大作，我们软件开发人员自然也不能一朝一夕写好一个系统，更何况我们还需要测试自己的代码。\n所以我们需要对任务进行切分。\n任务切分的方法和意义 最近两三个月，在工作中，我开始使用画图工具来画一些流程图或者架构图。这些图不是标准的UML图，但是是我自己能看懂的图。\n简单说一下本次系统做了什么。 我平常会看LPL比赛，尤其是季后赛或者国际赛事。这些赛事一般是BO5（五局三胜制），一局比赛一般30分钟，加上休息的10分钟，如果打满5局大概4个小时多。如果中途出了点差错，还有暂停的时间。 而最好看的比赛往往不是前两三局，而是第四局或者第五局。因为如果第三局就结束这场BO5，只有可能是3-0碾压，没什么意思。而如果打到第四局，必然是2-1，这时领先方再加把劲就赢下整场比赛，而落后方已经站到悬崖边，这时候的比赛是最好看的。 但要打完3局，至少也要两个多小时了。如果我手头上有一件其他的事情要做，那么我就需要经常点开某个APP检查比赛是否到了2-1？又或者我对两队的实力很信任，我相信他们一定能打到2-2进决胜局，那我就很可能需要在三个小时内不断的抽时间查看比赛进度。这会影响我手上的事的效率。 所以，不如写一个系统，每隔好几分钟去请求一下LPL的接口，和数据库的预定比赛信息比对，如果到达了我预定的比赛比分，或者到不了我预定的比分，就发邮件提醒我。我只需要开着QQ，等着右下角提示就好了。\n技术选型 回到上一节说的“造自己的轮子”和“用别人的轮子”的讨论，我平时的工作用Java进行开发，如果用SpringBoot，在路由，操作数据库逻辑，发送邮件那几块的内容，在数据库设计好了的情况下，我会写的很快。 在这个情况下，“用别人的轮子”就是用SpringBoot，“造自己的轮子”就是用某个自己没学过的语言或者框架，边做边学。 本次我选用的是Go语言和Gin，对标Java和SpringBoot。","title":"独立个人项目开发心得 - 任务切分、挑战性、实用性和半途而废"},{"content":"套接字编程作业2：UDP ping 程序 在本实验中，您将学习使用Python进行UDP套接字编程的基础知识。您将学习如何使用UDP套接字发送和接收数据报，以及如何设置适当的套接字超时。在实验中，您将熟悉Ping应用程序及其在计算统计信息（如丢包率）中的作用。\n您首先需要研究一个用Python编写的简单的ping服务器程序，并实现对应的客户端程序。这些程序提供的功能类似于现代操作系统中可用的标准ping程序功能。然而，我们的程序使用更简单的UDP协议，而不是标准互联网控制消息协议（ICMP）来进行通信。 ping协议允许客户端机器发送一个数据包到远程机器，并使远程机器将数据包返回到客户（称为回显）的操作。另外，ping协议允许主机计算它到其他机器的往返时间。\n以下是Ping服务器程序的完整代码。你的任务是写出Ping客户端程序。\n服务器代码 以下代码完整实现了一个ping服务器。您需要在运行客户端程序之前编译并运行此代码。而且您不需要修改此代码。 在这个服务器代码中，30％的客户端的数据包会被模拟丢失。你应该仔细研究这个代码，它将帮助你编写ping客户端。\n# UDPPingerServer.py # We will need the following module to generate randomized lost packets import random from socket import * import random # Create a UDP socket # Notice the use of SOCK_DGRAM for UDP packets serverSocket = socket(AF_INET, SOCK_DGRAM) # Assign IP address and port number to socket serverSocket.bind((\u0026#39;\u0026#39;, 12000)) while True: # Generate random number in the range of 0 to 10 rand = random.randint(0, 10) # Receive the client packet along with the address it is coming from message, address = serverSocket.recvfrom(1024) # Capitalize the message from the client message = message.upper() # If rand is less is than 4, we consider the packet lost and do not respond if rand \u0026lt; 4: continue # Otherwise, the server responds serverSocket.sendto(message, address) 服务器程序在一个无限循环中监听到来的UDP数据包。当数据包到达时，如果生成一个随机整数大于或等于4，则服务器将数字转为大写并将其发送回客户端。\n数据包丢失 UDP为应用程序提供了不可靠的传输服务。消息可能因为路由器队列溢出，硬件错误或其他原因，而在网络中丢失。但由于在内网中很丢包甚至不丢包，所以在本实验室的服务器程序添加人为损失来模拟网络丢包的影响。服务器创建一个随机整数，由它确定传入的数据包是否丢失。\n客户端代码 您需要实现以下客户端程序。\n客户端向服务器发送10次ping。因为UDP是不可靠的协议，所以从客户端发送到服务器的数据包可能在网络中丢失。因此，客户端不能无限期地等待ping消息的回复。客户等待服务器回答的时间至多为一秒，如果在一秒内没有收到回复，您的客户端程序应该假定数据包在网络传输期间丢失。您需要查找Python文档，以了解如何在数据报套接字上设置超时值。\n具体来说，您的客户端程序应该\n使用UDP发送ping消息（注意：不同于TCP，您不需要首先建立连接，因为UDP是无连接协议。） 从服务器输出响应消息 如果从服务器受到响应，则计算并输出每个数据包的往返时延（RTT）（以秒为单位）， 否则输出“请求超时” 在开发过程中，您应该先在计算机上运行UDPPingerServer.py，并通过向localhost（或127.0.0.1）发送数据包来测试客户端。调试完成代码后，您应该能看到ping服务器和ping客户端在不同机器上通过网络进行通信。\n消息格式 本实验中的ping消息格式使用最简单的方式。客户端消息只有一行，由以下格式的ASCII字符组成：\nPing sequence_number time\n其中sequence_number从1开始，一直到10，共10条消息，而time则是客户端发送消息时的时间。\n需要上交的内容 您需要上交完整的客户端代码和屏幕截图，以验证您的ping程序是否按需求运行。\n可选练习 目前，程序计算每个数据包的往返时间（RTT），并单独打印出来。请按照标准ping程序的模式修改。您需要在客户端每次ping后显示最小，最大和平均RTT。另外，还需计算丢包率（百分比）。 UDP Ping的另一个类似的应用是UDP Heartbeat。心跳可用于检查应用程序是否已启动并运行，并报告单向丢包。客户端在UDP数据包中将一个序列号和当前时间戳发送给正在监听客户端心跳的服务器。服务器收到数据包后，计算时差，报告丢包（若发生）。如果心跳数据包在指定的一段时间内丢失，我们可以假设客户端应用程序已经停止。实现UDP Heartbeat（客户端和服务器端）。您需要修改给定的UDPPingerServer.py和您自己的UDP ping客户端。 客户端源码：\nimport time from socket import * host = \u0026#39;127.0.0.1\u0026#39; port = 12000 clientSocket = socket(AF_INET, SOCK_DGRAM) clientSocket.connect((host, port)) clientSocket.settimeout(1) num = 10 sended = 0 received = 0 lost = 0 maxRTT = 0.0 minRTT = 0.0 sum = 0.0 for i in range(num): sendTime = time.time() sendMsg = (\u0026#39;Ping %d %s\u0026#39; % (i + 1, sendTime)).encode() try: clientSocket.sendto(sendMsg, (host, port)) sended = sended + 1 recvMsg, addr = clientSocket.recvfrom(1024) received = received + 1 rtt = time.time() - sendTime print(\u0026#39;Sequence %d: Reply from %s RTT = %.3fs\u0026#39; % (i + 1, host, rtt)) sum += rtt if i == 0: maxRTT = rtt minRTT = rtt else: if rtt \u0026lt; minRTT: minRTT = rtt if rtt \u0026gt; maxRTT: maxRTT = rtt except Exception as e: lost = lost + 1 print(\u0026#39;Sequence %d: Request timed out\u0026#39; % (i + 1)) clientSocket.close() print(\u0026#39;host: %s ping statistic:\u0026#39; % host) print(\u0026#39;\\t package: sended = %d, received = %d, lost = %d (%d%% lost rate)\u0026#39; %(sended, received, lost, int(1.0 * lost / sended * 100))) if received \u0026gt; 0: print(\u0026#39;rtt statistic: \u0026#39;) print(\u0026#39;\\t min = %.3fs, max = %.3fs, avg = %.3fs\u0026#39; % (minRTT, maxRTT, 1.0 * sum / received)) 在这段源码中，我模仿Windows的ping程序，成功实现了类似的效果。\n关于可选练习的第二个问题 我认为服务端这边需要在读取客户端发的消息中，提取客户端的发送时间，并将其与服务器当前时间相减而得到RTT时延，以此来判定是否超时。\n另外，心跳检测应规定每X秒都由客户端发送一条简短的消息到服务端，服务端存储一个客户端状态列表，更新最后状态更新时间。\n同时服务端应该有一个tick机制，即每隔Y秒都检查一遍客户端状态列表，如果上次状态更新时间与当前时间超过了设置的阈值，则判定该客户端已经离线。\n学到的东西： TCP和UDP用的都是AF_INET,但是TCP用的是SOCK_STREAM,而UDP用的是SOCK_DGRAM 用sendto()函数的话就不需要在前面调用connect()方法，而用send()之前需要connect() 用recvfrom()函数可以获得接收的消息和消息来源信息，而recv()只能获取消息 用settimeout(1)可以设置超时时间，但超时会直接抛出异常；如果要继续下去，则需要用try excerpt接取异常信息处理。 ","permalink":"https://windypath.com/posts/simple_udp_ping_with_python/","summary":"套接字编程作业2：UDP ping 程序 在本实验中，您将学习使用Python进行UDP套接字编程的基础知识。您将学习如何使用UDP套接字发送和接收数据报，以及如何设置适当的套接字超时。在实验中，您将熟悉Ping应用程序及其在计算统计信息（如丢包率）中的作用。\n您首先需要研究一个用Python编写的简单的ping服务器程序，并实现对应的客户端程序。这些程序提供的功能类似于现代操作系统中可用的标准ping程序功能。然而，我们的程序使用更简单的UDP协议，而不是标准互联网控制消息协议（ICMP）来进行通信。 ping协议允许客户端机器发送一个数据包到远程机器，并使远程机器将数据包返回到客户（称为回显）的操作。另外，ping协议允许主机计算它到其他机器的往返时间。\n以下是Ping服务器程序的完整代码。你的任务是写出Ping客户端程序。\n服务器代码 以下代码完整实现了一个ping服务器。您需要在运行客户端程序之前编译并运行此代码。而且您不需要修改此代码。 在这个服务器代码中，30％的客户端的数据包会被模拟丢失。你应该仔细研究这个代码，它将帮助你编写ping客户端。\n# UDPPingerServer.py # We will need the following module to generate randomized lost packets import random from socket import * import random # Create a UDP socket # Notice the use of SOCK_DGRAM for UDP packets serverSocket = socket(AF_INET, SOCK_DGRAM) # Assign IP address and port number to socket serverSocket.bind((\u0026#39;\u0026#39;, 12000)) while True: # Generate random number in the range of 0 to 10 rand = random.","title":"使用Python实现简单UDP Ping"},{"content":" 来自书籍《计算机网络-自顶向下方法-第6版(课本)》第120页，第二章应用层的课后题第一题。\n基础题目 题目：在这个编程作业中，你将用Python语言开发一个简单的Web服务器，它仅能处理一个请求。具体而言，你的Web服务器将：（1）当一个客户（浏览器）联系时创建一个连接套接字；（2）从这个连接接收HTTP请求；（3）解释该请求以确定所请求的特定文件；（4）从服务器的文件系统获得请求的文件；（5）创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行；（6）经TCP连接向请求的浏览器发送响应。如果浏览器请求一个在该服务器中不存在的文件，服务器应当返回一个“404 Not Found”差错报文。\n参考或者说学习了github上moranzcw的仓库：Computer-Networking-A-Top-Down-Approach-NOTES的内容，完成了这道题。\n代码https://github.com/moranzcw如下：\n# import socket module from socket import * serverSocket = socket(AF_INET, SOCK_STREAM) # Prepare a sever socket # Fill in start # 定义ip和端口号，然后bind绑定socket host = \u0026#39;\u0026#39; port = 6789 serverSocket.bind((host, port)) serverSocket.listen(1) # Fill in end while True: # Establish the connection print(\u0026#39;Ready to serve...\u0026#39;) connectionSocket, addr = serverSocket.accept() # Fill in start #Fill in end try: message = connectionSocket.recv(1024) # Fill in start #Fill in end filename = message.split()[1] f = open(filename[1:]) outputdata = f.read() # Fill in start #Fill in end # Send one HTTP header line into socket # Fill in start header = \u0026#39; HTTP/1.1 200 OK\\nConnection: close\\nContent-Type: text/html\\nContent-Length: %d\\n\\n\u0026#39; % ( len(outputdata)) connectionSocket.send(header.encode()) # Fill in end # Send the content of the requested file to the client for i in range(0, len(outputdata)): connectionSocket.send(outputdata[i].encode()) connectionSocket.close() except IOError: # Send response message for file not found # Fill in start header = \u0026#39; HTTP/1.1 404 Found\u0026#39; connectionSocket.send(header.encode()) connectionSocket.close() # Fill in end # Close client socket # Fill in start # Fill in end serverSocket.close() 同时在这个文件的同级目录下，有一个html文件：helloWorld.html\n\u0026lt;head\u0026gt;Hello world!\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;abcdefg\u0026lt;/body\u0026gt; 在Python中启动项目：\n然后打开浏览器，在地址栏内输入：http://localhost:6789/helloWorld.html 可以看到浏览器正常收到HTTP响应报文，显示正常。\n如果输入的地址不是helloWorld.html，则会报404。 进阶题目 进阶题目1 题目也是翻译自github老哥之手，感谢。\n题目：目前，这个Web服务器一次只处理一个HTTP请求。请实现一个能够同时处理多个请求的多线程服务器。使用线程，首先创建一个主线程，在固定端口监听客户端请求。当从客户端收到TCP连接请求时，它将通过另一个端口建立TCP连接，并在另外的单独线程中为客户端请求提供服务。这样在每个请求/响应对的独立线程中将有一个独立的TCP连接。\n不难得知，只要用线程包装一下处理socket的方法即可。\n代码如下：\n# import socket module import threading from socket import * def sonTcpConnect(connectionSocket): # Fill in start #Fill in end try: print(\u0026#34;thread: \u0026#34; + threading.currentThread().name + \u0026#34; is working...\u0026#34;) message = connectionSocket.recv(1024) # Fill in start #Fill in end print(\u0026#34;msg\u0026#34;, message) filename = message.split()[1] f = open(filename[1:]) outputdata = f.read() # Fill in start #Fill in end # Send one HTTP header line into socket # Fill in start header = \u0026#39; HTTP/1.1 200 OK\\nConnection: close\\nContent-Type: text/html\\nContent-Length: %d\\n\\n\u0026#39; % ( len(outputdata)) connectionSocket.send(header.encode()) # Fill in end # Send the content of the requested file to the client for i in range(0, len(outputdata)): connectionSocket.send(outputdata[i].encode()) connectionSocket.close() except IOError: # Send response message for file not found # Fill in start header = \u0026#39; HTTP/1.1 404 Found\u0026#39; connectionSocket.send(header.encode()) connectionSocket.close() # Fill in end # Close client socket # Fill in start # Fill in end serverSocket = socket(AF_INET, SOCK_STREAM) # Prepare a sever socket # Fill in start # 定义ip和端口号，然后bind绑定socket host = \u0026#39;\u0026#39; port = 6789 serverSocket.bind((host, port)) serverSocket.listen(100) # Fill in end while True: # Establish the connection print(\u0026#39;Ready to serve...\u0026#39;) connectionSocket, addr = serverSocket.accept() t = threading.Thread(target=sonTcpConnect, args=(connectionSocket,)) t.start() serverSocket.close() 有一个要注意的地方是，在53行，args这个参数的括号内必须要加上逗号，原因是因为args是一个元组，需要在元素后面增加逗号。（资料来源：https://blog.csdn.net/chpllp/article/details/54381141）\n多次在浏览器请求之后，控制台输出如下： 说实话感觉可能有些bug ,// TODO记得修\n进阶题目2： 题目：\n不使用浏览器，编写自己的HTTP客户端来测试你的服务器。您的客户端将使用一个TCP连接用于连接到服务器，向服务器发送HTTP请求，并将服务器响应显示出来。您可以假定发送的HTTP请求将使用GET方法。 客户端应使用命令行参数指定服务器IP地址或主机名，服务器正在监听的端口，以及被请求对象在服务器上的路径。以下是运行客户端的输入命令格式。\nclient.py server_host server_port filename\n意思就是用python发送HTTP请求到服务器就可以了。\nfrom socket import * import sys clientSocket = socket(AF_INET, SOCK_STREAM) host = str(sys.argv[1]) port = int(sys.argv[2]) clientSocket.connect((host, port)) msg = \u0026#39;GET \u0026#39; + str(sys.argv[3]) clientSocket.send(msg.encode()) result = b\u0026#34;\u0026#34; while True: recv_data = clientSocket.recv(1024) if recv_data: result += recv_data if result.rfind(b\u0026#34;0\\r\\n\u0026#34;) != -1: break else: break print(\u0026#39;Received\u0026#39;, repr(result)) 这里要注意的是，如果没有用While True循环接收，可能只会接收到HTTP响应报文的请求头了。\n结果如下： ","permalink":"https://windypath.com/posts/simple_web_server_with_python/","summary":"来自书籍《计算机网络-自顶向下方法-第6版(课本)》第120页，第二章应用层的课后题第一题。\n基础题目 题目：在这个编程作业中，你将用Python语言开发一个简单的Web服务器，它仅能处理一个请求。具体而言，你的Web服务器将：（1）当一个客户（浏览器）联系时创建一个连接套接字；（2）从这个连接接收HTTP请求；（3）解释该请求以确定所请求的特定文件；（4）从服务器的文件系统获得请求的文件；（5）创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行；（6）经TCP连接向请求的浏览器发送响应。如果浏览器请求一个在该服务器中不存在的文件，服务器应当返回一个“404 Not Found”差错报文。\n参考或者说学习了github上moranzcw的仓库：Computer-Networking-A-Top-Down-Approach-NOTES的内容，完成了这道题。\n代码https://github.com/moranzcw如下：\n# import socket module from socket import * serverSocket = socket(AF_INET, SOCK_STREAM) # Prepare a sever socket # Fill in start # 定义ip和端口号，然后bind绑定socket host = \u0026#39;\u0026#39; port = 6789 serverSocket.bind((host, port)) serverSocket.listen(1) # Fill in end while True: # Establish the connection print(\u0026#39;Ready to serve...\u0026#39;) connectionSocket, addr = serverSocket.accept() # Fill in start #Fill in end try: message = connectionSocket.recv(1024) # Fill in start #Fill in end filename = message.","title":"使用Python开发一个简单的web服务器"},{"content":"参考的是《数据结构(C语言版)》上256页左右的哈希表的介绍，用了最简单的直接寻址法 + 链地址法。\n用的是Kotlin。\npackage main.kotlin /** * 手动实现简单的hash表 * 简单的数组 +链表 （无红黑树） * 要求哈希函数可配置（被自我否决，太复杂了啦），这次就先做比较简单的 直接定址法 + 链地址法 * * @Date 2021-10-16. * @author Johnathan Lin */ data class Node( val key: Int, //key var value: Int, //value var next: Node? //如果hash值重复了，则用头插法放进去 ) fun main() { // hash表，这次可为空 val size = 100 val hashArr: Array\u0026lt;Node?\u0026gt; = Array(size) { null } //插入 假设插入key 8 value 24 println(\u0026#34;插入key 8 value 24\u0026#34;) set(hashArr, size, 8, 24) { k, s -\u0026gt; k % s } println(\u0026#34;插入key 108 value 32\u0026#34;) set(hashArr, size, 108, 32) { k, s -\u0026gt; k % s } var v = get(hashArr, size, 108) { k, s -\u0026gt; k % s } println(\u0026#34;读取key为108: $v\u0026#34;) println(\u0026#34;删除key 108\u0026#34;) remove(hashArr, size, 108) { k, s -\u0026gt; k % s } v = get(hashArr, size, 108) { k, s -\u0026gt; k % s } println(\u0026#34;读取key为108: $v\u0026#34;) v = get(hashArr, size, 8) { k, s -\u0026gt; k % s } println(\u0026#34;读取key为8: $v\u0026#34;) } /** * @param hashFunc 哈希函数 param1：key param2：size */ fun get(hashArr: Array\u0026lt;Node?\u0026gt;, size: Int, key: Int, hashFunc: (Int, Int) -\u0026gt; Int): Node? { val pos = hashFunc.invoke(key, size) val queueHead = hashArr[pos] if (queueHead == null) { return null } else { if (queueHead.key == key) { return queueHead } var p = queueHead while(p?.next != null) { if (p.next?.key == key) { return p.next } p = p.next } } return null } fun set(hashArr: Array\u0026lt;Node?\u0026gt;, size: Int, key: Int, value: Int, hashFunc: (Int, Int) -\u0026gt; (Int)) { //get 不到的时候才会set val node = get(hashArr, size, key, hashFunc) if (node != null) { node.value = value } else { val pos = hashFunc.invoke(key, size) val newNode = Node(key, value, null) if (hashArr[pos] == null) { hashArr[pos] = newNode } else { val next = hashArr[pos]?.next if (next == null) { hashArr[pos]?.next = newNode } else { newNode.next = next hashArr[pos]?.next = newNode } } } } fun remove(hashArr: Array\u0026lt;Node?\u0026gt;, size: Int, key: Int, hashFunc: (Int, Int) -\u0026gt; (Int)) { val pos = hashFunc.invoke(key, size) val queueHead = hashArr[pos] if (queueHead == null) { return } else { if (queueHead.key == key) { if (queueHead.next != null) { //好像jdk7有一个hashMap的bug？ hashArr[pos] = queueHead.next return } else { hashArr[pos] = null } } else { var p = queueHead while(p?.next != null) { if (p.next?.key == key) { if (p.next?.next != null) { p.next = p.next?.next } else { p.next = null } return } p = p.next } } } } 然后是输出：\n插入key 8 value 24 插入key 108 value 32 读取key为108: Node(key=108, value=32, next=null) 删除key 108 读取key为108: null 读取key为8: Node(key=8, value=24, next=null) Process finished with exit code 0 ","permalink":"https://windypath.com/posts/kotlin_implement_a_simple_hashmap/","summary":"参考的是《数据结构(C语言版)》上256页左右的哈希表的介绍，用了最简单的直接寻址法 + 链地址法。\n用的是Kotlin。\npackage main.kotlin /** * 手动实现简单的hash表 * 简单的数组 +链表 （无红黑树） * 要求哈希函数可配置（被自我否决，太复杂了啦），这次就先做比较简单的 直接定址法 + 链地址法 * * @Date 2021-10-16. * @author Johnathan Lin */ data class Node( val key: Int, //key var value: Int, //value var next: Node? //如果hash值重复了，则用头插法放进去 ) fun main() { // hash表，这次可为空 val size = 100 val hashArr: Array\u0026lt;Node?\u0026gt; = Array(size) { null } //插入 假设插入key 8 value 24 println(\u0026#34;插入key 8 value 24\u0026#34;) set(hashArr, size, 8, 24) { k, s -\u0026gt; k % s } println(\u0026#34;插入key 108 value 32\u0026#34;) set(hashArr, size, 108, 32) { k, s -\u0026gt; k % s } var v = get(hashArr, size, 108) { k, s -\u0026gt; k % s } println(\u0026#34;读取key为108: $v\u0026#34;) println(\u0026#34;删除key 108\u0026#34;) remove(hashArr, size, 108) { k, s -\u0026gt; k % s } v = get(hashArr, size, 108) { k, s -\u0026gt; k % s } println(\u0026#34;读取key为108: $v\u0026#34;) v = get(hashArr, size, 8) { k, s -\u0026gt; k % s } println(\u0026#34;读取key为8: $v\u0026#34;) } /** * @param hashFunc 哈希函数 param1：key param2：size */ fun get(hashArr: Array\u0026lt;Node?","title":"Kotlin手动实现一个最简单的哈希表"},{"content":"参考了\nhttps://www.bilibili.com/video/BV11t4y1r79L\nhttps://blog.csdn.net/qq_19782019/article/details/78301832\n他们已经写的足够好了。我最近都在用Kotlin编程开发，我尝试用Kotlin实现了大顶堆，并且作为手动实现的优先级队列，通过了Leetcode 347。\npackage main.kotlin /** * 二叉堆（大顶堆、优先级队列） * * @Date 2021-10-14. * @author Johnathan Lin */ data class MaxHeap\u0026lt;T : Comparable\u0026lt;T\u0026gt;\u0026gt;( val arr: Array\u0026lt;T\u0026gt;, var size: Int ) { //将无序的数组构建一个二叉堆 fun makeHeap() { for (i in (size - 1) downTo 0) { heapDown(i) } } //向二叉堆中加入元素 fun addItem(value: T) { //TODO 添加的边界还未考虑 val newIndex = size++ arr[newIndex] = value heapUp(newIndex) } //移除堆顶元素 fun removeItem(): T { //TODO 删除的边界还未考虑 val removeValue = arr[0] val lastValue = arr[size - 1] // println(\u0026#34;lastValue:$lastValue\u0026#34;) arr[0] = lastValue size-- heapDown(0) return removeValue } fun printHeap() { for (i in 0..(size - 1)) { print(arr[i].toString() + \u0026#34; \u0026#34;) } println() } private fun heapDown(p: Int) { var i = p while (i \u0026lt; size) { //和左右子节点（如果存在）比大小，如果自己是最大则结束，如果不是，则将自己这个位置换成最大的，然后再从被换的位置继续比 val left = 2 * i + 1 val right = 2 * i + 2 var maxinum = i if (left \u0026lt; size \u0026amp;\u0026amp; arr[maxinum] \u0026lt; arr[left]) { maxinum = left } if (right \u0026lt; size \u0026amp;\u0026amp; arr[maxinum] \u0026lt; arr[right]) { maxinum = right } if (maxinum == i) { break } // println(\u0026#34;交换i: $i ${arr[i]}, maxinum:$maxinum ${arr[maxinum]}\u0026#34;) val tmp = arr[i] arr[i] = arr[maxinum] arr[maxinum] = tmp i = maxinum } } private fun heapUp(p: Int) { //从下往上不停地比较其父节点，比父节点大则交换 var i = p while (i \u0026gt;= 0 \u0026amp;\u0026amp; arr[i] \u0026gt; arr[(i - 1) / 2]) { val parentIndex = (i - 1) / 2 val tmp = arr[i] arr[i] = arr[parentIndex] arr[parentIndex] = tmp i = parentIndex } } } //自己定义的类型，实现Comparable接口 data class Data( val name: String, //名字 val weight: Int //权重 ) : Comparable\u0026lt;Data\u0026gt; { override fun compareTo(other: Data): Int { return if (weight \u0026gt; other.weight) { 1 } else if (weight \u0026lt; other.weight) { -1 } else { 0 } } override fun toString(): String { return \u0026#34;${name}-${weight}\u0026#34; } } fun main() { //TODO 这里由于Kotlin指定泛型Data为非空，所以要求对每个元素初始化，这步很浪费空间 //TODO 如果改为Array\u0026lt;Data?\u0026gt; 则很多地方都要判断是否为空 val arr: Array\u0026lt;Data\u0026gt; = Array(100) { i -\u0026gt; Data(\u0026#34;null\u0026#34;, i) } //测试数据 arr[0] = Data(\u0026#34;Kobe\u0026#34;, 5) arr[1] = Data(\u0026#34;James\u0026#34;, 4) arr[2] = Data(\u0026#34;Duncan\u0026#34;, 6) arr[3] = Data(\u0026#34;Garnett\u0026#34;, 8) arr[4] = Data(\u0026#34;Wall\u0026#34;, 2) arr[5] = Data(\u0026#34;Nash\u0026#34;, 10) arr[6] = Data(\u0026#34;Howard\u0026#34;, 12) arr[7] = Data(\u0026#34;Paul\u0026#34;, 3) arr[8] = Data(\u0026#34;Anthony\u0026#34;, 7) arr[9] = Data(\u0026#34;Yi\u0026#34;, 11) println(\u0026#34;构建二叉堆\u0026#34;) val heap: MaxHeap\u0026lt;Data\u0026gt; = MaxHeap(arr, 10) //将无序的数组构建一个二叉堆 heap.makeHeap() heap.printHeap() //加入一个元素，预计这个元素会到堆顶 val added = Data(\u0026#34;Gasol\u0026#34;, 16) println(\u0026#34;添加一个元素${added.toString()}\u0026#34;) heap.addItem(added) heap.printHeap() val removed = heap.removeItem() println(\u0026#34;移除了顶部元素${removed.toString()}\u0026#34;) heap.printHeap() println(\u0026#34;finish\u0026#34;) } 输出结果如下：\n构建二叉堆 Howard-12 Yi-11 Nash-10 Garnett-8 James-4 Kobe-5 Duncan-6 Paul-3 Anthony-7 Wall-2 添加一个元素Gasol-16 Gasol-16 Howard-12 Nash-10 Garnett-8 Yi-11 Kobe-5 Duncan-6 Paul-3 Anthony-7 Wall-2 James-4 移除了顶部元素Gasol-16 Howard-12 Yi-11 Nash-10 Garnett-8 James-4 Kobe-5 Duncan-6 Paul-3 Anthony-7 Wall-2 finish Process finished with exit code 0 然后我将其进行修改，提交到LeetCode，通过，代码如下：\ndata class MaxHeap\u0026lt;T:Comparable\u0026lt;T\u0026gt;\u0026gt;( val arr:Array\u0026lt;T\u0026gt;, var size: Int ) { fun makeHeap() { for(i in (size - 1) downTo 0) { heapDown( i) } } fun heapDown(p: Int) { var i = p while(i \u0026lt; size) { // if(i == 0) { // println(\u0026#34;i: $i, arr[i] = ${arr[i]}\u0026#34;) // } val left = 2 * i + 1 val right = 2 * i + 2 var maxinum = i if (left \u0026lt; size \u0026amp;\u0026amp; arr[maxinum] \u0026lt; arr[left]) { maxinum = left } if (right \u0026lt; size \u0026amp;\u0026amp; arr[maxinum] \u0026lt; arr[right]) { maxinum = right } if (maxinum == i) { break } // println(\u0026#34;交换i: $i ${arr[i]}, maxinum:$maxinum ${arr[maxinum]}\u0026#34;) val tmp = arr[i] arr[i] = arr[maxinum] arr[maxinum] = tmp i = maxinum } } fun heapUp(p: Int) { var i = p while (i \u0026gt;= 0 \u0026amp;\u0026amp; arr[i] \u0026gt; arr[(i-1)/2]) { val parentIndex = (i-1)/2 val tmp = arr[i] arr[i] = arr[parentIndex] arr[parentIndex] = tmp i = parentIndex } } fun addItem(value: T) { val newIndex = size++ arr[newIndex] = value heapUp(newIndex) } fun removeItem():T { val removeValue = arr[0] val lastValue = arr[size-1] // println(\u0026#34;lastValue:$lastValue\u0026#34;) arr[0] = lastValue size-- heapDown(0) return removeValue } } data class Data( val value: Int, val num: Int ): Comparable\u0026lt;Data\u0026gt; { override fun compareTo(other: Data): Int { return if (num \u0026gt; other.num) { 1 } else if (num \u0026lt; other.num) { -1 } else { 0 } } override fun toString(): String { return \u0026#34;${value}-${num}\u0026#34; } } class Solution { fun topKFrequent(nums: IntArray, k: Int): IntArray { val res = IntArray(k); val arr:Array\u0026lt;Data\u0026gt; = Array(nums.size) {i -\u0026gt; Data(0, 0)} // val arr: Array\u0026lt;Data\u0026gt; = Array(nums.size) { i -\u0026gt; Data(0, 0) } val maxHeap = MaxHeap(arr, 0) val map: HashMap\u0026lt;Int, Int\u0026gt; = hashMapOf() nums.forEach { it -\u0026gt; map[it] = map.getOrDefault(it, 0) + 1 } map.forEach { key, value -\u0026gt; maxHeap.addItem(Data(key, value)) } for(i in 1..k) { res[i-1] = maxHeap.removeItem().value } return res } } ","permalink":"https://windypath.com/posts/kotlin_implement_heap/","summary":"参考了\nhttps://www.bilibili.com/video/BV11t4y1r79L\nhttps://blog.csdn.net/qq_19782019/article/details/78301832\n他们已经写的足够好了。我最近都在用Kotlin编程开发，我尝试用Kotlin实现了大顶堆，并且作为手动实现的优先级队列，通过了Leetcode 347。\npackage main.kotlin /** * 二叉堆（大顶堆、优先级队列） * * @Date 2021-10-14. * @author Johnathan Lin */ data class MaxHeap\u0026lt;T : Comparable\u0026lt;T\u0026gt;\u0026gt;( val arr: Array\u0026lt;T\u0026gt;, var size: Int ) { //将无序的数组构建一个二叉堆 fun makeHeap() { for (i in (size - 1) downTo 0) { heapDown(i) } } //向二叉堆中加入元素 fun addItem(value: T) { //TODO 添加的边界还未考虑 val newIndex = size++ arr[newIndex] = value heapUp(newIndex) } //移除堆顶元素 fun removeItem(): T { //TODO 删除的边界还未考虑 val removeValue = arr[0] val lastValue = arr[size - 1] // println(\u0026#34;lastValue:$lastValue\u0026#34;) arr[0] = lastValue size-- heapDown(0) return removeValue } fun printHeap() { for (i in 0.","title":"Kotlin实现二叉堆、大顶堆、优先级队列"},{"content":"系统及软件配置 系统配置 内存：16g 2400 cpu：i5 9400F\n软件配置 Windows 10 1903版本 VMware workstation 15.10 CentOS centos-release-7-7.1908.0.el7.centos.x86_64 Java jdk-8u241-linux-x64.tar.gz Scala scala-2.11.8.tgz 值得一提的是，win10 1903版本与VMware 15.10之前的版本不兼容，会出现卡死（虚拟机繁忙）的问题，该问题在15.10版本解决。 资源来源于网络： VMware 15.10 链接：https://pan.baidu.com/s/1bpF3M1V3qPydQgGl-hUC1g 提取码：sb8t CentOS 7.7 链接：https://pan.baidu.com/s/1xFOlCvNrmXXwciVNOL2Pew 提取码：wxdx Java jdk-8u241-linux-x64.tar.gz 链接：https://pan.baidu.com/s/1E1TyObvyO6iQUW44lTCqDQ 提取码：6xw9 Scala scala-2.11.8.tgz 链接：https://pan.baidu.com/s/1TQB-wnffHh0i2aqzzfSi6A 提取码：iowh\n安装前的准备 查看Windows下的网络配置 以Windows 10 1903为例（windows下控制台输入“winver”可以看自己windows版本），在控制面板-\u0026gt;网络和Internet-\u0026gt;网络连接中，可以看到本机上的网络配置。本次搭建这个集群，我们需要虚拟机和物理机（也就是windows）共用一个网络，所以需要使用桥接模式。 本人电脑联网时使用的是这个WLAN 2，它使用的网卡是Realtek 8821AE \u0026hellip;. 的，记住这个名字。\n配置VMware 虚拟网络编辑器 使用管理员权限打开VMware，菜单栏的编辑-\u0026gt;虚拟网络适配器：将桥接模式的“桥接到”指向刚才记下的Realtek 8821AE，点击确定保存配置。 同时还要记住我WLAN 2这张网卡的网络配置信息：（windows cmd输入ipconfig查看） 集群及网络配置 根据刚才WLAN 2网络配置信息可知，我的虚拟机的网卡只能配置为192.168.3.***。 你得根据自己网卡上的网络配置去修改虚拟机网卡配置。\n序号 IP地址 机器名 运行进程 核数/内存 用户名 1 192.168.3.30 master NN/SNN/DN/RM\nMaster/Worker 1核/3G spark 2 192.168.3.31 slave1 DN/NM/Worker 1核/2G spark 3 192.168.3.32 slave2 DN/NM/Worker 1核/2G spark 用到的目录： /app,/app/soft,/app/compile,/app/spark,/home/spark 开始安装 搭建集群样板机 在VMware中安装CentOS 新建虚拟机 菜单栏，文件-\u0026gt;新建虚拟机 选择刚才下载的CentOS镜像： 一路下一步到这里，点击“自定义硬件”把内存调成3G，网络适配器调成桥接模式，然后完成并启动。 按↑键，选中Install CentOS 7，再按Enter键开始安装。 安装CentOS 7 选择语言简体中文后，进入到这个界面： 点击这个“软件选择”，进入选择界面： 勾选GNOME桌面，然后自定义勾选需要的附加选项，我这里只选了“兼容性程序库”和“系统管理工具”，之后如果有缺少软件的话，之后再补装就好。点击左上角完成。 选择网络和主机名，可以配置网络。 配置网络 打开以太网的连接，然后点击“配置”，切到IPv4设置，输入刚才我定义的第一台虚拟机的ip地址192.168.3.30，子网掩码255.255.255.0，网关和物理机windows一样192.168.3.1（见前文），最后附加DNS服务器填入谷歌提供的8.8.8.8。 然后点一下安装位置，选择自动分区，再回来就可以点“开始安装”了。 设置用户 安装过程中，可以设置root和用户，简单设置吧以免忘记密码。 以下是我设置的root和用户（仅做学习之用，也以防忘记密码）：\n用户 密码 root root spark spark 由于密码太过简单，我们需要多按一次左上角的“完成”。 值得一提的是，如果不在这里设置root和用户，在安装结束后设置的话，系统会要求你设置比较复杂的密码。 静静等待其安装完。 重启，然后接受许可证，点完成，使用spark用户登录，再简单配置下，就正式进入系统。\n测试网络 点击应用程序-\u0026gt;Firefox，然后访问百度，如果成功则网络连接正常。 设置机器名 用root使用vi /etc/sysconfig/network中设置内容如下：\nNETWORKING=yes HOSTNAME=master 至此，CentOS安装完成。\n设置Host映射文件 /etc/hosts内保存了网址域名/机器名与其对应的ip地址建立关联的一个“数据库”，我们根据集群规划配置： 以root的身份（先su root然后输入root的密码）在命令行用#vi /etc/hosts打开配置文件，然后按小写字母i，输入以下内容然后按Esc + :wq回车保存：\n192.168.3.30 master 192.168.3.31 slave1 192.168.3.32 slave2 设置完毕后，用#ping master看看master是否连通及检测服务器响应速度。 关闭防火墙和SELinux 关闭防火墙和SELinux的原因在于Hadoop和Spark运行过程中需要使用端口进行通信，而这些安全设施会阻拦。关闭方法： 关闭iptables时，使用root登录，在命令行终端使用#service iptables status查看iptables状态，如果显示“iptables: Firewall is not running”则iptables已关闭，如果显示iptables的配置信息，则使用如下命令关闭iptables：\nchkconfig iptables off 同样，用root用户在终端使用#vi /etc/SELinux/config打开配置文件，设置SELINUX=disable，注意需要重启才生效。 然而在我们虚拟机上并没有iptables： SELinux设置为disable。 配置运行环境 更新OpenSSL CentOS自带的OpenSSL存在bug，所以我们使用如下命令更新\nyum update openssl 当然了我自己跑了一下并没有看到需要更新，也许centos7修复了。 修改OpenSSH配置 在集群环境中需要SSH进行免密码登录，需要修改OpenSSH配置文件，确认使用RSA算法进行公钥加密并确认私钥存放文件等，需要使用root用户，使用vi /etc/ssh/sshd_config打开配置文件，打开以下三个配置项： 保存修改后使用systemctl restart sshd.service重启服务。\n将用户spark加入sudoers中 后面执行中需要使用sudo命令，故将spark加入sudoers文件中，先修改配置文件的权限：chmod u+x /etc/sudoers，再使用vi /etc/sudoers打开文件，在root ALL=(ALL)ALL后加入：\nspark ALL=(ALL) ALL 他虽然说是只读，但是你可以用root编辑，然后使用wq! 加感叹号保存。\n创建运行环境所需要的目录结构 mkdir /app chown -R spark:spark /app mkdir /app/soft mkdir /app/compile mkdir /app/spark mkdir -p /home/spark/work chown -R spark:spark /home/spark/work 安装Java和Spark环境 安装和配置JDK 安装一下vmware tools，然后把jdk的包拖进去，放到/home/spark/work中。（这个找一找centos虚拟机安装vmware tools教程吧） 解压该文件并移动到/app/soft中\ncd /home/spark/work tar -zxf jdk-8u241-linux-x64.tar.gz mv jdk1.8.0_241 /app/soft ll /app/soft 然后以root执行vi /etc/profile，设置JDK相关配置如下：\nexport JAVA_HOME=/app/soft/jdk1.8.0_241 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 保存后回到终端，输入source /etc/profile更新全局变量，然后输入java和javac看看是否安装成功。\n安装Scala 把scala安装包放入/home/spark/work中。解压该文件并移动到/app/soft中。\ncd /home/spark/work tar -zxf scala-2.11.8.tgz mv scala-2.11.8 /app/soft ll /app/soft 然后以root执行vi /etc/profile，设置JDK相关配置如下：\nexport SCALA_HOME=/app/soft/scala-2.11.8 export PATH=${SCALA_HOME}/bin:$PATH 保存后回到终端，输入source /etc/profile更新全局变量，然后输入scala -version看看是否安装成功。\n参考文献 《图解Spark：核心技术与案例实战》https://item.jd.com/12021791.html VMware设置centos7共享文件夹 https://blog.csdn.net/nesxiaogu/article/details/85274626 vmware-hgfsclient结果为空解决办法 https://blog.csdn.net/qq_43371004/article/details/103101426 ","permalink":"https://windypath.com/posts/build_spark_environment/","summary":"系统及软件配置 系统配置 内存：16g 2400 cpu：i5 9400F\n软件配置 Windows 10 1903版本 VMware workstation 15.10 CentOS centos-release-7-7.1908.0.el7.centos.x86_64 Java jdk-8u241-linux-x64.tar.gz Scala scala-2.11.8.tgz 值得一提的是，win10 1903版本与VMware 15.10之前的版本不兼容，会出现卡死（虚拟机繁忙）的问题，该问题在15.10版本解决。 资源来源于网络： VMware 15.10 链接：https://pan.baidu.com/s/1bpF3M1V3qPydQgGl-hUC1g 提取码：sb8t CentOS 7.7 链接：https://pan.baidu.com/s/1xFOlCvNrmXXwciVNOL2Pew 提取码：wxdx Java jdk-8u241-linux-x64.tar.gz 链接：https://pan.baidu.com/s/1E1TyObvyO6iQUW44lTCqDQ 提取码：6xw9 Scala scala-2.11.8.tgz 链接：https://pan.baidu.com/s/1TQB-wnffHh0i2aqzzfSi6A 提取码：iowh\n安装前的准备 查看Windows下的网络配置 以Windows 10 1903为例（windows下控制台输入“winver”可以看自己windows版本），在控制面板-\u0026gt;网络和Internet-\u0026gt;网络连接中，可以看到本机上的网络配置。本次搭建这个集群，我们需要虚拟机和物理机（也就是windows）共用一个网络，所以需要使用桥接模式。 本人电脑联网时使用的是这个WLAN 2，它使用的网卡是Realtek 8821AE \u0026hellip;. 的，记住这个名字。\n配置VMware 虚拟网络编辑器 使用管理员权限打开VMware，菜单栏的编辑-\u0026gt;虚拟网络适配器：将桥接模式的“桥接到”指向刚才记下的Realtek 8821AE，点击确定保存配置。 同时还要记住我WLAN 2这张网卡的网络配置信息：（windows cmd输入ipconfig查看） 集群及网络配置 根据刚才WLAN 2网络配置信息可知，我的虚拟机的网卡只能配置为192.168.3.***。 你得根据自己网卡上的网络配置去修改虚拟机网卡配置。\n序号 IP地址 机器名 运行进程 核数/内存 用户名 1 192.168.3.30 master NN/SNN/DN/RM","title":"搭建Spark实战环境（3台linux虚拟机集群）（一）样板机的搭建"},{"content":"单条件查询 使用BasicDBObject配置查询条件\nList\u0026lt;AbstractMongoEntity\u0026gt; list = Lists.newArrayList(); // 配置查询条件 BasicDBObject cond1 = new BasicDBObject(); cond1.append(\u0026#34;_id\u0026#34;, new ObjectId(\u0026#34;5de39f20684014f1d8b8fa37\u0026#34;)); FindIterable\u0026lt;Document\u0026gt; findIterable = // 执行查询 mongoTemplate.getCollection(\u0026#34;crawler_cjwt\u0026#34;).find(cond1); // 装配查询结果 MongoCursor\u0026lt;Document\u0026gt; cursor = findIterable.iterator(); Document document = null; CjwtMongoEntity question = null; while (cursor.hasNext()) { document = cursor.next(); // 使用MongoConverter可以将结果对象映射到Java Bean question = mongoConverter.read(CjwtMongoEntity.class, document); list.add(question); } System.out.println(question); cursor.close(); 返回的是一个指针，所以我们需要通过该指针遍历结果，并装进list中返回使用。 对应的mongo脚本：\ndb.crawler_cjwt.find({\u0026#39;_id\u0026#39;:new ObjectId(\u0026#34;5de39f20684014f1d8b8fa37\u0026#34;)}) 查询该集合所有结果 List\u0026lt;FgcxMongoEntity\u0026gt; list = Lists.newArrayList(); // find函数没有传参，即查询所有 FindIterable\u0026lt;Document\u0026gt; findIterable = crawlMongoTemplate.getCollection(\u0026#34;fgcx\u0026#34;).find(); MongoCursor\u0026lt;Document\u0026gt; cursor = findIterable.iterator(); FgcxMongoEntity question = null; while (cursor.hasNext()) { question = mongoConverter.read(FgcxMongoEntity.class, cursor.next()); list.add(question); } cursor.close(); 多条件查询 String cityClassifyId = \u0026#34;b2c7147e804b48f8af562fbe1f1c32f6\u0026#34;; // 上面这部分是获取省，市的名字 IndustryRepoClassify cityClassify = industryRepoClassifyMapper.selectByPrimaryKey(cityClassifyId); IndustryRepoClassify provinceClassify = industryRepoClassifyMapper.selectByPrimaryKey(cityClassify.getParentId()); IndustryRepoClassify bsznClassify = industryRepoClassifyMapper.selectByPrimaryKey(provinceClassify.getParentId()); // 获取集合对象 MongoCollection\u0026lt;Document\u0026gt; collection = mongoTemplate.getCollection(\u0026#34;bszn\u0026#34;); // 配置查询BasicDBObject BasicDBObject filterCondition = new BasicDBObject(); filterCondition.append(\u0026#34;province.value\u0026#34;, provinceClassify.getClassifyName()); filterCondition.append(\u0026#34;city.value\u0026#34;, cityClassify.getClassifyName()); // 执行查询 FindIterable\u0026lt;Document\u0026gt; findIterable = collection.find(filterCondition); List\u0026lt;Document\u0026gt; res = (List\u0026lt;Document\u0026gt;) findIterable; 等价于Mongo脚本：\ndb.bszn.find({$and:[{\u0026#39;province.value\u0026#39;: \u0026#39;某省份\u0026#39;}, {\u0026#39;city.value\u0026#39;: \u0026#39;某城市\u0026#39;}]}) $in查询 List\u0026lt;String\u0026gt; idList = Arrays.asList(\u0026#34;5a08fea2704f44dda6e3d0a25d89014a\u0026#34;, \u0026#34;96e71f036fa74bceac41130902f8d2be\u0026#34;); BasicDBObject query = new BasicDBObject(); BasicDBList conditionList = new BasicDBList(); for (String id : idList) { conditionList.add(id); } // 在这里用$in做键，用上面定义的字符串数组为值 query.put(\u0026#34;classify_id\u0026#34;, new BasicDBObject(\u0026#34;$in\u0026#34;, conditionList)); FindIterable\u0026lt;Document\u0026gt; findIterable = mongoTemplate.getCollection(\u0026#34;crawler_classify\u0026#34;).find(query); MongoCursor\u0026lt;Document\u0026gt; cursor = findIterable.iterator(); IndustryRepoClassify question = null; List\u0026lt;IndustryRepoClassify\u0026gt; list = Lists.newArrayList(); while (cursor.hasNext()) { question = mongoConverter.read(IndustryRepoClassify.class, cursor.next()); list.add(question); } cursor.close(); 等价于Mongo脚本：\ndb.crawler_classify.find({\u0026#39;classify_id\u0026#39;: {$in:[\u0026#39;5a08fea2704f44dda6e3d0a25d89014a\u0026#39;, \u0026#39;96e71f036fa74bceac41130902f8d2be\u0026#39;]}}) 更新某个属性 Bson filter = new BasicDBObject().append(\u0026#34;_id\u0026#34;, new ObjectId(\u0026#34;5def5b6d5f090d15618df344\u0026#34;)); BasicDBObject set = new BasicDBObject(); set.append(\u0026#34;kobe.value\u0026#34;,\u0026#34;33,\u0026#34;); Bson update = new Document(\u0026#34;$set\u0026#34;,set); crawlMongoTemplate.getCollection(\u0026#34;test\u0026#34;).updateOne(filter, update); 等价于Mongo脚本：\ndb.test.update({\u0026#39;_id\u0026#39;: new ObjectId(\u0026#34;5def5b6d5f090d15618df344\u0026#34;)}, {$set:{\u0026#39;kobe.value\u0026#39;:\u0026#39;33,\u0026#39;}},{}) 用于接取Mongo数据的Java Bean定义注意事项 import com.alibaba.fastjson.JSONObject; import com.google.common.collect.Lists; import lombok.*; import org.bson.types.ObjectId; import org.springframework.data.mongodb.core.mapping.Field; import java.util.List; import java.util.Map; /** * @Date: 2019/12/11 17:37 */ @Data @Getter @Setter @ToString @NoArgsConstructor @AllArgsConstructor public class CjwtMongoEntity { /** * mongoid */ private ObjectId id; /** * url */ @Field private Map url; /** * 数据来源 */ @Field private Map source; /** * 数据采集时间 */ @Field private Map time; /** * 批次号 */ @Field(\u0026#34;batch_number\u0026#34;) private Map batchNumber; /** * 省份 */ @Field private Map province; /** * 数据来源 人为添加：artificial 爬虫添加 crawler */ @Field(\u0026#34;data_source\u0026#34;) private Map dataSource; } 注意的点有两个，一是id直接定义为ObjectId类型就可以了，二是其他的属性需要与Mongo文档中对应，如果不是完全一致，则需要在@Field注解后面加上Mongo文档中的键名。\n","permalink":"https://windypath.com/posts/spring_operate_mongodb/","summary":"单条件查询 使用BasicDBObject配置查询条件\nList\u0026lt;AbstractMongoEntity\u0026gt; list = Lists.newArrayList(); // 配置查询条件 BasicDBObject cond1 = new BasicDBObject(); cond1.append(\u0026#34;_id\u0026#34;, new ObjectId(\u0026#34;5de39f20684014f1d8b8fa37\u0026#34;)); FindIterable\u0026lt;Document\u0026gt; findIterable = // 执行查询 mongoTemplate.getCollection(\u0026#34;crawler_cjwt\u0026#34;).find(cond1); // 装配查询结果 MongoCursor\u0026lt;Document\u0026gt; cursor = findIterable.iterator(); Document document = null; CjwtMongoEntity question = null; while (cursor.hasNext()) { document = cursor.next(); // 使用MongoConverter可以将结果对象映射到Java Bean question = mongoConverter.read(CjwtMongoEntity.class, document); list.add(question); } System.out.println(question); cursor.close(); 返回的是一个指针，所以我们需要通过该指针遍历结果，并装进list中返回使用。 对应的mongo脚本：\ndb.crawler_cjwt.find({\u0026#39;_id\u0026#39;:new ObjectId(\u0026#34;5de39f20684014f1d8b8fa37\u0026#34;)}) 查询该集合所有结果 List\u0026lt;FgcxMongoEntity\u0026gt; list = Lists.newArrayList(); // find函数没有传参，即查询所有 FindIterable\u0026lt;Document\u0026gt; findIterable = crawlMongoTemplate.getCollection(\u0026#34;fgcx\u0026#34;).find(); MongoCursor\u0026lt;Document\u0026gt; cursor = findIterable.","title":"Springboot操作MongoDB，包括增改查及复杂操作"},{"content":" 这是一篇在公司写的文档，但不涉及公司隐私。几乎所有内容参考于：https://www.cnblogs.com/welcomer/p/5068287.html\n引言 编写目的 编写本文档是为了让读者快速上手使用Unison进行两台Linux服务器文件进行同步。\n前景 Unison是windows和unix平台下都可以使用的双向文件同步工具，它能使两个文件夹（本地或网络上的）保持内容的一致。 unison 拥有其它一些同步工具或文件系统的相同特性，但也有自己的特点：\n跨平台使用； 对内核和用户 权限 没有特别要求； unison 是双向的，它能自动 处理两分拷贝中更新没有冲突的部分，有冲突的部分将会显示出来让用户选择更新策略； 只要是能连通的两台主机 ，就可以运行 unison ，可以直接使用 socket 连接或安全的 ssh 连接方式，对带宽 的要求不高，使用类似 rsync 的压缩传输协议。\nUnison双向同步的一个缺点是,对于同名文件在两个同步文件夹中都被修改时,unison是不会去同步的,因为unison无法判断以那个为准。\n定义 本文档介绍如何同步两台服务器，为表述方便，将第一台服务器命名为“服务器1”，操作该服务器的用户为“system1”；将第二台服务器命名为“服务器2”，操作该服务器的用户命名为“system2”。\n参考资料 《使用Unison同步服务器目录》 https://www.cnblogs.com/welcomer/p/5068287.html\n安装与初始化 由于在目录同步时需要跨服务器通过ssh连接，因此不建议使用root用户，建议新建普通用户进行操作。\n在两台或多台服务器之间同步，只需要在第一台服务器上安装Unison，再用scp连接将可执行的unison文件复制到第二台服务器上即可。\n安装Unison 由于使用源码包安装Unison需要安装Ocaml依赖，且Unison默认将文件复制到“/用户名/bin/”目录下，会导致在make install步骤时提示错误，所以建议使用apt-get或yum安装。\nUbuntu下安装：在配置好阿里云的apt-get源之后，使用sudo apt-get install unison安装。\nCentoOS下安装：使用yum install unison安装。\n将Unison复制到服务器2 使用apt-get或yum安装Unison后，默认放在/usr/bin/unison。\n1、使用ssh连接到远程主机：\nscp /usr/bin/unison root@服务器2的IP地址:/root/ 注意：在Ubuntu下，如果服务器没有安装openssh-server，则无法被其他服务器连接，解决方法：\n使用sudo apt-get install openssh-server安装 在/etc/ssh/sshd_config文件中，把将PermitRootLogin prohibie-password 修改为：PermitRootLogin yes 重启ssh服务即可使用。 2、登录服务器2，使用复制命令，将可执行文件unison从/root/移到/usr/bin/下。\ncp /root/unison /usr/bin/ 3、在两台服务器上都输入unison –version，查看是否安装成功。如果返回了版本号，则安装成功。\n[root@服务器名 ~]$ unison -version unison version 2.40.128 Unison的配置 配置ssh key信任 即配置公私钥。从这里开始，建议使用普通用户进行操作。\n新建普通用户 使用useradd –m 用户名 新建用户，再使用passwd 用户名 为用户设置密码。 使用 su 用户名 ，从root用户转到普通用户。 本文使用用户system1指代服务器1的用户，system2指代服务器2的用户。\n在服务器1上配置服务器2的信任 在服务器1新建ssh key 在服务器1的system1用户下，\n使用命令 ssh-keygen –t rsa 命令生成公私钥，在提示保存私钥（key）和公钥（public key）的位置时，使用默认值； 在提示是否需要私钥密码（passphrase）时，直接敲回车，即不使用私钥密码。 系统将生成一对密钥，id_rsa（私钥文件）和id_rsa.pub（公钥文件），保存在/home/system1/.ssh/目录下。 将公钥添加到服务器2 1、将~/.ssh/id_rsa.pub公钥文件上传到服务器2\n[system1@服务器1~]$ scp ~/.ssh/id_rsa.pub system2@服务器2ip地址:/home/system2/ 2、使用system2登录服务器2\n（1）在~目录下新建文件夹.ssh，并使用chmod赋予权限\nmkdir .ssh chmod 700 .ssh （2）将刚才system1生成的公钥id_rsa.pub移动到刚才system2新建的.ssh目录下，并重命名为authorized_keys，并使用chmod赋予权限\nmv ~/id_rsa.pub ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys 至此，配置服务器1信任服务器2完成。\n在服务器2上配置服务器1的信任 执行方法与服务器1完全一致。在服务器2上，使用system2登录，然后使用ssh-keygen –t rsa 生成公私钥，使用scp复制公钥到服务器1的system1的~目录下，在服务器1上将服务器2的id_rsa.pub公钥移动到~/.ssh/下并改名为authorized_keys。\n重启ssh服务 在两台服务器上分别使用如下命令以重启ssh服务。\n/etc/init.d/ssh stop /etc/init.d/ssh start Unison配置文件 新建测试目录 在两个服务器的~目录下分别新建test目录，此目录将作为之后被同步的目录。\n[system1@服务器1 ~]$ mkdir test [system2@服务器2 ~]$ mkdir test 首次使用Unison同步 在两台服务器上分别执行一次unison，如果出现提示确认，则直接敲回车选择默认值。\n[system1@服务器1~]$unison /home/system1/test/ ssh://system2@服务器2//home/system2/test/ [system2@服务器2~]$unison /home/system2/test/ ssh://system1@服务器1//home/system1/test/ 在首次同步之后，Unison会在用户的~目录下新建一个.unison目录，里面会有一个default.prf，这是unison同步的配置文件，编辑这个文件，之后就可以直接使用unison命令执行同步。\n编辑配置文件default.prf 对服务器1的default.prf进行如下编辑：\n#Unison preferences file root = /home/system1/test root = ssh://system2@服务器2//home/system2/test/ #force = #ignore = batch = true #repeat = 1 #retry = 3 #owner = true #group = true perms = -1 fastcheck = false rsync = false sshargs = -C xferbycopying = true log = true logfile = /home/system1/.unison/unison.log 对服务器2的default.prf进行如下编辑：\n#Unison preferences file root = /home/system2/test root = ssh://system1@服务器1//home/system1/test/ #force = #ignore = batch = true #repeat = 1 #retry = 3 #owner = true #group = true perms = -1 fastcheck = false rsync = false sshargs = -C xferbycopying = true log = true logfile = /home/system2/.unison/unison.log 相关注解如下：\nforce表示会以本地所指定文件夹为标准，将该目录同步到远端。这里需要注意，如果指定了force参数，那么Unison就变成了单项同步了，也就是说会以force指定的文件夹为准进行同步，类似与rsync。\nUnison双向同步基本原理是：假如有A B两个文件夹，A文件夹把自己的改动同步到B，B文件夹也把自己的改动同步到A，最后A B两文件夹的内容相同，是AB文件夹的合集。\nUnison双向同步的一个缺点是，对于一个文件在两个同步文件夹中都被修改时，unison是不会去同步的，因为unison无法判断以那个为准。\nignore = Path表示忽略指定目录，即同步时不同步它。\nbatch = true，表示全自动模式，接受缺省动作，并执行。\n-fastcheck true 表示同步时仅通过文件的创建时间来比较，如果选项为false，Unison则将比较两地文件的内容。\nlog = true 表示在终端输出运行信息。\nlogfile 指定输出的log文件。\n运行 执行unison命令进行同步 在终端下，直接输入命令unison即可同步。\n在没有发生更改时，运行的结果为：\n在目标目录test下有文件发生改变时，运行结果为： 设置定时任务自动同步 使用crontab进行自动同步。\n(1)使用crontab –e 命令编辑定时任务。 (2)在文件最后一行输入cron表达式 + 要执行的命令，如果要每分钟执行一次同步，则输入：\n* * * * * unison 然后按下ctrl+O，会提示保存，按回车确认保存；\n最后按下ctrl+X退出。\n(3)在终端输入crontab –l 查看当前正在运行的定时任务 ","permalink":"https://windypath.com/posts/unison_install_in_linux/","summary":"这是一篇在公司写的文档，但不涉及公司隐私。几乎所有内容参考于：https://www.cnblogs.com/welcomer/p/5068287.html\n引言 编写目的 编写本文档是为了让读者快速上手使用Unison进行两台Linux服务器文件进行同步。\n前景 Unison是windows和unix平台下都可以使用的双向文件同步工具，它能使两个文件夹（本地或网络上的）保持内容的一致。 unison 拥有其它一些同步工具或文件系统的相同特性，但也有自己的特点：\n跨平台使用； 对内核和用户 权限 没有特别要求； unison 是双向的，它能自动 处理两分拷贝中更新没有冲突的部分，有冲突的部分将会显示出来让用户选择更新策略； 只要是能连通的两台主机 ，就可以运行 unison ，可以直接使用 socket 连接或安全的 ssh 连接方式，对带宽 的要求不高，使用类似 rsync 的压缩传输协议。\nUnison双向同步的一个缺点是,对于同名文件在两个同步文件夹中都被修改时,unison是不会去同步的,因为unison无法判断以那个为准。\n定义 本文档介绍如何同步两台服务器，为表述方便，将第一台服务器命名为“服务器1”，操作该服务器的用户为“system1”；将第二台服务器命名为“服务器2”，操作该服务器的用户命名为“system2”。\n参考资料 《使用Unison同步服务器目录》 https://www.cnblogs.com/welcomer/p/5068287.html\n安装与初始化 由于在目录同步时需要跨服务器通过ssh连接，因此不建议使用root用户，建议新建普通用户进行操作。\n在两台或多台服务器之间同步，只需要在第一台服务器上安装Unison，再用scp连接将可执行的unison文件复制到第二台服务器上即可。\n安装Unison 由于使用源码包安装Unison需要安装Ocaml依赖，且Unison默认将文件复制到“/用户名/bin/”目录下，会导致在make install步骤时提示错误，所以建议使用apt-get或yum安装。\nUbuntu下安装：在配置好阿里云的apt-get源之后，使用sudo apt-get install unison安装。\nCentoOS下安装：使用yum install unison安装。\n将Unison复制到服务器2 使用apt-get或yum安装Unison后，默认放在/usr/bin/unison。\n1、使用ssh连接到远程主机：\nscp /usr/bin/unison root@服务器2的IP地址:/root/ 注意：在Ubuntu下，如果服务器没有安装openssh-server，则无法被其他服务器连接，解决方法：\n使用sudo apt-get install openssh-server安装 在/etc/ssh/sshd_config文件中，把将PermitRootLogin prohibie-password 修改为：PermitRootLogin yes 重启ssh服务即可使用。 2、登录服务器2，使用复制命令，将可执行文件unison从/root/移到/usr/bin/下。\ncp /root/unison /usr/bin/ 3、在两台服务器上都输入unison –version，查看是否安装成功。如果返回了版本号，则安装成功。\n[root@服务器名 ~]$ unison -version unison version 2.","title":"Unison在Linux下的安装与使用"},{"content":"pom.xml添加的依赖：\n\u0026lt;!-- https://mvnrepository.com/artifact/ch.ethz.ganymed/ganymed-ssh2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.ethz.ganymed\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ganymed-ssh2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;262\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这里注意，不同版本的这玩意用法有差别。这里我使用的是262。\n操作类代码如下：\nimport ch.ethz.ssh2.*; import java.io.*; /** * @Author: 风萧古道的博客 windypath.com * @Date: 2019/11/29 15:14 */ public class SSHUtil { // uploadFile to Linux /** * 上传文件到Linux * * @param ip ip地址 * @param username 登录用户名 * @param password 密码 * @param remoteFilePath 目标文件所在完整目录 * @param file 本地文件File对象 * @return */ public static boolean uploadFile(String ip, String username, String password, String remoteFilePath, File file) { FileInputStream input = null; BufferedOutputStream boutput = null; Connection conn = null; try { conn = new Connection(ip); conn.connect(); boolean isAuthenticated = conn.authenticateWithPassword(username, password); if (isAuthenticated == false) { throw new IOException(\u0026#34;Authentication failed.\u0026#34;); } SCPClient scpClient = conn.createSCPClient(); boutput = scpClient.put(file.getName(), file.length(), remoteFilePath, \u0026#34;0600\u0026#34;); byte[] buffer = new byte[1024 * 8]; input = new FileInputStream(file); int length = -1; while ((length = input.read(buffer)) != -1) { boutput.write(buffer, 0, length); } boutput.flush(); } catch (IOException e) { e.printStackTrace(System.err); } finally { try { boutput.close(); input.close(); conn.close(); } catch (IOException e) { e.printStackTrace(System.err); } } return true; } /** * 从远程服务器上下载文件 * * @param ip ip地址 * @param username 用户名 * @param password 密码 * @param remoteFile 要下载的文件的完整路径 * @param localFileName 下载到本地的文件名 * @return */ public static boolean downloadFile(String ip, String username, String password, String remoteFile, String localFileName) { SCPInputStream binput = null; FileOutputStream output = null; BufferedOutputStream boutput = null; Connection conn = null; try { File file = new File(localFileName); conn = new Connection(ip); conn.connect(); boolean isAuthenticated = conn.authenticateWithPassword(username, password); if (isAuthenticated == false) { throw new IOException(\u0026#34;Authentication failed.\u0026#34;); } SCPClient scpClient = conn.createSCPClient(); binput = scpClient.get(remoteFile); output = new FileOutputStream(file); boutput = new BufferedOutputStream(output); byte[] buffer = new byte[1024 * 8]; int length = -1; while ((length = binput.read(buffer)) != -1) { boutput.write(buffer, 0, length); } } catch (IOException e) { e.printStackTrace(System.err); } finally { try { binput.close(); boutput.close(); output.close(); conn.close(); } catch (IOException e) { e.printStackTrace(System.err); } } return true; } /** * 获取远程文件的输入流 * * @param ip ip * @param username 用户名 * @param password 密码 * @param remoteFile 远程文件的完整地址 * @return 输入流 */ public static SCPInputStream getRemoteFileInputStream(String ip, String username, String password, String remoteFile) { SCPInputStream binput = null; Connection conn = null; try { conn = new Connection(ip); conn.connect(); boolean isAuthenticated = conn.authenticateWithPassword(username, password); if (isAuthenticated == false) { throw new IOException(\u0026#34;Authentication failed.\u0026#34;); } SCPClient scpClient = conn.createSCPClient(); binput = scpClient.get(remoteFile); } catch (IOException e) { e.printStackTrace(System.err); } return binput; } /** * 执行远程服务器的控制台命令 * * @param ip ip地址 * @param username 用户名 * @param password 密码 * @param cmd 控制台命令 */ public static void executeCmd(String ip, String username, String password, String cmd) { Connection conn = null; try { conn = new Connection(ip); conn.connect(); boolean isAuthenticated = conn.authenticateWithPassword(username, password); if (isAuthenticated == false) { throw new IOException(\u0026#34;Authentication failed.\u0026#34;); } Session sess = conn.openSession(); sess.execCommand(cmd + \u0026#34;\\n\u0026#34;); InputStream stdout = new StreamGobbler(sess.getStdout()); BufferedReader br = new BufferedReader( new InputStreamReader(stdout)); while (true) { String line = br.readLine(); if (line == null) { break; } System.out.println(line); } } catch (IOException e) { e.printStackTrace(System.err); } finally { conn.close(); } } } 值得一提的是，uploadFile()方法的最后一个参数传入的是指向本地文件的一个File，也就是要上传的文件，而在downloadFile()方法中，最后一个参数是字符串，就是将目标文件下载下来之后，要叫什么名字，记得带上后缀。\n执行命令的话，执行一次就新开一次session。一个session（好像貌似）不能做两件事（如上传文件的过程中创建一个新文件夹，再以新文件夹的目录为目标上传目录）。\n","permalink":"https://windypath.com/posts/java_implement_winscp_like/","summary":"pom.xml添加的依赖：\n\u0026lt;!-- https://mvnrepository.com/artifact/ch.ethz.ganymed/ganymed-ssh2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.ethz.ganymed\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ganymed-ssh2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;262\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这里注意，不同版本的这玩意用法有差别。这里我使用的是262。\n操作类代码如下：\nimport ch.ethz.ssh2.*; import java.io.*; /** * @Author: 风萧古道的博客 windypath.com * @Date: 2019/11/29 15:14 */ public class SSHUtil { // uploadFile to Linux /** * 上传文件到Linux * * @param ip ip地址 * @param username 登录用户名 * @param password 密码 * @param remoteFilePath 目标文件所在完整目录 * @param file 本地文件File对象 * @return */ public static boolean uploadFile(String ip, String username, String password, String remoteFilePath, File file) { FileInputStream input = null; BufferedOutputStream boutput = null; Connection conn = null; try { conn = new Connection(ip); conn.","title":"Java实现类似WINSCP访问远程Linux服务器，执行命令、上传文件、下载文件"},{"content":"这是一个python项目。\n使用到的技术包括爬虫和发邮件\n代码如下：\n#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2020/2/5 22:49 # @Author : Johnathan Lin import time import requests import random import json import re from bs4 import BeautifulSoup import smtplib from email.mime.text import MIMEText from email.header import Header from urllib.parse import urljoin from bs4.element import NavigableString # 第三方 SMTP 服务 mail_host = \u0026#34;smtp.163.com\u0026#34; # 设置服务器 mail_user = \u0026#34;你的邮箱\u0026#34; # 用户名 mail_pass = \u0026#34;你的密码\u0026#34; # 口令 # 发送人和接收人 sender = \u0026#39;你的邮箱\u0026#39; # 自己发给自己就可以了， receivers = [\u0026#39;你的邮箱\u0026#39;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 爬虫请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\u0026#39; } def send_mail(date, msg): \u0026#34;\u0026#34;\u0026#34; 发送邮件 :param date: 日期 :param msg: XX内容 :return: \u0026#34;\u0026#34;\u0026#34; mail_msg = msg message = MIMEText(mail_msg, \u0026#39;html\u0026#39;, \u0026#39;utf-8\u0026#39;) message[\u0026#39;From\u0026#39;] = Header(\u0026#34;我的发件邮箱\u0026#34;, \u0026#39;utf-8\u0026#39;) message[\u0026#39;To\u0026#39;] = Header(\u0026#34;我的收件邮箱\u0026#34;, \u0026#39;utf-8\u0026#39;) subject = date + \u0026#39; \u0026#39; + \u0026#39;XXXXXXX情况\u0026#39; message[\u0026#39;Subject\u0026#39;] = Header(subject, \u0026#39;utf-8\u0026#39;) try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user, mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print(\u0026#34;邮件发送成功\u0026#34;) except smtplib.SMTPException as e: print(\u0026#34;Error: 无法发送邮件\u0026#34;) print(repr(e)) def regular_res(res): \u0026#34;\u0026#34;\u0026#34; 把不规则json转为规则json :param res: 请求得到的字符串 :return: 合法的json字符串 \u0026#34;\u0026#34;\u0026#34; res = re.sub(r\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;, res) res = re.sub(r\u0026#39;\\t\u0026#39;, \u0026#39;\u0026#39;, res) res = re.sub(r\u0026#39;chnldesc\u0026#39;, \u0026#39;\\\u0026#34;chnldesc\\\u0026#34;\u0026#39;, res) res = re.sub(r\u0026#39;recordCount\u0026#39;, \u0026#39;\\\u0026#34;recordCount\\\u0026#34;\u0026#39;, res) res = re.sub(r\u0026#39;docs\u0026#39;, \u0026#39;\\\u0026#34;docs\\\u0026#34;\u0026#39;, res) res = re.sub(r\u0026#39;docid\u0026#39;, \u0026#39;\\\u0026#34;docid\\\u0026#34;\u0026#39;, res) res = re.sub(r\u0026#39;title\u0026#39;, \u0026#39;\\\u0026#34;title\\\u0026#34;\u0026#39;, res) res = re.sub(r\u0026#39;url\u0026#39;, \u0026#39;\\\u0026#34;url\\\u0026#34;\u0026#39;, res) res = re.sub(r\u0026#39;time \u0026#39;, \u0026#39;\\\u0026#34;time\\\u0026#34;\u0026#39;, res) return res def crawl_data(date): \u0026#34;\u0026#34;\u0026#34; 爬取文档 :param date: 日期，用于测量是否是当天的 :return: 目标页面的url \u0026#34;\u0026#34;\u0026#34; url = \u0026#39;http://xxxxxxxxxx?r=\u0026#39; + str(random.random()) response = requests.get(url, headers=headers) res = str(response.content, encoding=\u0026#39;utf-8\u0026#39;) response.close() res = regular_res(res) json_obj = json.loads(res) for doc in json_obj[\u0026#39;docs\u0026#39;]: if doc[\u0026#39;title\u0026#39;] == \u0026#39;XXXXXXXX情情况\u0026#39; and doc[\u0026#39;time\u0026#39;] == date: return doc[\u0026#39;url\u0026#39;] return \u0026#39;\u0026#39; def timestamp_to_date(timestamp): \u0026#34;\u0026#34;\u0026#34; 时间戳转时间年-月-日 :param timestamp: 时间戳 :return: 时间字符串 \u0026#34;\u0026#34;\u0026#34; return time.strftime(time.strftime(\u0026#34;%Y-%m-%d\u0026#34;, time.localtime(timestamp))) def crawl_content(res_url): response = requests.get(res_url, headers=headers) html = str(response.content, encoding=\u0026#39;utf-8\u0026#39;) response.close() html_content = BeautifulSoup(html, \u0026#39;lxml\u0026#39;) news_content = \u0026#39;\u0026#39; news_block = html_content.select(\u0026#39;div.TRS_Editor\u0026#39;)[0] [s.extract() for s in html_content.select(\u0026#39;style\u0026#39;)] [s.extract() for s in html_content.select(\u0026#39;script\u0026#39;)] for block in news_block.contents: if not isinstance(block, NavigableString): del block[\u0026#39;style\u0026#39;] del block[\u0026#39;class\u0026#39;] del block[\u0026#39;align\u0026#39;] # print(block.name) if block.name == \u0026#39;a\u0026#39;: block[\u0026#39;href\u0026#39;] = urljoin(res_url, block[\u0026#39;href\u0026#39;]) if block.name == \u0026#39;h2\u0026#39; or block.get_text().strip() == \u0026#39;\u0026#39;: continue news_content += str(block).replace(\u0026#39;\\r\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;\\t\u0026#39;, \u0026#39;\u0026#39;).strip() return news_content if __name__ == \u0026#39;__main__\u0026#39;: # # 2.6的时间戳 timestamp = 1580918400 while (True): # 每隔60秒爬一次 time.sleep(60) # 获取下次需要的日期 date = timestamp_to_date(timestamp) # 请求得到目标url res_url = crawl_data(date) if res_url == \u0026#39;\u0026#39;: continue # 找到相应的请求，爬取内容 news_content = crawl_content(res_url) # 发送邮件 send_mail(date, news_content) # 爬取下一天的内容 timestamp += 86400 # 2.9之后停止 if timestamp == 1581264000: break 使用网易邮箱app，可以第一时间接到自己发的邮件。\n这里测试过QQ邮箱，把我的邮件判定为垃圾邮件，直接被退回了。\n测试结果： （我做完然后发现爬不动的时候，感觉到了自己在吃人血馒头，故将人名隐去）\n在本地测试通过后，放到服务器上，使用\nnohup python3 main.py \u0026amp; 放在后台执行，本以为万事大吉，结果才爬了一小会人报了错。\nConnectionResetError: [Errno 104] Connection reset by peer 服务器把我的连接请求关闭了。\n网上查找资料的结果是，爬取过频，对面关闭服务器我还继续请求。\n但我一分钟请求一次，也不算特别快了。\n我当然可以写个方法，在读取异常之后继续爬，如：\ndef request_while_response(url, type, headers, data, open_proxy, sleep_time): \u0026#34;\u0026#34;\u0026#34; 发送请求,规避10054错误，直至请求成功 :param url: 请求路径 :param type: 请求类型（get或post） :param headers: 请求头 :param data: 请求参数对象 :param open_proxy: 是否使用代理 :return: 请求得到的文本 \u0026#34;\u0026#34;\u0026#34; r = \u0026#39;\u0026#39; while True: # 循环 try: # request()是发送请求的方法，我将requests包封装成了 r = request(url, type, headers, data, open_proxy) except (requests.exceptions.SSLError, requests.exceptions.ConnectionError, requests.exceptions.ReadTimeout) as e: if \u0026#39;bad handshake\u0026#39; in str(e) or \u0026#39;10054\u0026#39; in str(e) or \u0026#39;Read timed out\u0026#39; in str(e): # 上述2种异常 time.sleep(sleep_time) continue # 继续发请求 else: raise Exception(e) # 其他异常，抛出来 break # 无异常就跳出循环 return r # 返回响应结果 但总归是做贼心虚，还是罢了。\n","permalink":"https://windypath.com/posts/a_bad_project_crawler_and_email/","summary":"这是一个python项目。\n使用到的技术包括爬虫和发邮件\n代码如下：\n#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2020/2/5 22:49 # @Author : Johnathan Lin import time import requests import random import json import re from bs4 import BeautifulSoup import smtplib from email.mime.text import MIMEText from email.header import Header from urllib.parse import urljoin from bs4.element import NavigableString # 第三方 SMTP 服务 mail_host = \u0026#34;smtp.163.com\u0026#34; # 设置服务器 mail_user = \u0026#34;你的邮箱\u0026#34; # 用户名 mail_pass = \u0026#34;你的密码\u0026#34; # 口令 # 发送人和接收人 sender = \u0026#39;你的邮箱\u0026#39; # 自己发给自己就可以了， receivers = [\u0026#39;你的邮箱\u0026#39;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 爬虫请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.","title":"一个被废弃的项目——自动爬取信息然后发给我自己邮箱上"},{"content":"Python连接MongoDB 安装 首先要安装pymongo，用pip装一下就好了。\n工具类python文件 以下直接给出我写的mongodb操作类\n#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2019/12/23 14:02 # @Author : Johnathan Lin 林佳庆 \u0026#34;\u0026#34;\u0026#34; 数据导入Mongo模块 \u0026#34;\u0026#34;\u0026#34; import os import pymongo from utils.configReader import read_mongo_config # 设置编码 os.environ[\u0026#39;NLS_LANG\u0026#39;] = \u0026#39;SIMPLIFIED CHINESE_CHINA.UTF8\u0026#39; def get_mongodb_collection(collection): \u0026#34;\u0026#34;\u0026#34; 根据配置文件和数据库和表得到表（collection） :param database: 数据库 :param collection: 表 :return: 表的对象 \u0026#34;\u0026#34;\u0026#34; mongo_config = read_mongo_config() client = pymongo.MongoClient(mongo_config[\u0026#39;client\u0026#39;]) db = client[mongo_config[\u0026#39;database\u0026#39;]] if mongo_config[\u0026#39;auth\u0026#39;] == \u0026#39;True\u0026#39; or mongo_config[\u0026#39;auth\u0026#39;] == \u0026#39;true\u0026#39;: db.authenticate(mongo_config[\u0026#39;username\u0026#39;], mongo_config[\u0026#39;password\u0026#39;]) col = db[collection] return col def insert_data(collection, document): \u0026#34;\u0026#34;\u0026#34; 将数据插入MongoDB中 :param collection:数据将插入的集合名 :param doc:数据文档 :return:无 \u0026#34;\u0026#34;\u0026#34; col = get_mongodb_collection(collection) col.insert_one(document) def insert_data_list(collection, document_list): \u0026#34;\u0026#34;\u0026#34; 批量插入数据到MongoDB :param collection: 数据将插入的集合名 :param document_list: 数据文档列表 :return: \u0026#34;\u0026#34;\u0026#34; col = get_mongodb_collection(collection) col.insert_many(document_list) def get_children_classify_id(parent_id): \u0026#34;\u0026#34;\u0026#34; 获取所有子孙节点 :param parent_id: 父节点ID :return: 所有子孙节点 \u0026#34;\u0026#34;\u0026#34; col = get_mongodb_collection(\u0026#39;crawler_classify\u0026#39;) res = col.aggregate([ {\u0026#39;$match\u0026#39;: {\u0026#39;classify_id\u0026#39;: parent_id}}, {\u0026#39;$graphLookup\u0026#39;: {\u0026#39;from\u0026#39;: \u0026#39;crawler_classify\u0026#39;, \u0026#39;startWith\u0026#39;: \u0026#39;$classify_id\u0026#39;, \u0026#39;connectFromField\u0026#39;: \u0026#39;classify_id\u0026#39;, \u0026#39;connectToField\u0026#39;: \u0026#39;parent_id\u0026#39;, \u0026#39;as\u0026#39;: \u0026#39;son\u0026#39;}} ]) res_list = [] for doc in res: res_list.append(doc) if len(res_list) == 0 or len(res_list[0][\u0026#39;son\u0026#39;]) == 0: return [] else: return [classify[\u0026#39;classify_id\u0026#39;] for classify in res_list[0][\u0026#39;son\u0026#39;]] def get_document_by_condition(collection, key, value): \u0026#34;\u0026#34;\u0026#34; 根据集合和单一条件查找匹配的文档 :param collection: 集合名 :param key: 键 :param value: 值 :return: 匹配的文档列表 \u0026#34;\u0026#34;\u0026#34; col = get_mongodb_collection(collection) res = col.find({key: value}) res_list = [] for doc in res: res_list.append(doc) return res_list def update_document(collection, condition_key, condition_value, updated_key, new_value): \u0026#34;\u0026#34;\u0026#34; 更新文档 :param collection: :param condition_key: :param condition_value: :param updated_key: :param new_value: :return: \u0026#34;\u0026#34;\u0026#34; col = get_mongodb_collection(collection) col.update({condition_key: condition_value}, {\u0026#39;$set\u0026#39;: {updated_key: new_value}}) def get_document_by_condition_list(collection, condition_list): \u0026#34;\u0026#34;\u0026#34; 多条件同时成立查询匹配的文档 :param collection: 集合名 :param condition_list: 条件列表（列表中的元素为{key:value}形式） :return: 匹配的文档 \u0026#34;\u0026#34;\u0026#34; col = get_mongodb_collection(collection) res = col.find({\u0026#39;$and\u0026#39;: condition_list}) res_list = [] for doc in res: res_list.append(doc) return res_list def remove_document(collection, condition_list): \u0026#34;\u0026#34;\u0026#34; 删除文档 :param collection: 删除文档的集合 :param condition_list: :return: \u0026#34;\u0026#34;\u0026#34; col = get_mongodb_collection(collection) col.remove({\u0026#39;$and\u0026#39;: condition_list}) def update_document_condition_list_and_new_value_obj(collection, condition_list, new_value_obj): \u0026#34;\u0026#34;\u0026#34; 更新update文档，通过多个用“\u0026amp;”连接的条件和新对象更新 :param collection: 集合 :param condition_list: 与条件的列表 :param new_value_obj: 要更新的新值对象 :return: \u0026#34;\u0026#34;\u0026#34; col = get_mongodb_collection(collection) col.update({\u0026#39;$and\u0026#39;: condition_list}, {\u0026#39;$set\u0026#39;: new_value_obj}) 配置文件 配置文件长这样：\n[CONFIG] client=mongodb://localhost:27017/ auth=False username=xxx password=xxx database=yyy 获取集合 我们以 get_mongodb_collection(collection)函数为例：\ndef get_mongodb_collection(collection): \u0026#34;\u0026#34;\u0026#34; 根据配置文件和数据库和表得到表（collection） :param database: 数据库 :param collection: 表 :return: 表的对象 \u0026#34;\u0026#34;\u0026#34; mongo_config = read_mongo_config() client = pymongo.MongoClient(mongo_config[\u0026#39;client\u0026#39;]) db = client[mongo_config[\u0026#39;database\u0026#39;]] if mongo_config[\u0026#39;auth\u0026#39;] == \u0026#39;True\u0026#39; or mongo_config[\u0026#39;auth\u0026#39;] == \u0026#39;true\u0026#39;: db.authenticate(mongo_config[\u0026#39;username\u0026#39;], mongo_config[\u0026#39;password\u0026#39;]) col = db[collection] return col 在使用Mongo的时候，我们需要先获取其Mongo服务器地址，也就是上文配置文件的client字段内的内容，通过pymongo.MongoClient()方法获取其服务器对象\n然后，使用client[‘数据库名’]选择一个数据库，但选中的数据库可能需要验证用户名密码，所以如果需要验证，则使用db.authenticate(用户名，密码)验证；\n最后，用db[‘集合名’]取出对应的集合即可使用了。\n使用 可以发现，在python里使用mongo，用法和直接敲mongoDB脚本差不多，但是也存在一些不同，比如说‘$and’必须是字符串。\nPython连接Oracle pip装 cx-Oracle（这里注意，会有很多双胞胎几胞胎兄弟，认准这个带横杠的，后面O大写的）。\n这是我之前写的python调用oracle。\nimport cx_Oracle from utils.dataOperator import insert_data def start(): conn = cx_Oracle.connect(\u0026#39;oracle用户名/oracle密码@IP地址:端口号/oracle用户\u0026#39;) parent_id = \u0026#39;6c9da9e2b17b4e1da967f2fdfa05d89a\u0026#39; sql = \u0026#39;select * from 一个表的名字 start with CLASSIFY_ID = \\\u0026#39;\u0026#39; + parent_id + \u0026#39;\\\u0026#39;connect by prior classify_id = parent_id order by seq\u0026#39; cur = conn.cursor() cur.execute(sql) result_list = cur.fetchall() for result in result_list: res_obj = {} res_obj[\u0026#39;classify_id\u0026#39;] = str(result[0]) # 一顿操作。。。。 # 在此不表 insert_data(\u0026#39;数据库名\u0026#39;, \u0026#39;集合名\u0026#39;, res_obj) 使用cx_Oracle.connect（注意这里cx_Oracle是下划线了）调用方法，参数是oracle连接字符串\n之后创建一个游标cursor，用它执行sql语句，然后用fetchAll()函数把结果拿回来就可以用了。\n但具体怎么用呢？\n假如CLASSIFY_ID是执行这行sql返回结果中第一列的列名，那么result[0]就是该行数据在该列的值。\n所以需要多加注意。\n","permalink":"https://windypath.com/posts/python_connect_mongodb_and_oracle/","summary":"Python连接MongoDB 安装 首先要安装pymongo，用pip装一下就好了。\n工具类python文件 以下直接给出我写的mongodb操作类\n#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2019/12/23 14:02 # @Author : Johnathan Lin 林佳庆 \u0026#34;\u0026#34;\u0026#34; 数据导入Mongo模块 \u0026#34;\u0026#34;\u0026#34; import os import pymongo from utils.configReader import read_mongo_config # 设置编码 os.environ[\u0026#39;NLS_LANG\u0026#39;] = \u0026#39;SIMPLIFIED CHINESE_CHINA.UTF8\u0026#39; def get_mongodb_collection(collection): \u0026#34;\u0026#34;\u0026#34; 根据配置文件和数据库和表得到表（collection） :param database: 数据库 :param collection: 表 :return: 表的对象 \u0026#34;\u0026#34;\u0026#34; mongo_config = read_mongo_config() client = pymongo.MongoClient(mongo_config[\u0026#39;client\u0026#39;]) db = client[mongo_config[\u0026#39;database\u0026#39;]] if mongo_config[\u0026#39;auth\u0026#39;] == \u0026#39;True\u0026#39; or mongo_config[\u0026#39;auth\u0026#39;] == \u0026#39;true\u0026#39;: db.","title":"Python连接MongoDB和Oracle实战"},{"content":"写在前面的话 前后端分离的项目中，需要分别部署前端与后端项目。前端项目使用npm打包，将得到的dist文件夹下的内容上传到服务器后，用nginx的alias指向文件夹即可访问，而后端项目使用maven打包，需使用tomcat在后台启动，再通过nginx转发，供前端项目调用。\n打包 前端的打包 前端项目使用的是vue-element-admin的基础版本：vue-admin-template\n根据教程从github上下载后，在webstorm中运行成功。\n原项目中只有前端，但可以完成简单的数据交互，根据使用手册介绍，该项目使用了mockjs模拟数据。\n而我们需要做前后端交互，故不使用mockjs。\n修改为访问后端的路径 方法很简单，在根目录下的.env.development文件下，将VUE_APP_BASE_API改为你的本地后端地址。 .env.development VUE_APP_BASE_API = \u0026#39;http://localhost:8080\u0026#39; 在根目录下的.env.production文件下，将VUE_APP_BASE_API改为你的云服务器的后端地址。\n.env.production # just a flag ENV = \u0026#39;production\u0026#39; # base api VUE_APP_BASE_API = \u0026#39;http://？？？？？？？/springbootdemo\u0026#39; 这里可能会有一些小bug，主要是要与服务器的路径对应起来。\n根据该项目package.json内所设置的，使用npm run build:prod打包，生成dist文件夹 最后得到dist文件夹。 后端的打包 编写接口 首先，编写Controller，写一些接口。\npackage com.windypath.demo.controller; import com.windypath.demo.response.ResponseData; import com.windypath.demo.response.ResponseDataUtil; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RequestMapping(\u0026#34;/\u0026#34;) @RestController public class MainController { @RequestMapping(\u0026#34;/hello\u0026#34;) public ResponseData hello() { return ResponseDataUtil.buildSuccess(\u0026#34;hello!\u0026#34;); } @RequestMapping(\u0026#34;/\u0026#34;) public ResponseData root() { return ResponseDataUtil.buildSuccess(\u0026#34;root!\u0026#34;); } } 此处使用的ResponseData来自于https://blog.csdn.net/weixin_33863087/article/details/89540234 处理跨域 新增一个config包装入跨域的配置类，来自于https://www.cnblogs.com/tonggc1668/p/11215932.html\n打成war包 注意，原始的springboot项目默认将项目打成jar包，需要设置。\n这里我备份一下我的pom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;groupId\u0026gt;com.windypath\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--去除内嵌tomcat--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.10\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-websocket --\u0026gt; \u0026lt;!--websocket依赖包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.embed\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-embed-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.23\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--servlet依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!--生成war包的名称--\u0026gt; \u0026lt;finalName\u0026gt;springbootdemo\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-war-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;failOnMissingWebXml\u0026gt;false\u0026lt;/failOnMissingWebXml\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt;\u0026lt;!--这里版本需和服务器版本保持一致--\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 需要注意的点是，第11行设置导出的格式为war，然后要去除内嵌的tomcat，还要引入一个servlet的依赖。最后在标签内还要指定maven-war-plugin和maven-compiler-plugin两个插件。\n同时，启动类也需要更改。\npackage com.windypath.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; @SpringBootApplication public class Application extends SpringBootServletInitializer { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application){ return application.sources(Application.class); } } 需要继承一个SpringBootServletInitializer 才能使用。\n最后点击右边maven的package，在目录下的target找到.war的文件，打包就算完成了。\nLinux服务器配置 tomcat依赖java，所以需要先装java。\ntomcat配置 然后再装tomcat，这里建议使用源代码安装（其实解压就可以用了）\n配置tomcat的conf/server.xml。\n由于本次我们的后端只负责接收请求，故不需要配置标签，只需要修改监听的端口号就行了。\n\u0026lt;Connector port=\u0026#34;10081\u0026#34; protocol=\u0026#34;org.apache.coyote.http11.Http11NioProtocol\u0026#34; connectionTimeout=\u0026#34;60000\u0026#34; maxConnections=\u0026#34;10000\u0026#34; maxThreads=\u0026#34;2000\u0026#34; acceptCount=\u0026#34;2000\u0026#34; maxPostSize=\u0026#34;20971520\u0026#34; redirectPort=\u0026#34;8443\u0026#34; executor=\u0026#34;tomcatThreadPool\u0026#34; URIEncoding=\u0026#34;UTF-8\u0026#34; /\u0026gt; 后端部署 将刚才springboot打的war包放入webapps文件夹下，然后进入bin，启动。\n输入./startup.sh 启动\n关闭的话，./shutdown.sh会报错，看不太懂，但是我们可以用ps -ef |grep tomcat查看正在运行的tomcat，然后用kill -9 进程号 将其关闭\nNginx配置 这里依旧建议源代码安装（注意安装过程中可能会提示缺了什么插件，去查找然后装好就行了）\n安装方法：\nhttps://segmentfault.com/a/1190000007116797#articleHeader8\n然后，建一个文件夹专门放前端项目。\n将dist文件夹整个上传到服务器中，改个名。\n配置Nginx\n#user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; upstream springbootdemo { server ？？？？:10081; } server { listen 20081; #端口 server_name springbootdemo_20081; client_max_body_size 20m; client_body_buffer_size 128k; #配置前端地址文件 location /springbootdemo_fe { alias /usr/local/webserver/apps/springbootdemo_fe; } #配置后台地址文件 location /springbootdemo { proxy_pass http://springbootdemo; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Cookie $http_cookie; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_read_timeout 3600s; } } } 我们刚才在后端配置的时候写的端口号是10081，故在upstream内也写这个端口号。\n而用户真正访问的端口是20081。\nalias指向前端的文件夹，需是完整路径。\n后端则用proxy_pass指向tomcat监听的端口。\nnginx的启动：进入/sbin下，\n启动 ./nginx\n停止 ./nginx -s stop\n启动顺序 先启动tomcat，再启动nginx即可。\n结果 ","permalink":"https://windypath.com/posts/vue_springboot_deploy_in_linux/","summary":"写在前面的话 前后端分离的项目中，需要分别部署前端与后端项目。前端项目使用npm打包，将得到的dist文件夹下的内容上传到服务器后，用nginx的alias指向文件夹即可访问，而后端项目使用maven打包，需使用tomcat在后台启动，再通过nginx转发，供前端项目调用。\n打包 前端的打包 前端项目使用的是vue-element-admin的基础版本：vue-admin-template\n根据教程从github上下载后，在webstorm中运行成功。\n原项目中只有前端，但可以完成简单的数据交互，根据使用手册介绍，该项目使用了mockjs模拟数据。\n而我们需要做前后端交互，故不使用mockjs。\n修改为访问后端的路径 方法很简单，在根目录下的.env.development文件下，将VUE_APP_BASE_API改为你的本地后端地址。 .env.development VUE_APP_BASE_API = \u0026#39;http://localhost:8080\u0026#39; 在根目录下的.env.production文件下，将VUE_APP_BASE_API改为你的云服务器的后端地址。\n.env.production # just a flag ENV = \u0026#39;production\u0026#39; # base api VUE_APP_BASE_API = \u0026#39;http://？？？？？？？/springbootdemo\u0026#39; 这里可能会有一些小bug，主要是要与服务器的路径对应起来。\n根据该项目package.json内所设置的，使用npm run build:prod打包，生成dist文件夹 最后得到dist文件夹。 后端的打包 编写接口 首先，编写Controller，写一些接口。\npackage com.windypath.demo.controller; import com.windypath.demo.response.ResponseData; import com.windypath.demo.response.ResponseDataUtil; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RequestMapping(\u0026#34;/\u0026#34;) @RestController public class MainController { @RequestMapping(\u0026#34;/hello\u0026#34;) public ResponseData hello() { return ResponseDataUtil.buildSuccess(\u0026#34;hello!\u0026#34;); } @RequestMapping(\u0026#34;/\u0026#34;) public ResponseData root() { return ResponseDataUtil.buildSuccess(\u0026#34;root!\u0026#34;); } } 此处使用的ResponseData来自于https://blog.","title":"vue和springboot项目部署到Linux服务器"},{"content":"strip()、lstrip()、和rstrip() Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。\n注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。\nlstrip()就是从左边匹配然后删除字符，rstrip()从右边匹配然后删除字符。\n表面上挺好理解的，但是用起来还是有一些陷阱。\n如：\nif __name__ == \u0026#39;__main__\u0026#39;: string = \u0026#39;abcdefghijkl\u0026#39; print(string.lstrip(\u0026#39;bac\u0026#39;)) # 输出 defghijkl 可以看到，虽然左侧开头的\u0026rsquo;abc\u0026rsquo;和\u0026rsquo;bac‘顺序不同，但lstrip()方法依旧将其匹配然后删除了。\n所以如果我只是要删除开头的某一部分，比如获取标签内的字符：\nif __name__ == \u0026#39;__main__\u0026#39;: string = \u0026#39;\u0026lt;a href=\u0026#34;http://www.windypath.com\u0026#34;\u0026gt;abcde\u0026lt;/a\u0026gt;\u0026#39; print(string.lstrip(\u0026#39;\u0026lt;a href=\u0026#34;http://www.windypath.com\u0026#34;\u0026gt;\u0026#39;).rstrip(\u0026#39;\u0026lt;/a\u0026gt;\u0026#39;)) # 输出 bcde 就会把标签内容的最左边的a给匹配到了。\n那么如何实现只根据字符顺序，匹配前面的字符呢？\n用正则表达式：re.sub()\nPython 的 re 模块提供了re.sub用于替换字符串中的匹配项。\n语法：\nre.sub(pattern, repl, string, count=0, flags=0) 参数：\npattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 使用该方法：\nimport re if __name__ == \u0026#39;__main__\u0026#39;: string = \u0026#39;\u0026lt;a href=\u0026#34;http://www.windypath.com\u0026#34;\u0026gt;abcde\u0026lt;/a\u0026gt;\u0026#39; clear_pre = re.sub(r\u0026#39;\u0026lt;a href=\u0026#34;http://www.windypath.com\u0026#34;\u0026gt;\u0026#39;, \u0026#39;\u0026#39;, string) clear_post = re.sub(r\u0026#39;\u0026lt;/a\u0026gt;\u0026#39;, \u0026#39;\u0026#39;, clear_pre) print(clear_post) # 输出 abcde js的indexOf()对应python的index() 对于数组而言：\njs的indexOf()返回元素在数组中的下标：\nvar fruit = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;pear\u0026#39;] console.log(fruit.indexOf(\u0026#39;banana\u0026#39;)) // 输出 1 python里也有一个名字很像的index\nif __name__ == \u0026#39;__main__\u0026#39;: fruit = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;pear\u0026#39;] print(fruit.index(\u0026#39;banana\u0026#39;)) # 输出 1 但对于字符串：\n对于js而言，依旧可以使用indexOf()函数。\n找得到的情况：\nvar string = \u0026#39;I love apple and banana\u0026#39; console.log(string.indexOf(\u0026#39;apple\u0026#39;)) // 输出 7 找不到的情况：\nvar string = \u0026#39;I love apple and banana\u0026#39; console.log(string.indexOf(\u0026#39;orange\u0026#39;)) // 输出 -1 找不到时，输出-1。\n而python的index在字符串中找不到时，将抛出异常。\nif __name__ == \u0026#39;__main__\u0026#39;: string = \u0026#39;I love apple and banana\u0026#39; print(string.index(\u0026#39;orange\u0026#39;)) # Traceback (most recent call last): # File \u0026#34;/****.py\u0026#34;, line 12, in \u0026lt;module\u0026gt; # print(string.index(\u0026#39;orange\u0026#39;)) # ValueError: substring not found index()方法在找不到时，并不返回-1。\n但find()函数在找不到时可以返回-1.\nif __name__ == \u0026#39;__main__\u0026#39;: string = \u0026#39;I love apple and banana\u0026#39; print(string.find(\u0026#39;orange\u0026#39;)) # 输出 -1 print(string.find(\u0026#39;apple\u0026#39;)) # 输出 7 python连接Oracle和MongoDB 这个。。待写，下篇文章再见。\n2020.2.9已更新：点击这里\n文件读取f.truncate() 关于文件的w,a,r和它们的+，在网上资料很多，这里我只想备份一下：\nf.truncate()是将文件清空的函数。\n只有在w的模式下可以执行，在a下没有效果，r则抛出异常。\nif __name__ == \u0026#39;__main__\u0026#39;: file_name = \u0026#39;测试.txt\u0026#39; with open(file_name, \u0026#39;w\u0026#39;) as f: f.truncate() 对dict对象的.keys()取出所有键 这是个非常实用的方法。\nif __name__ == \u0026#39;__main__\u0026#39;: obj = { \u0026#39;website\u0026#39;: \u0026#39;www.windypath.com\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;风萧古道\u0026#39;, \u0026#39;favorite_team\u0026#39;: \u0026#39;Los Angeles Lakers\u0026#39; } print(obj.keys()) # dict_keys([\u0026#39;website\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;favorite_team\u0026#39;]) 使用range()和enumerate()对数组遍历 range()：传入某个整数，获取从0到该数-1的数组\nif __name__ == \u0026#39;__main__\u0026#39;: sum = 5 for i in range(sum): print(i) # 输出 # 0 # 1 # 2 # 3 # 4 enumerate()：传入某个list，获取每个元素的下标和自身\nif __name__ == \u0026#39;__main__\u0026#39;: fruit_list = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;pear\u0026#39;] for index, fruit in enumerate(fruit_list): print(index, fruit) # 输出 # 0 apple # 1 banana # 2 orange # 3 pear ","permalink":"https://windypath.com/posts/some_usages_of_python/","summary":"strip()、lstrip()、和rstrip() Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。\n注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。\nlstrip()就是从左边匹配然后删除字符，rstrip()从右边匹配然后删除字符。\n表面上挺好理解的，但是用起来还是有一些陷阱。\n如：\nif __name__ == \u0026#39;__main__\u0026#39;: string = \u0026#39;abcdefghijkl\u0026#39; print(string.lstrip(\u0026#39;bac\u0026#39;)) # 输出 defghijkl 可以看到，虽然左侧开头的\u0026rsquo;abc\u0026rsquo;和\u0026rsquo;bac‘顺序不同，但lstrip()方法依旧将其匹配然后删除了。\n所以如果我只是要删除开头的某一部分，比如获取标签内的字符：\nif __name__ == \u0026#39;__main__\u0026#39;: string = \u0026#39;\u0026lt;a href=\u0026#34;http://www.windypath.com\u0026#34;\u0026gt;abcde\u0026lt;/a\u0026gt;\u0026#39; print(string.lstrip(\u0026#39;\u0026lt;a href=\u0026#34;http://www.windypath.com\u0026#34;\u0026gt;\u0026#39;).rstrip(\u0026#39;\u0026lt;/a\u0026gt;\u0026#39;)) # 输出 bcde 就会把标签内容的最左边的a给匹配到了。\n那么如何实现只根据字符顺序，匹配前面的字符呢？\n用正则表达式：re.sub()\nPython 的 re 模块提供了re.sub用于替换字符串中的匹配项。\n语法：\nre.sub(pattern, repl, string, count=0, flags=0) 参数：\npattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 使用该方法：\nimport re if __name__ == \u0026#39;__main__\u0026#39;: string = \u0026#39;\u0026lt;a href=\u0026#34;http://www.","title":"Python的一些用法（可能不定时更新）"},{"content":" 参考文献 java正则表达式（find()和 matches()） java正则表达式，求匹配：双反斜杠（\\）合法，单反斜杠不合法（\\） Java 正则表达式-菜鸟教程 正则表达式-菜鸟教程\nPattern类和Matcher类 在Java中，与正则表达式相关的类有两个：Pattern和Matcher\n菜鸟教程已经介绍的很好了。\njava.util.regex 包主要包括以下三个类：\nPattern 类：pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类：Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxException：PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 然后菜鸟教程的第一个代码样例如下：\nimport java.util.regex.*; class RegexExample1{ public static void main(String args[]){ String content = \u0026#34;I am noob \u0026#34; + \u0026#34;from runoob.com.\u0026#34;; String pattern = \u0026#34;.*runoob.*\u0026#34;; boolean isMatch = Pattern.matches(pattern, content); System.out.println(\u0026#34;字符串中是否包含了 \u0026#39;runoob\u0026#39; 子字符串? \u0026#34; + isMatch); } } 但我尝试把他改成自己的正则表达式，如”^I am“来匹配开头的”I am\u0026quot;字符串时，我发现程序一直返回false。\n这是为什么呢？\n原因是，matches()函数是用于字符串全匹配的。若正则内的字符串与待匹配的字符串存在完全匹配，则返回false。\n具体的阳602说的更好一些。\nfind()和matches() 1.find()方法是部分匹配，是查找输入串中与模式匹配的子串，如果该匹配的串有组还可以使用group()函数。 matches()是全部匹配，是将整个输入串与模式匹配，如果要验证一个输入的数据是否为数字类型或其他类型，一般要用matches()。\nPattern pattern= Pattern.compile(\u0026#34;.*?,(.*)\u0026#34;); Matcher matcher = pattern.matcher(result); if (matcher.find()) { return matcher.group(1); } 3.详解： matches public static boolean matches(String regex, CharSequence input) 编译给定正则表达式并尝试将给定输入与其匹配。 调用此便捷方法的形式 Pattern.matches(regex, input); Pattern.compile(regex).matcher(input).matches() ; 如果要多次使用一种模式，编译一次后重用此模式比每次都调用此方法效率更高。 参数： regex - 要编译的表达式 input - 要匹配的字符序列 抛出： PatternSyntaxException - 如果表达式的语法无效\nfind public boolean find()尝试查找与该模式匹配的输入序列的下一个子序列。 此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。 如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。 matcher.start() 返回匹配到的子字符串在字符串中的索引位置. matcher.end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置. matcher.group()返回匹配到的子字符串 返回： 当且仅当输入序列的子序列匹配此匹配器的模式时才返回 true。\n4.部分JAVA正则表达式实例\n①字符匹配\nPattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(str); // 操作的字符串 boolean b = m.matches(); //返回是否匹配的结果 System.out.println(b); Pattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(str); // 操作的字符串 boolean b = m. lookingAt (); //返回是否匹配的结果 System.out.println(b); Pattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(str); // 操作的字符串 boolean b = m..find (); //返回是否匹配的结果 System.out.println(b); ②分割字符串\nPattern pattern = Pattern.compile(expression); //正则表达式 String[] strs = pattern.split(str); //操作字符串 得到返回的字符串数组 ③替换字符串\nPattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(text); // 操作的字符串 String s = m.replaceAll(str); //替换后的字符串 ④查找替换指定字符串\nPattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(text); // 操作的字符串 StringBuffer sb = new StringBuffer(); int i = 0; while (m.find()) { m.appendReplacement(sb, str); i++; //字符串出现次数 } m.appendTail(sb);//从截取点将后面的字符串接上 String s = sb.toString(); ⑤查找输出字符串\nPattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(text); // 操作的字符串 while (m.find()) { matcher.start() ; matcher.end(); matcher.group(1); } 有趣的双反斜杠（\\） 在Java字符串中，存在诸如\\n，\\r等转义字符，而反斜杠\\自己本身也是转义字符，所以在Java字符串中，要输出\\，需要写两个\\，即\\。\n而正则表达式也需要匹配转义字符，故正则表达式要匹配一个\\的时候，也需要写两个\\。\n所以，在Java中使用正则表达式，要匹配一个\\，需要写四个\\。\n正则表达式特殊字符（来自菜鸟教程） 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 \u0026lsquo;\\n\u0026rsquo; 或 \u0026lsquo;\\r\u0026rsquo;。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， \u0026rsquo;n\u0026rsquo; 匹配字符 \u0026rsquo;n\u0026rsquo;。\u0026rsquo;\\n\u0026rsquo; 匹配换行符。序列 \u0026lsquo;\\\u0026rsquo; 匹配 \u0026ldquo;\u0026quot;，而 \u0026lsquo;(\u0026rsquo; 则匹配 \u0026ldquo;(\u0026quot;。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 ","permalink":"https://windypath.com/posts/regular_expression/","summary":"参考文献 java正则表达式（find()和 matches()） java正则表达式，求匹配：双反斜杠（\\）合法，单反斜杠不合法（\\） Java 正则表达式-菜鸟教程 正则表达式-菜鸟教程\nPattern类和Matcher类 在Java中，与正则表达式相关的类有两个：Pattern和Matcher\n菜鸟教程已经介绍的很好了。\njava.util.regex 包主要包括以下三个类：\nPattern 类：pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类：Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxException：PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 然后菜鸟教程的第一个代码样例如下：\nimport java.util.regex.*; class RegexExample1{ public static void main(String args[]){ String content = \u0026#34;I am noob \u0026#34; + \u0026#34;from runoob.com.\u0026#34;; String pattern = \u0026#34;.*runoob.*\u0026#34;; boolean isMatch = Pattern.matches(pattern, content); System.out.println(\u0026#34;字符串中是否包含了 \u0026#39;runoob\u0026#39; 子字符串? \u0026#34; + isMatch); } } 但我尝试把他改成自己的正则表达式，如”^I am“来匹配开头的”I am\u0026quot;字符串时，我发现程序一直返回false。","title":"java正则表达式 - 双反斜杠（\\）和Pattern的matches()与find()"},{"content":"爬虫的目的是采集网站的数据。而网站渲染数据有两种方式。我个人将其称为前端渲染和后端渲染。\n前端渲染 前端渲染指的是网页并不直接展示数据，而是在读取完网页之后，再次向服务器请求数据。在得到数据之后再渲染到网页中。\n后端渲染 后端渲染指的是服务器收到请求之后，将数据在后端写入网页，然后将带有数据的网页直接展示在浏览器中。\n爬取方式 目前我并没有使用scrapy、webmagic等爬虫框架，仅使用python的requests模块，json模块和BeautifulSoup框架。\n前端渲染的爬取方式\n步骤：使用requests请求数据，再用json.loads()方法将返回的数据解析，最后操作得到的数据对象即可。\n我们这里以豆瓣为例。\n分析该网页。 爬取的url：\nhttps://movie.douban.com/explore#!type=movie\u0026amp;tag=%E7%83%AD%E9%97%A8\u0026amp;sort=recommend\u0026amp;page_limit=20\u0026amp;page_start=0\n将url放进浏览器，先点开F12，然后访问。这里我使用谷歌浏览器 可以看到，红框内的All、XHR、JS等。这是一个筛选框，用来筛选该网页请求的数据。\nAll代表所有，XHR代表异步请求，JS代表Js文件，Css……\n对于前端渲染，必然有异步的过程，所以选择XHR。\n通过观察，发现第三行是“选电影”列表的数据。 这时，我们点击Headers，查看其请求的详细信息。 可以看到，这是一个Get请求，在下面的Qurey String Parameters可以看到该请求的参数。\n数据对应的网页内容为： 测试这个请求。 浏览器可以发起这个请求得到相应，但我们的代码不一定能做到。有一部分原因是网站开发者本身不希望数据被爬取。所以我们需要测试这个接口。这里推荐Postman，先对接口进行测试，查看是否有些Headers或者参数是不需要的，以简化代码量。\nPostman的用法下回分解吧。\n编写代码。 #!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2019/11/15 22:11 # @Author : Johnathan Lin import requests import json if __name__ == \u0026#39;__main__\u0026#39;: # 请求头，一般写上User-Agent防止爬虫，遇到有验证状态的网站要填写Cookie headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\u0026#39; } # 请求Url url = \u0026#39;https://movie.douban.com/j/search_subjects?type=movie\u0026amp;tag=%E7%83%AD%E9%97%A8\u0026amp;sort=recommend\u0026amp;page_limit=20\u0026amp;page_start=0\u0026#39; # 发送请求 request = requests.get(url, headers=headers) json_data = str(request.content, encoding=\u0026#39;utf-8\u0026#39;) # 解析数据 json_data_obj = json.loads(json_data) for data in json_data_obj[\u0026#39;subjects\u0026#39;]: print(data[\u0026#39;title\u0026#39;]) 爬取结果： 这里建议养成写上User-Agent的习惯。\n对于Get请求，将数据装在url的“？”后面即可，但对于Post请求，一般建议写在data对象里。\n我们以网站http://ent.zdface.com/为例。\nF12看到一个异步请求： 注意这里同时有Query String Parameters和Form Data。Query String Parameters是装在url后的参数，而Form Data是POST请求传入的参数。\n查看其Preview，发现是某一板块下的数据。 找到网页对应部分内容： 开始爬取，注意这回参数要写进data对象里。\n#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2019/11/15 22:11 # @Author : Johnathan Lin import requests import json if __name__ == \u0026#39;__main__\u0026#39;: # 请求头，一般写上User-Agent防止爬虫，遇到有验证状态的网站要填写Cookie headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\u0026#39; } # 请求参数 data = { \u0026#39;last\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;amount\u0026#39;: \u0026#39;20\u0026#39; } # 请求Url url = \u0026#39;http://ent.zdface.com/e/ajax/data.php?classid=12\u0026#39; # 发送POST请求 request = requests.post(url, data=data, headers=headers) json_data = str(request.content, encoding=\u0026#39;utf-8\u0026#39;) # 解析数据 json_data_obj = json.loads(json_data) for data in json_data_obj: print(data[\u0026#39;title\u0026#39;]) 爬取结果： 后端渲染： 后端渲染网站的爬取过程依旧是发起请求-\u0026gt;解析。\n这里使用BeautifulSoup解析。\n这个框架本身并不难。不需要看什么教程，仔仔细细把官方的中文文档读一遍下来，就知道怎么用了。\n文档地址：https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/\n我选择我自己的网站作为后端渲染的网页爬取样例。\n我 爬 我 自 己\n这是之前用wordpress的时候写的文章，目前可能不适用了。\n目标url：www.windypath.com\nF12看一下。\n一般来说，后端渲染的网站，只要挑第一个看就可以了。而如果你点XHR，将什么都看不到。 这是一个Get请求。点击Response： 可以看到，每一篇文章都是用标签展示的，其中里面在下的标签装着标题内容，标签的href就是文章的url。\n也就是说，我们要获取文章列表url，可以通过标签找到标题的标签。\nBeautifuSoup功能虽强大，但它提供的一些find()，findAll()并不实用，直接实用select()方法，参数为CSS选择器的字符串，像操控CSS选择元素一样找到元素，是比较灵活方便有效的方式。\n注：BeautifulSoup支持许多解析器，用来解析html文档，这里我只用过lxml，记得装bs4的时候也要装lxml。\n于是我们写成以下代码：\n#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2019/11/15 22:11 # @Author : Johnathan Lin import requests import json from bs4 import BeautifulSoup if __name__ == \u0026#39;__main__\u0026#39;: # 请求头，一般写上User-Agent防止爬虫，遇到有验证状态的网站要填写Cookie headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\u0026#39; } # 请求Url url = \u0026#39;http://www.windypath.com/\u0026#39; # 发送请求 request = requests.get(url, headers=headers) html = str(request.content, encoding=\u0026#39;utf-8\u0026#39;) # 解析数据 html_content = BeautifulSoup(html, \u0026#39;lxml\u0026#39;) for article in html_content.select(\u0026#39;article\u0026#39;): a_tag = article.select(\u0026#39;header \u0026gt; h1 \u0026gt; a\u0026#39;)[0] print(\u0026#39;文章标题：\u0026#39; + a_tag.get_text().strip() + \u0026#39;,文章url：\u0026#39; + a_tag[\u0026#39;href\u0026#39;]) 输出结果： ","permalink":"https://windypath.com/posts/two_crawl_web_approach/","summary":"爬虫的目的是采集网站的数据。而网站渲染数据有两种方式。我个人将其称为前端渲染和后端渲染。\n前端渲染 前端渲染指的是网页并不直接展示数据，而是在读取完网页之后，再次向服务器请求数据。在得到数据之后再渲染到网页中。\n后端渲染 后端渲染指的是服务器收到请求之后，将数据在后端写入网页，然后将带有数据的网页直接展示在浏览器中。\n爬取方式 目前我并没有使用scrapy、webmagic等爬虫框架，仅使用python的requests模块，json模块和BeautifulSoup框架。\n前端渲染的爬取方式\n步骤：使用requests请求数据，再用json.loads()方法将返回的数据解析，最后操作得到的数据对象即可。\n我们这里以豆瓣为例。\n分析该网页。 爬取的url：\nhttps://movie.douban.com/explore#!type=movie\u0026amp;tag=%E7%83%AD%E9%97%A8\u0026amp;sort=recommend\u0026amp;page_limit=20\u0026amp;page_start=0\n将url放进浏览器，先点开F12，然后访问。这里我使用谷歌浏览器 可以看到，红框内的All、XHR、JS等。这是一个筛选框，用来筛选该网页请求的数据。\nAll代表所有，XHR代表异步请求，JS代表Js文件，Css……\n对于前端渲染，必然有异步的过程，所以选择XHR。\n通过观察，发现第三行是“选电影”列表的数据。 这时，我们点击Headers，查看其请求的详细信息。 可以看到，这是一个Get请求，在下面的Qurey String Parameters可以看到该请求的参数。\n数据对应的网页内容为： 测试这个请求。 浏览器可以发起这个请求得到相应，但我们的代码不一定能做到。有一部分原因是网站开发者本身不希望数据被爬取。所以我们需要测试这个接口。这里推荐Postman，先对接口进行测试，查看是否有些Headers或者参数是不需要的，以简化代码量。\nPostman的用法下回分解吧。\n编写代码。 #!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2019/11/15 22:11 # @Author : Johnathan Lin import requests import json if __name__ == \u0026#39;__main__\u0026#39;: # 请求头，一般写上User-Agent防止爬虫，遇到有验证状态的网站要填写Cookie headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\u0026#39; } # 请求Url url = \u0026#39;https://movie.","title":"简述爬虫对两种网站的不同爬取方式"},{"content":"​ vue-cli（vue脚手架）超详细教程：vue-cli（vue脚手架）超详细教程_Yin_Xiaobo的博客-CSDN博客_vue-cli(vue脚手架)超详细教程\n这个教程里面是使用 vue init webpack app-name，但官方文档中建议的命令是 vue create app-name\n但这两个命令创建的项目是有些不一样的，vue init是版本2的方法，vue create是版本3的方法。但网上搜索了一圈，有人说两种方法都是vue.js + webpack结合的。\n当然了现在还不是很熟悉babel，所以根本看不懂。。\n这回我使用vue init webpack vue-demo，一阵操作之后，得到： 这样的一个结构。注意，src/router下有个index.js，里面装着路由：\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import HelloWorld from \u0026#39;@/components/HelloWorld\u0026#39; Vue.use(Router) export default new Router({ routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;HelloWorld\u0026#39;, component: HelloWorld } ] }) 同时在components文件夹下有一个 HelloWorld.vue，里面装着一个模板文件。\n注意到在/src/router/index.js里，第三行引入了HelloWorld的component，然后放在路由中，根目录指向的component。\n所以在执行npm run dev之后，就可以直接打开HelloWorld了。 这个页面就是通过根目录的路由得到的。\n然后我们添加一个路由：\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import HelloWorld from \u0026#39;@/components/HelloWorld\u0026#39; import About from \u0026#39;@/components/About\u0026#39; Vue.use(Router) export default new Router({ routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;HelloWorld\u0026#39;, component: HelloWorld }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, component: About } ] }) ​ 增加一个about路由。\n然后再components文件夹下加入一个About.vue。然后编译通过，但直接通过http://localhost:8080/about/ 访问，会回到根目录的HelloWorld页。\n为什么呢？\n原来Vue-Router用的是Hash模式，文档：不同的历史模式 | Vue Router\n就是说怕直接访问没有安排的路由，会报404错误，所以就自动跳转回来了。\n​ 之所以有个#也是因为hash模式。\n所以怎么访问路由呢？\n在App.vue里，加入一行 About\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; \u0026lt;img src=\u0026#34;./assets/logo.png\u0026#34;\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 然后，再次访问时就有一个超链接：\n从超链接中点击，就能访问那个路由了。\n这里多提一句，那个#有些扎眼，但在文档中他说如果没有#，则需要在后端设置404的跳转。\n","permalink":"https://windypath.com/posts/why_vue_router_back/","summary":"​ vue-cli（vue脚手架）超详细教程：vue-cli（vue脚手架）超详细教程_Yin_Xiaobo的博客-CSDN博客_vue-cli(vue脚手架)超详细教程\n这个教程里面是使用 vue init webpack app-name，但官方文档中建议的命令是 vue create app-name\n但这两个命令创建的项目是有些不一样的，vue init是版本2的方法，vue create是版本3的方法。但网上搜索了一圈，有人说两种方法都是vue.js + webpack结合的。\n当然了现在还不是很熟悉babel，所以根本看不懂。。\n这回我使用vue init webpack vue-demo，一阵操作之后，得到： 这样的一个结构。注意，src/router下有个index.js，里面装着路由：\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import HelloWorld from \u0026#39;@/components/HelloWorld\u0026#39; Vue.use(Router) export default new Router({ routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;HelloWorld\u0026#39;, component: HelloWorld } ] }) 同时在components文件夹下有一个 HelloWorld.vue，里面装着一个模板文件。\n注意到在/src/router/index.js里，第三行引入了HelloWorld的component，然后放在路由中，根目录指向的component。\n所以在执行npm run dev之后，就可以直接打开HelloWorld了。 这个页面就是通过根目录的路由得到的。\n然后我们添加一个路由：\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import HelloWorld from \u0026#39;@/components/HelloWorld\u0026#39; import About from \u0026#39;@/components/About\u0026#39; Vue.","title":"Vue的路由配置及手动改地址栏为啥又跳转回来？？"},{"content":"[JavaScript]JS基础知识（上） 变量类型及计算 变量类型 值类型 vs 引用类型\n值类型：\nvar a = 100 var b = a a = 200 console.log(b) //100 引用类型：\nvar a = {age:20} var b = a b.age = 21 console.log(a.age) //21 引用类型：对象、数组和函数\n特点：无限扩展属性，内存占用可能过大，故共用内存空间以节省空间\nTypeof运算符详解 typeof undefined\t//undefined typeof \u0026#39;abc\u0026#39;\t//string typeof 123\t//number typeof true\t//boolean typeof {}\t//object typeof []\t//object typeof null\t//object typeof console.log\t//function 注：null也是对象\n1~4行是值类型，5~8行是引用类型，但JS只能区分函数与非函数，而不能区分数组和对象。\n变量计算 强制类型转换 字符串拼接 var a = 100 + 10 var b = 100 + \u0026#39;10\u0026#39; console.log(a)\t//110 console.log(b)\t//10010 数字 + 字符串时将数字自身转为字符串。\n==运算符 console.log(100 == \u0026#39;100\u0026#39;)\t//true console.log(0 == \u0026#39;\u0026#39;)\t//true console.log(null == undefined)\t//true ==计算会试图让前后的比较对象相等，故发生类型转换\nif语句 var a = true if(a){ console.log(\u0026#39;a\u0026#39;); } var b = 100 if(b){ console.log(\u0026#39;b\u0026#39;) } var c = \u0026#39;\u0026#39; if(c){ console.log(\u0026#39;c\u0026#39;) } //输出 a // b //（c不输出） 100被强制转换为true，而’’被转换为false\n逻辑运算 console.log(10 \u0026amp;\u0026amp; 0)\t//0 console.log(\u0026#39;\u0026#39; || \u0026#39;abc\u0026#39;)\t//abc console.log(!window.abc)\t//true //判断一个变量会被当成true 还是 false var a = 100 console.log(!!a)\t//true 题目： 1、何时使用 === 何时使用 == ?\nif(obj.a == null){ //相当于 obj.a === null || obj.a === undefined 的简写形式 //jQuery源码推荐写法 } 除了这种情况外，全部使用===\n2、JS中有哪些内置函数\nObject Array Boolean Number String Function Date RegExp Error 3、如何理解JSON？\nJson既是数据格式，也是数据对象。\nJSON.stringify({a:10,b:20}) JSON.parse(\u0026#39;{\u0026#34;a\u0026#34;:10,\u0026#34;b\u0026#34;:20}\u0026#39;) 原型和原型链 构造函数 function Foo(name,age){ this.name = name this.age = age this.class = \u0026#39;class-1\u0026#39; //return this //默认有这一行 } var f = new Foo(\u0026#39;zhangsan\u0026#39;,20) //var f1 = new Foo(\u0026#39;lisi\u0026#39;,21)\t//创建多个对象 构造函数需使用大写开头！\n扩展：\nvar a = {} 其实是 var a = new Object() 的语法糖\nVar a = [] 其实是 Var a = new Array() 的语法糖\nFunction Foo(){\u0026hellip;} 其实是 var Foo = new Function(\u0026hellip;)的语法糖\n使用instanceof判断一个函数是否是一个变量的构造函数\n判断一个变量是否为“数组”： 变量 instanceof Array\n5条原型规则 1、所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了null以外）\nvar obj = {};obj.a = 100; var arr = [];arr.a = 100; function fn(){} fn.a = 100 2、所有的引用类型（数组、对象、函数），都有一个__proto__属性，属性值是一个普通的对象。（隐式原型）\nconsole.log(obj.__proto__); console.log(arr.__proto__); console.log(fn.__proto__); 输出结果： 3、所有的函数，都有一个prototype属性，属性值也是一个普通的对象（显式原型）\nconsole.log(fn.prototype) 输出结果 4、所有的引用类型（数组、对象、函数），__proto__属性值指向它的构造函数的“prototype”属性值\nconsole.log(obj.__proto__ === Object.prototype) //true 5、当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找\nfunction Foo(name, age){ this.name = name } Foo.prototype.alertName = function(){ alert(this.name) } //创建示例 var f = new Foo(\u0026#39;zhangsan\u0026#39;) f.printName = function(){ console.log(this.name); } //测试 f.printName() f.alertName() this：\n永远指向f自身，故能读取属性\n循环对象自身的属性\nvar item for (item in f){ //高级浏览器已经在for in中屏蔽了来自原型的属性 //但是建议还是加判断 if(f.hasOwnProperty(item)){ console.log(item) } } 原型链 function Foo(name, age){ this.name = name } Foo.prototype.alertName = function(){ alert(this.name) } //创建示例 var f = new Foo(\u0026#39;zhangsan\u0026#39;) f.printName = function(){ console.log(this.name); } //测试 f.printName() f.alertName() f.toString() // 要去f.__proto__.__proto__中查找 注意，toString()是Object.prototype中的方法，f通过读取__proto__的方式寻找该方法，但它的上一级原型并没有这个方法，故寻找隐式原型的隐式原型，最终在Object中找到了toString()方法。\nInstanceof的用法介绍 用于判断引用类型属于哪个构造函数的方法\nF instanceof Foo 的判断逻辑是：\nF 的 proto 一层一层往上，能否对应到 Foo.prototype\n再试着判断 f instanceof Object\n题目：\n1、如何准确判断一个变量是数组类型\nvar arr = [] arr instanceof Array\t// true typeof arr //Object 2、写一个原型链继承的例子\n封装DOM查询：\nfunction Elem(id){ this.elem = document.getElementById(id) } Elem.prototype.html = function(val){ var elem = this.elem if(val){ elem.innerHTML = val return this //链式操作 }else{ return elem.innerHTML } } Elem.prototype.on = function(type, fn){ var elem = this.elem elem.addEventListener(type,fn) return this } var div1 = new Elem(\u0026#39;div1\u0026#39;) //console.log(div1.html()) div1.html(\u0026#39;\u0026lt;p\u0026gt;hello world\u0026lt;/p\u0026gt;\u0026#39;) div1.on(\u0026#39;click\u0026#39;,function(){ alert(\u0026#39;clicked\u0026#39;) }) //链式操作 div1.html(\u0026#39;\u0026lt;p\u0026gt;hello world\u0026lt;/p\u0026gt;\u0026#39;).on(\u0026#39;click\u0026#39;,function(){ alert(\u0026#39;clicked\u0026#39;) }) 3、描述new一个对象的过程\nfunction Foo(name,age){ this.name = name this.age = age this.class = \u0026#39;class-1\u0026#39; //return this //默认有这一行 } var f = new Foo(\u0026#39;zhangsan\u0026#39;,20) 创建一个新对象 this指向这个新对象 执行代码，即对this赋值 返回this [JavaScript]JS基础知识（中） 作用域和闭包 执行上下文 范围：一段\u0026lt;script\u0026gt;或者一个函数\n全局：变量定义、函数声明（一段\u0026lt;script\u0026gt;）\n函数：变量定义、函数声明、this、arguments（函数）\nconsole.log(a) //undefined var a = 100 fn(\u0026#39;zhangsan\u0026#39;) //zhangsan 20 function fn(name){ //函数内 age = 20 console.log(name, age) var age bar(100) function bar(num){ console.log(num) } } 在第2行执行之前，a被声明为undefined，而在第5行执行时，函数fn直接被提前完整声明了，所以可以正确执行。\n在第6~15行，是函数内的执行上下文，同理，在第8行中读取age的属性，自动为age完成了“var age”的声明，故程序可正常执行。\n建议定义要放前面，方便他人阅读。\n在函数fn中，bar(100)也会去寻找function bar()的声明，故也能正常输出数字。\n关于this、argument，在函数执行之前，this就已经确定了值。\n注意“函数声明”和“函数表达式”的区别 //函数声明 function fn(){ //声明 } //函数表达式 var fn = function(){ //表达式 } 注意，执行第1行时，如果是用函数声明的方式定义函数，则可以执行，而使用函数表达式的方式，则报错，因为找不到函数的定义。\nthis 作为构造函数执行：\nfunction Foo(name){ this.name = name } var f = new Foo(\u0026#34;zhangsan\u0026#34;) 作为对象属性执行：\nvar obj = { name: \u0026#39;A\u0026#39;, printName: function(){ console.log(this.name) } } obj.printName() 作为普通函数执行：\nfunction fn(){ console.log(this) //this === window } fn() call apply bind：\nfunction fn1(name,age){ alert(name) console.log(this) } fn1.call({x:100},\u0026#39;zhangsan\u0026#39;,20) fn1.apply({x:100},[\u0026#39;zhangsan\u0026#39;,20]) var fn2 = function(name,age){ alert(name) console.log(this) }.bind({y:200}) fn2(\u0026#39;zhangsan\u0026#39;,20) call、apply和bind可以修改this的值。其中要注意bind必须要用函数表达式的方式才能执行。\n作用域 js中，无块级作用域：\nif(true){ var name = \u0026#39;zhangsan\u0026#39; } console.log(name) //zhangsan 外部可以访问if语句块中的name\n有函数和全局作用域：\nvar a = 100 function fn(){ var a = 200 console.log(\u0026#39;fn\u0026#39;,a) //fn 200 } console.log(\u0026#39;global\u0026#39;,a) //global 100 fn() 由于有函数作用域和全局作用域，故两次输出a的值不同。定义到函数里的变量，外部不可调用、改变。\n作用域链 关于自由变量：\nvar a = 100 function fn(){ var b = 200 //当前作用域中没有定义的变量，即“自由变量” console.log(a) console.log(b) } fn() 在fn函数中，并没有定义a，但是fn从其父级作用域中寻找变量。\n函数的作用域是由函数定义的时候指定的，而不是函数执行时指定的。\n关于作用域链：\nvar a = 100 function f1(){ var b = 200 function f2(){ var c = 300 console.log(a) //自由变量 console.log(b) //自由变量 console.log(c) } f2() } f1() F1的父级作用域是全局作用域，f2的父级作用域是f1，因此当打印a时，js向父级作用域中寻找，而f1作用域没有，则再往f1的父级作用域，即全局作用域中寻找，再全局作用域中找到a，而b也同理。\n这个寻找的过程是从作用域链中一步步寻找得到的，这就是作用域链。\n闭包 函数作为返回值的情况： function F1(){ var a = 100 //返回一个函数（函数作为返回值） return function(){ console.log(a) } } //f1得到一个新函数 var f1 = F1() a = 200 f1() // 10 F1函数返回了一个函数。将返回的函数赋值给了f1，之后执行f1。\n在第5行中，a是自由变量，故到它的父级作用域中寻找，而F1()函数中定义了a = 100，所以a的值为100。\n函数作为参数传递的情况： function F1(){ var a = 100 //返回一个函数（函数作为返回值） return function(){ console.log(a) } } var f1 = new F1() function F2(fn){ a = 200 fn() } F2(f1); //还是 100 题目： 1、说一下对变量提升的理解：\n变量定义 函数声明（注意和函数表达式的区别）\n2、说明this几种不同的使用场景\n作为构造函数执行 作为对象属性执行 作为普通函数执行 Call apply bind\n3、创建10个\u0026lt;a\u0026gt;标签，点击的时候弹出来对应的序号\n错误代码：\nvar i,a for(i = 0;i \u0026amp;lt; 10;i++){ a = document.createElement(\u0026#39;a\u0026#39;) a.innerHTML = i + \u0026#39;\u0026amp;lt;br/\u0026amp;gt;\u0026#39; a.addEventListener(\u0026#39;click\u0026#39;,function(e){ e.preventDefault() alert(i) }) document.body.appendChild(a) } 执行结果：无论点击哪个链接，都弹出10。原因是在全局作用域中，i在循环结束时的值为10，所以不管之前定义时i的值为多少，总是返回当前作用域的i的值。\n正确解法：使用自执行函数（就是不用调用，只要定义完成，立即执行的函数）\n正确代码：\nvar i for(i = 0;i \u0026amp;lt; 10;i++){ (function(i){ //存在自己的函数作用域 var a = document.createElement(\u0026#39;a\u0026#39;) a.innerHTML = i + \u0026#39;\u0026amp;lt;br/\u0026amp;gt;\u0026#39; a.addEventListener(\u0026#39;click\u0026#39;,function(e){ e.preventDefault() alert(i) }) document.body.appendChild(a) })(i) } 结果截图： [JavaScript]JS基础知识（下） 异步和单线程 异步 console.log(100) setTimeout(function(){ console.log(200) },1000) console.log(300) //输出： //100 //300 //200（过了1秒后） 同步 console.log(100) alert(200) console.log(300) //在弹窗弹出200时，控制台是不打印300的，直到弹框结束才打印300 同步会阻塞下面代码的执行，什么时候消除阻塞，才会继续往下走。\n异步不会阻塞，只是继续等待。\n异步同步的差异在于，会不会阻塞后续代码的执行。\n何时需要异步？ 在可能发生等待的情况。\n等待过程中不能像alert一样阻塞程序执行。\n因此，所有的“等待的情况”都需要异步。\n前端使用异步的场景 定时任务：setTimeout（设置多少毫秒之后执行函数体）,setInterval（设置每多少毫秒之后执行函数体）\nconsole.log(100) setTimeout(function(){ console.log(200) },1000) console.log(300) //输出： //100 //300 //200（过了1秒后） 网络请求：ajax请求：\nconsole.log(\u0026#39;start\u0026#39;) $.get(\u0026#39;./data1.json\u0026#39;,function(data1){ console.log(data1) }) console.log(\u0026#39;end\u0026#39;) 动态\u0026lt;img\u0026gt;加载：\nconsole.log(\u0026#39;start\u0026#39;) var img = document.createElement(\u0026#39;img\u0026#39;) img.onload = function(){ console.log(\u0026#39;loaded\u0026#39;) } img.src = \u0026#39;img/HBuilder.png\u0026#39; console.log(\u0026#39;end\u0026#39;) 事件绑定：\nconsole.log(\u0026#39;start\u0026#39;) document.getElementById(\u0026#39;div1\u0026#39;).addEventListener(\u0026#39;click\u0026#39;,function(){ alert(\u0026#39;clicked\u0026#39;) }) console.log(\u0026#39;end\u0026#39;) 异步和单线程 console.log(100) setTimeout(function(){ console.log(200) },1000) console.log(300) //输出： //100 //300 //200（过了1秒后） 执行第1行，打印100，\n执行setTimeout后，传入setTimeout函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事），\n执行最后一行，打印300，\n待所有程序执行完，处于空闲状态时，会马上查看有没有暂存起来的要执行的函数，\n发现暂存起来的setTimeout中的函数无需等待时间，就立即发过来执行。\n题目 1、同步和异步的区别是什么？分别举一个同步和异步的例子。\n同步会阻塞代码执行，而异步不会。\nAlert是同步，setTimeout是异步。\n2、一个关于setTimeout的笔试题：\nconsole.log(1) setTimeout(function(){ console.log(2) },0) console.log(3) setTimeout(function(){ console.log(4) },1000) console.log(5) 输出：1 3 5 2 4\n3、前端使用异步的场景有哪些？\n都需要等待，单线程，为了不阻塞，只能等待。\n其他知识 日期 Date.now()\t//当前时间的毫秒数 var dt = new Date() dt.getTime() //获取毫秒数 dt.getFullYear() //年 dt.getMonth() //月（0~11） dt.getDate()\t//日（0~31） dt.getHours()\t//小时（0~23） dt.getMinutes()\t//分钟（0~59） dt.getSeconds()\t//秒\t(0~59) Math 获取随机数Math.random()\n数组API forEach 遍历所有元素：\nvar arr = [1,2,3] //参数为 元素,下标，元素在前，下标在后 arr.forEach(function(item, index){ //遍历数组中的所有元素 console.log(index,item) }) every 判断所有元素是否都符合条件：\nvar arr = [1,2,3] var result = arr.every(function(item, index){ //用来判断所有的数组元素，是否都满足一个条件 if(item \u0026amp;lt; 2){ return true } }) console.log(result)\t//false some 判断是否有至少一个元素符合条件：\nvar arr = [1,2,3] var result = arr.some(function(item, index){ //用来判断所有的数组元素，只要有一个满足条件即可 if(item \u0026amp;lt; 2){ return true } }) console.log(result)\t//true sort 排序\nvar arr = [1,4,2,3,5] var arr2 = arr.sort(function(a,b){ //从小到大排序 return a - b }) console.log(arr2) map 对元素重新组装，生成新数组\nvar arr = [1,2,3,4] var arr2 = arr.map(function(item,index){ //将元素重新组装，并返回 return \u0026#39;\u0026amp;lt;b\u0026amp;gt;\u0026#39; + item + \u0026#39;\u0026amp;lt;/b\u0026amp;gt;\u0026#39; }) console.log(arr2) filter 过滤符合条件的元素：\nvar arr = [1,2,3] var arr2 = arr.filter(function(item,index){ //通过某一个条件过滤数组 if(item \u0026amp;gt;= 2){ return true } }) console.log(arr2) 对象API for in\nvar obj = { x:100, y:200, z:300 } var key for(key in obj){ if(obj.hasOwnProperty(key)){ console.log(key,obj[key]) } } 题目 1、获取2017-06-10格式的日期\nfunction formatDate(dt){ if(!dt){ dt = new Date() } var year = dt.getFullYear() var month = dt.getMonth() + 1 var date = dt.getDate() if(month \u0026amp;lt; 10){ //强制类型转换 month = \u0026#39;0\u0026#39; + month } if(date \u0026amp;lt; 10){ //强制类型转换 date = \u0026#39;0\u0026#39; + date } //强制类型转换 return year + \u0026#39;-\u0026#39; + month + \u0026#39;-\u0026#39; + date } var dt = new Date() var formatDate = formatDate(dt) console.log(formatDate) 2、获取随机数，要求是长度一致的字符串格式\nvar random = Math.random() random = random + \u0026#39;0000000000\u0026#39;//后面加上10个零 random = random.slice(0,10) console.log(random) 3、写一个能遍历对象和数组的通用forEach函数\n//对数组: var arr = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] forEach(arr,function(item,index){ console.log(index,item) }) //对对象: var obj = { \u0026#39;one\u0026#39;:\u0026#39;a\u0026#39;, \u0026#39;two\u0026#39;:\u0026#39;b\u0026#39; } for(key in obj){ console.log(key,obj[key]) } //组合后: function forEach(obj,fn){ var key if(obj instanceof Array){ //准确判断是不是数组 obj.forEach(function(item,index){ fn(index,item) }) }else{ //不是数组就是对象 for(key in obj){ fn(key,obj[key]) } } } [JavaScript]JS WEB API（上） JS WEB API Ecma262 + w3c\nDOM操作 1、DOM是哪种基本的数据结构？树\n2、DOM操作的常用API有哪些？\n获取DOM节点，以及节点的property和attribute\n获取父节点，获取子节点\n新增节点，删除节点\n3、DOM节点的attr和property有何区别？\nProperty只是一个js对象的属性的修改\nAttribute是对html标签属性的修改\nDOM本质 浏览器把拿到的HTML代码，结构化一个浏览器能识别并且js可操作的一个模型而已。\nDOM节点操作 获取DOM节点 prototype 获取的是js对象 attribute 获取的是DOM节点 DOM结构操作 新增节点 获取父元素、获取子元素、删除节点 BOM操作 Navigator、Screen Location、History 1、如何检测浏览器的类型？\nNavigator\n2、拆解url的各部分\nlocation\n","permalink":"https://windypath.com/posts/javascript_basic_knowledge/","summary":"[JavaScript]JS基础知识（上） 变量类型及计算 变量类型 值类型 vs 引用类型\n值类型：\nvar a = 100 var b = a a = 200 console.log(b) //100 引用类型：\nvar a = {age:20} var b = a b.age = 21 console.log(a.age) //21 引用类型：对象、数组和函数\n特点：无限扩展属性，内存占用可能过大，故共用内存空间以节省空间\nTypeof运算符详解 typeof undefined\t//undefined typeof \u0026#39;abc\u0026#39;\t//string typeof 123\t//number typeof true\t//boolean typeof {}\t//object typeof []\t//object typeof null\t//object typeof console.log\t//function 注：null也是对象\n1~4行是值类型，5~8行是引用类型，但JS只能区分函数与非函数，而不能区分数组和对象。\n变量计算 强制类型转换 字符串拼接 var a = 100 + 10 var b = 100 + \u0026#39;10\u0026#39; console.","title":"[JavaScript]JS基础知识"},{"content":"这个标题有点奇怪。不过我要说的就是，在Mybatis逆向工程自动生成的Mapper中，对TEXT字段的定义和其他的字段不一样。\nComments表设计： 可以看到，content字段为TEXT。\n然而，直接调用selectByExample()方法，查询不到content字段的内容： 而究其原因，是因为在自动生成的CommentsMapper.xml中，对TEXT字段的定义是不一样的。\n\u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;com.windypath.seer.pojo.Comments\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;id\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;uid\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;uid\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;aid\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;aid\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;floor\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;floor\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;createDate\u0026#34; jdbcType=\u0026#34;TIMESTAMP\u0026#34; property=\u0026#34;createDate\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;isDeleted\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;isDeleted\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;resultMap extends=\u0026#34;BaseResultMap\u0026#34; id=\u0026#34;ResultMapWithBLOBs\u0026#34; type=\u0026#34;com.windypath.seer.pojo.Comments\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;content\u0026#34; jdbcType=\u0026#34;LONGVARCHAR\u0026#34; property=\u0026#34;content\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; 在代码中可以清晰地看到，content字段放在了“extends”里，而没有和其他的字段放在一起。jdbcType也定义成了LONGVARCHAR，我认为这样做是担心这个字段里装的数据量过大，增加查询负担，所以把它放进extends里。\n而selectByExample()的初衷也许是查找信息列表。我发现在selectByPrimaryKey()中，只查询某一条数据的情况下，TEXT字段就会被查询出来。\n因此我将TEXT改成了varchar(1000)，问题解决。\n（逆向工程修改后要重新生成一次覆盖旧的东西！） ","permalink":"https://windypath.com/posts/mybatis_text_not_queried/","summary":"这个标题有点奇怪。不过我要说的就是，在Mybatis逆向工程自动生成的Mapper中，对TEXT字段的定义和其他的字段不一样。\nComments表设计： 可以看到，content字段为TEXT。\n然而，直接调用selectByExample()方法，查询不到content字段的内容： 而究其原因，是因为在自动生成的CommentsMapper.xml中，对TEXT字段的定义是不一样的。\n\u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;com.windypath.seer.pojo.Comments\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;id\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;uid\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;uid\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;aid\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;aid\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;floor\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;floor\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;createDate\u0026#34; jdbcType=\u0026#34;TIMESTAMP\u0026#34; property=\u0026#34;createDate\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;isDeleted\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34; property=\u0026#34;isDeleted\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;resultMap extends=\u0026#34;BaseResultMap\u0026#34; id=\u0026#34;ResultMapWithBLOBs\u0026#34; type=\u0026#34;com.windypath.seer.pojo.Comments\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;content\u0026#34; jdbcType=\u0026#34;LONGVARCHAR\u0026#34; property=\u0026#34;content\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; 在代码中可以清晰地看到，content字段放在了“extends”里，而没有和其他的字段放在一起。jdbcType也定义成了LONGVARCHAR，我认为这样做是担心这个字段里装的数据量过大，增加查询负担，所以把它放进extends里。\n而selectByExample()的初衷也许是查找信息列表。我发现在selectByPrimaryKey()中，只查询某一条数据的情况下，TEXT字段就会被查询出来。\n因此我将TEXT改成了varchar(1000)，问题解决。\n（逆向工程修改后要重新生成一次覆盖旧的东西！） ","title":"[Mybatis]逆向工程中Select语句查询不出‘TEXT’字段"},{"content":"FIRST集 FIRST(α)为α的开始符号集或者首符号集。\n定义 设G=(VT，VN，S，P)是上下文无关文法 ，FIRST(α)={a|α能推导出aβ,a∈VT，α,β∈V*} 。\n特别的，若α能推导出ε,则规定ε∈FIRST(α)．\nVT为终结符集，VN为非终结符集，S称作识别符或开始符，P为规则(α→β)的集合。\n根据定义求解FIRST集 （对每一文法符号X∈V 计算FIRST(X)）\n若X∈VT，则FIRST(X)={X}； 若X∈VN，且有产生式X→a\u0026hellip;，则把a加入到FIRST(X)中； 若X∈VN，X→ε也是一条产生式，则把ε也加到FIRST(X)中； 若X→Y\u0026hellip;是一个产生式且Y∈VN，则把FIRST(Y)中的所有非ε元素都加到FIRST(X)中； 若X→Y1 Y2 \u0026hellip; Yk是一个产生式，Y1，Y2，\u0026hellip;Y（i-1）都∈VN（1≤i≤K），而且，对于任何j(1≤j≤i-1)，FIRST(Yj)都含有ε （即Y1\u0026hellip;Y(i-1)=\u0026gt;*ε），则把FIRST(Yj)中的所有非ε元素和FIRST(Yi)中的所有元素都加到FIRST(X)中； 特别是，若所有的FIRST(Yj，j=1,2,..,K)均含有ε，则把ε加到FIRST(X)中。\n反复使用上述2~5步，直到每个符号的FIRST集合不再增大为止。\nFOLLOW集 FOLLOW(A)为非终结符A的后跟符号集合。\n定义 设G=(VT，VN，S，P)是上下文无关文法，A∈VN，S是开始符号， FOLLOW(A)=｛a|S能推导出μAβ,且a∈VT，a∈FIRST(β),μ∈VT* ,β∈V+｝，若S能推导出μAβ,且β能推导出ε, 则#∈FOLLOW(A)。 也可定义为：FOLLOW(A)={a|S能推导出…Aa…,a ∈VT} ，若有S能推导出…A，则规定#∈FOLLOW(A) ，这里我们用‘#’作为输入串的结束符。\n计算FOLLOW集 任何FOLLOW(S)都包含输入终止符号#,其中S是开始符号 如果存在产生式,A-\u0026gt;αBβ,则将FIRST(β)中除ε以外的符号都放入FOLLOW(B)中 如果存在产生式,A-\u0026gt;αB,或A-\u0026gt;αBβ,其中FIRST(β)中包含ε,则将FOLLOW(A)中的所有符号都放入FOLLOW(B)中.\nSELECT集 SELECT集是选择符号集。\n定义及计算过程 给定上下文无关文法的产生式A→α, A∈VN,α∈V*, 若α不能推导出ε,则SELECT(A→α)=FIRST(α) 如果α能推导出ε则：SELECT(A→α)=（FIRST(α) –{ε}）∪FOLLOW(A) 需要注意的是，SELECT集是针对产生式而言的。\n例题 《编译原理》第三版，p100页，第2题：\n对下面的文法G： E→TE‘ E‘→+E|ε T→FT' T‘→T|ε F→PF' F\u0026rsquo;→*F\u0026rsquo;|ε P→(E)|a|b|^\n问：\n计算这个文法的每个非终结符的FIRST集和FOLLOW集。 证明这个文法是LL(1)的。 构造它的预测分析表。 构造它的递归下降分析程序。 答：\n1.计算这个文法的每个非终结符的FIRST集和FOLLOW集。\nFIRST(P) = {a,b,(,^} FIRST(F) = FIRST(P) = {a,b,(,^} FIRST(T) = FIRST(F) = {a,b,(,^} FIRST(E) = FIRST(T) = {a,b,(,^} FIRST(E\u0026rsquo;) = {+,ε} FIRST(T\u0026rsquo;) = FIRST(T) ∪ {ε} = {a,b,(,^,ε} FIRST(F\u0026rsquo;) = {*,ε}\nFOLLOW(E) = {#,)} FOLLOW(E\u0026rsquo;) = FOLLOW(E) = {#,)} FOLLOW(T) = (FIRST(E\u0026rsquo;) - {ε}) ∪ FOLLOW(E) = {+,#,)} FOLLOW(T\u0026rsquo;) = FOLLOW(T) = {+,#,)} FOLLOW(F) = (FIRST(T\u0026rsquo;) - {ε}) ∪ FOLLOW(T) = {a,b,(,#,^,+,)} FOLLOW(F\u0026rsquo;) = FOLLOW(F) = {a,b,(,#,^,+,)} FOLLOW(P) = (FIRST(F\u0026rsquo;) - {ε}) ∪ FOLLOW(F) = {*,a,b,(,#,^,+,)}\nFIRST FOLLOW E {a,b,(,^} {#,)} E' {+,ε} {#,)} T {a,b,(,^} {+,#,)} T' {a,b,(,^,ε} {+,#,)} F {a,b,(,^} {a,b,(,#,^,+,)} F' {*,ε} {a,b,(,#,^,+,)} P {a,b,(,^} {*,a,b,(,#,^,+,)} 2.证明这个文法是LL(1)的。\n考虑下列产生式： E‘→+E|ε T‘→T|ε F\u0026rsquo;→*F\u0026rsquo;|ε P→(E)|a|b|^\nFIRST(+E) ∩ FIRST(ε) = {+} ∩ {ε} = ∅ FIRST(T) ∩ FIRST(ε) = {(,a,b,^} ∩ {ε} = ∅ FIRST(F\u0026rsquo;) ∩ FIRST(ε) = {} ∩ {ε} = ∅ FIRST((E)) ∩ FIRST(a) ∩ FIRST(b) ∩ FIRST(^) = ∅\nFIRST(E\u0026rsquo;) ∩ FOLLOW(E\u0026rsquo;) = {+,ε} ∩ {#,)} = ∅ FIRST(T\u0026rsquo;) ∩ FOLLOW(T\u0026rsquo;) = {(,a,b,^,ε} ∩ {+,#,)} = ∅ FIRST(F\u0026rsquo;) ∩ FOLLOW(F\u0026rsquo;) = {*,ε} ∩ {(,A,B,^,+,),#} = ∅\n所以，该文法是LL(1)文法。\n","permalink":"https://windypath.com/posts/compilation_principle_first_follow_select/","summary":"FIRST集 FIRST(α)为α的开始符号集或者首符号集。\n定义 设G=(VT，VN，S，P)是上下文无关文法 ，FIRST(α)={a|α能推导出aβ,a∈VT，α,β∈V*} 。\n特别的，若α能推导出ε,则规定ε∈FIRST(α)．\nVT为终结符集，VN为非终结符集，S称作识别符或开始符，P为规则(α→β)的集合。\n根据定义求解FIRST集 （对每一文法符号X∈V 计算FIRST(X)）\n若X∈VT，则FIRST(X)={X}； 若X∈VN，且有产生式X→a\u0026hellip;，则把a加入到FIRST(X)中； 若X∈VN，X→ε也是一条产生式，则把ε也加到FIRST(X)中； 若X→Y\u0026hellip;是一个产生式且Y∈VN，则把FIRST(Y)中的所有非ε元素都加到FIRST(X)中； 若X→Y1 Y2 \u0026hellip; Yk是一个产生式，Y1，Y2，\u0026hellip;Y（i-1）都∈VN（1≤i≤K），而且，对于任何j(1≤j≤i-1)，FIRST(Yj)都含有ε （即Y1\u0026hellip;Y(i-1)=\u0026gt;*ε），则把FIRST(Yj)中的所有非ε元素和FIRST(Yi)中的所有元素都加到FIRST(X)中； 特别是，若所有的FIRST(Yj，j=1,2,..,K)均含有ε，则把ε加到FIRST(X)中。\n反复使用上述2~5步，直到每个符号的FIRST集合不再增大为止。\nFOLLOW集 FOLLOW(A)为非终结符A的后跟符号集合。\n定义 设G=(VT，VN，S，P)是上下文无关文法，A∈VN，S是开始符号， FOLLOW(A)=｛a|S能推导出μAβ,且a∈VT，a∈FIRST(β),μ∈VT* ,β∈V+｝，若S能推导出μAβ,且β能推导出ε, 则#∈FOLLOW(A)。 也可定义为：FOLLOW(A)={a|S能推导出…Aa…,a ∈VT} ，若有S能推导出…A，则规定#∈FOLLOW(A) ，这里我们用‘#’作为输入串的结束符。\n计算FOLLOW集 任何FOLLOW(S)都包含输入终止符号#,其中S是开始符号 如果存在产生式,A-\u0026gt;αBβ,则将FIRST(β)中除ε以外的符号都放入FOLLOW(B)中 如果存在产生式,A-\u0026gt;αB,或A-\u0026gt;αBβ,其中FIRST(β)中包含ε,则将FOLLOW(A)中的所有符号都放入FOLLOW(B)中.\nSELECT集 SELECT集是选择符号集。\n定义及计算过程 给定上下文无关文法的产生式A→α, A∈VN,α∈V*, 若α不能推导出ε,则SELECT(A→α)=FIRST(α) 如果α能推导出ε则：SELECT(A→α)=（FIRST(α) –{ε}）∪FOLLOW(A) 需要注意的是，SELECT集是针对产生式而言的。\n例题 《编译原理》第三版，p100页，第2题：\n对下面的文法G： E→TE‘ E‘→+E|ε T→FT' T‘→T|ε F→PF' F\u0026rsquo;→*F\u0026rsquo;|ε P→(E)|a|b|^\n问：\n计算这个文法的每个非终结符的FIRST集和FOLLOW集。 证明这个文法是LL(1)的。 构造它的预测分析表。 构造它的递归下降分析程序。 答：\n1.计算这个文法的每个非终结符的FIRST集和FOLLOW集。\nFIRST(P) = {a,b,(,^} FIRST(F) = FIRST(P) = {a,b,(,^} FIRST(T) = FIRST(F) = {a,b,(,^} FIRST(E) = FIRST(T) = {a,b,(,^} FIRST(E\u0026rsquo;) = {+,ε} FIRST(T\u0026rsquo;) = FIRST(T) ∪ {ε} = {a,b,(,^,ε} FIRST(F\u0026rsquo;) = {*,ε}","title":"[编译原理]FIRST、FOLLOW和SELECT"},{"content":"[Spring]Spring学习笔记（一） Spring 概念 spring是开源轻量级框架 AOP：面向切面编程，扩展功能不是修改源代码实现 IOC ：控制反转，有一个类，在类里面有方法（不是静态方法） 把对象的创建通过spring配置创建类对象 一站式框架 三层： web层 springMVC Service层 ioc Dao层 jdbcTemplate spring版本 当前最新版本：https://projects.spring.io/spring-framework/#quick-start 官网建议用Maven/Gradle安装 Spring的ioc操作 把对象的创建交给spring进行管理 ioc操作两部分： Ioc的配置文件方式 Ioc的注解方式 IOC底层原理 ioc底层原理使用技术 xml配置文件 Dom4j解决xml 工厂设计模式 反射 IOC使用方法（简单样例）： 导入jar包（用Maven/Gradle直接导入） 编写要操作的类（简单的User类） 创建Spring配置文件，通过配置创建类： 在src下创建xml文件，官方建议为applicationContext.xml 引入schema约束，来源：https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html 要加入的代码 配置对象创建 \u0026lt;bean id=\u0026#34;对象名\u0026#34; class=\u0026#34;类的路径（org.springframework.abcdef）\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 编写测试代码 import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class testIOC { @Test public void testMain() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;a.xml\u0026#34;); Main m = (Main) context.getBean(\u0026#34;m\u0026#34;); System.out.println(m); m.add(); } } 注：Maven自带的Junit版本为3.8.2，无法使用注解方式，故应手动修改为4.0以上版本才可使用注解。 测试结果如上图\n在spring里面通过配置文件创建对象 Beans 实例化有三种方式：\n第一种 使用类的无参数构造创建（重点） 类里面没有无参数的构造，会出现异常 第二种 使用静态工厂创建 创建静态方法返回类对象\n根据类调用静态方法 \u0026lt;bean id=”bean2” class=”****” factory-method=”getBean2”\u0026gt; 第三种 使用实例工厂创建 创建不是静态的方法，返回类对象 先创建工厂对象 \u0026lt;bean id=”bean3factory” class=”bean3类”\u0026gt; 再创建目标类，通过工厂对象里的方法构造 \u0026lt;bean id=”bean3” factory-bean=”bean3factory” factory-method-”getBean3”\u0026gt; Bean标签常用属性 id属性 起名称，任意命名 Id属性值不能包含特殊符号，根据id值得到配置对象 class属性：创建对象所在类的全路径 name属性：与id本身功能一样，但name可以加特殊符号（遗留问题） scope属性： singleton 单例 默认值 只有一个对象 Prototype 多例 多实例对象 不常用： Request 创建对象并把对象放到request域内 Session创建对象并把对象放到session域内 Globalsession 创建对象并把对象放到globalsession域内 属性注入 创建对象的时候，向类里面的属性设置值\n属性注入的三种方式： 有参构造：（constructor-arg，构造函数为User(string username) ） \u0026lt;bean id=\u0026#34;demo1\u0026#34; class=\u0026#34;类\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;username\u0026#34; value=\u0026#34;值\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; Set方法构造：（property，构造函数没有参数，但类中有set方法） \u0026lt;bean id=\u0026#34;demo2\u0026#34; class=\u0026#34;类\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;bookname\u0026#34; value=\u0026#34;值\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 注入对象类型属性（属性可能是自定义对象） 创建service类和dao类，同时在service得到dao对象 具体实现过程 在service里面把dao作为类型属性 生成dao类型属性的set方法 配置文件中设置注入关系 \u0026lt;bean id=”userDao” class=”dao”\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=”userService” class=”service”\u0026gt; \u0026lt;!-- 不写value 写ref属性 对应ID --\u0026gt; \u0026lt;property name=”userDao” ref=”userDao”\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; P名称空间注入： 注入复杂类型属性 数组 list集合 map集合 properties类型 数组与list集合\n\u0026lt;bean id=”person” class=”类”\u0026gt; \u0026lt;!-- 数组 list--\u0026gt; \u0026lt;property name=”arrs”\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;aaa\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;ada\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;aba\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- map --\u0026gt; \u0026lt;property name=”map”\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=”aa” value=”lucy”\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=”bb” value=”ldcy”\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=”cc” value=”luacy”\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=”properties”\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=”driverclass”\u0026gt;com.mysql.jdbc.Driver\u0026lt;/prop\u0026gt; \u0026lt;prop key=”username”\u0026gt;user\u0026lt;/prop\u0026gt; …… \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; IOC和DI区别 IOC：控制反转，把对象创建交给spring进行配置 DI：依赖注入，向类里面的属性中设置值 关系：依赖注入不能单独存在，需要在ioc基础之上完成操作 Spring整合Web项目原理 加载spring核心配置文件 通过new来创建对象，虽然功能可以实现，但是效率很低 实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成。 实现原理： servletContext对象 监听器 具体使用（原理、已封装） 在服务器启动时，为每个项目创建ServletContext对象 在servletContext对象创建手，使用监听器可以具体到ServletContext对象在什么时候创建 使用监听器监听到ServletContext对象创建时候， 加载spring配置文件，把配置文件配置对象创建 把创建出来的对象放到SERVLETcONTEXT域对象里面（setAttribute方法） 获取对象时候，到ServletContext域得到（getAttribute方法） [Spring]Spring学习笔记（二） Spring的bean管理（注解） 注解介绍 代码里面特殊标记，使用注解可以完成功能 注解写法 @注解名称(属性名称=属性值) 注解使用在类上面，方法上面 和 属性上面 Spring注解开发准备工作 导入jar包 导入基本的jar包 导入aop的jar包 创建类，创建方法 创建Spring配置文件，引入约束 ioc基本功能，引入约束 做Spring的ioc注解开发，引入新的约束 注解创建对象 配置文件中，开启注解扫描\n到包里面扫描类、方法、属性上面是否有注解\n\u0026lt;context:component-scan base-package=”包名”\u0026gt;\u0026lt;/context:component-scan\u0026gt;\n只扫描属性上面的注解\ncontext:annotation-config\n注解注入属性 在创建对象的类上面使用注解实现 @Component(value=”user”) //\u0026lt;bean id=”user” class=”” /\u0026gt; Public class User{ …… 创建对象有4个注解 注：功能一样 @Component @Controller @Service @Repository 创建对象是 单实例 还是多实例 @Scope(value=”prototype/singleton”) 注解注入属性 创建service类，创建dao类\n@Service(value=”userService”) Public class UserService{ //得到dao对象 //定义dao类型属性 //在dao属性上面使用注解 完成对象注入 @Autowired Private UserDao userDao; //使用注解方式的时候不需要使用set方法 Public void add(){ …… userDao.add(); } } 通过类名寻找对应的对象进来，自动注入/装配。 注入属性的两个对象\n@Autowired 自动装配\n@Resource(name) 注入指定对象，name为对象名\n配置文件和注解混合使用\n创建对象操作使用配置文件方式实现，然后注入属性的操作使用注解方式实现。\nAOP概念 AOP百度百科\nAOP：面向切面（方向）编程，扩展功能不修改源代码实现 AOP采取横向抽取机制，取代了传统纵向集成体系重复性代码（性能监视、事务管理、安全检查、缓存） AOP原理： 原理图 横向机制： 无接口情况： 使用动态代理实现。\nAOP术语 Joinpoint(连接点):所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点. 类里面哪些方法可以被增强，这些方法被称为连接点。 Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义. 在类里面可以有很多的方法被增强，比如实际操作中，只是增强了类里面add方法和update方法，实际增强的方法被称为切入点 Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) 增强的逻辑，称为增强，比如扩展日志功能，这个日志功能称为增强 前置通知：在方法之前执行 后置通知：在方法之后执行 异常通知：方法出现异常 最终通知：在后置之后执行 环绕通知：在方法之前和之后执行 Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field.（一般不用） 用动态的方式向类中加属性/方法 Target(目标对象):代理的目标对象（要增强的类） Weaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程.spring采用动态代理织入，而AspectJ采用编译期织入和类装在期织入。 是把advice应用到target的过程 Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类 Aspect(切面): 是切入点和通知（引介）的结合 把增强应用到具体方法上面，把增强用到切入点的过程。 Spring的aop操作 在Spring里面进aop操作，使用aspectJ实现 aspectj不是spring的一部分，和spring一起使用进行aop操作 Spring2.0以后增加了对aspectj的支持 使用aspectj实现aop有两种方式 基于aspectj的xml配置 基于aspectj的注解方式 AOP操作准备 除了导入基本的jar包外，还需要导入aop相关的jar包。 创建spring核心配置文件，导入aop的约束 来源：https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html\n使用表达式配置切入点 切入点，实际增强的方法 常用的表达式 规则：execution(\u0026lt;访问修饰符\u0026gt;?\u0026lt;返回类型\u0026gt;\u0026lt;方法名\u0026gt;(\u0026lt;参数\u0026gt;)\u0026lt;异常\u0026gt;) execution(* cn.itcast.aop.Book.add(..)) 某个方法 execution(* cn.itcast.aop.Book.*(..)) 某个类中的所有方法 execution(* .(..)) //所有类中的所有方法 匹配所有save开头的方法execution(* save*(..)) Aspectj的aop操作 \u0026lt;!--配置对象--\u0026gt; \u0026lt;bean id=”book”\u0026amp;nbsp;class=”类”\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=”myBook”\u0026amp;nbsp;class=”类”\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--配置aop操作--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--配置切入点--\u0026gt; \u0026lt;aop:pointcut expression=”execution(* cn.itcast.aop.Book.*(..))”\u0026amp;nbsp;id=”pointcut1”\u0026amp;nbsp;/\u0026gt; \u0026lt;!--配置切面--\u0026gt; \u0026lt;aop:aspect ref=”myBook”\u0026gt; \u0026lt;!--配置增强类型 method，增强类里面使用哪个方法作为前置--\u0026gt; \u0026lt;!--前置--\u0026gt; \u0026lt;aop:before method=”before1”\u0026amp;nbsp;pointcut-ref=”pointcut1”/\u0026gt; \u0026lt;!--后置--\u0026gt; \u0026lt;aop:after-returning method=”after1”\u0026amp;nbsp;pointcut-ref=”pointcut1”\u0026amp;nbsp;/\u0026gt; \u0026lt;!--环绕--\u0026gt; \u0026lt;aop:around method=”around1”\u0026amp;nbsp;pointcut-ref=”pointcut1”\u0026amp;nbsp;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 环绕：\n//MyBook类 Public void around1(ProceedingJoinPoint proceedingJoinPoint){ //方法之前 System.out.println(“方法之前”); //执行被增强的方法 proceedingJoinPoint.proceed(); //方法之后 System.out.println(“方法之后”); } Log4j介绍 通过log4j可以看到程序运行过程中更详细的信息 经常使用log4j查看日志 使用 导入log4j的jar包 赋值log4j的配置文件，复制到src下面Log4j.properties 设置日志级别 info看到基本信息 debug 看到详细信息 Spring整合web项目演示 演示问题 每次访问action时，都会加载spring配置文件 action调用service，service调用dao\n解决方案\n在服务器启动的时候，创建对象加载配置文件。 底层使用监听器，servletcontext对象 在spring里面不需要我们自己写代码实现，帮忙封装\n封装了一个监听器，只需要配置监听器就可以了 需先导入整合web项目的jar包，spring-web \u0026lt;!--Web.xml--\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt; Org.springframework.web.context.ContextLoaderListener \u0026lt;/listener-class\u0026gt; \u0026lt;/listenner\u0026gt; 指定加载spring配置文件位置 ","permalink":"https://windypath.com/posts/spring_learning_notes/","summary":"[Spring]Spring学习笔记（一） Spring 概念 spring是开源轻量级框架 AOP：面向切面编程，扩展功能不是修改源代码实现 IOC ：控制反转，有一个类，在类里面有方法（不是静态方法） 把对象的创建通过spring配置创建类对象 一站式框架 三层： web层 springMVC Service层 ioc Dao层 jdbcTemplate spring版本 当前最新版本：https://projects.spring.io/spring-framework/#quick-start 官网建议用Maven/Gradle安装 Spring的ioc操作 把对象的创建交给spring进行管理 ioc操作两部分： Ioc的配置文件方式 Ioc的注解方式 IOC底层原理 ioc底层原理使用技术 xml配置文件 Dom4j解决xml 工厂设计模式 反射 IOC使用方法（简单样例）： 导入jar包（用Maven/Gradle直接导入） 编写要操作的类（简单的User类） 创建Spring配置文件，通过配置创建类： 在src下创建xml文件，官方建议为applicationContext.xml 引入schema约束，来源：https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html 要加入的代码 配置对象创建 \u0026lt;bean id=\u0026#34;对象名\u0026#34; class=\u0026#34;类的路径（org.springframework.abcdef）\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 编写测试代码 import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class testIOC { @Test public void testMain() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;a.xml\u0026#34;); Main m = (Main) context.getBean(\u0026#34;m\u0026#34;); System.out.println(m); m.add(); } } 注：Maven自带的Junit版本为3.","title":"[Spring]Spring学习笔记"},{"content":"作业要求实现《一种求解多维背包问题的混合分布估计算法_王凌》\n百度学术路径\n写这篇文章主要是因为，这论文的数据集实在是找不到，但最后我还是找到了。\nCSDN下载地址\n然后我还是实现了该论文的算法，虽然感觉还是有错，而且结果并不是很好看，但我就是要厚脸皮发出来给大家嘲笑。\n我实现的是SENTO2.DAT，最佳值为8722。\npackage eda2; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.FileWriter; import java.io.InputStreamReader; import java.io.IOException; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Random; import java.util.Set; import java.util.Map.Entry; public class eda { private int N;//最佳个体数 private int s;//搜索时的 private int Y;//初始步长 private int M;//种群规模 private double alpha;//学习因子 private int n;//物体个数 private double []p;//概率向量 private int[][] population; private int[][] popValue; private int bagNum;//维度(背包数) private int []bagCapacity; //核重 private int [][]r;//物体在不同维度上的价值 第一个 维度 第二个 维度值 private int []weigh; private int []popWeigh; private Map\u0026lt;Integer,Integer\u0026gt; collection; //10 2 50 40 0.1 public eda(int N,int s,int Y,int M,double alpha){ this.N = N; this.s = s; this.Y = Y; this.M = M; this.alpha = alpha; } //初始化读取数据 public void init(String filename)throws IOException{ //这里用来存放用于排序的Map，键为下标，值为权重和 collection = new HashMap\u0026lt;Integer,Integer\u0026gt;(); //读取文件内容所需要的两个参数，strbuff读取一行的内容， //strcol数组存储被空格键切割后的字符串 String strbuff; String []strcol; //将要读取的行数 int line; //读取数据的工具data初始化 BufferedReader data = new BufferedReader(new InputStreamReader( new FileInputStream(filename))); //读取第一行，背包数bagNum 和物体个数n strbuff = data.readLine(); strcol = strbuff.split(\u0026#34; \u0026#34;); bagNum = Integer.valueOf(strcol[0]); n = Integer.valueOf(strcol[1]); //利用这两个数字初始化将要用到的数组 p = new double[n]; population = new int[M][n]; r = new int[bagNum][n]; bagCapacity = new int[bagNum]; popValue = new int[M][bagNum]; weigh = new int[n]; popWeigh = new int[M]; //文件中的第二部分为物体对应权重表 //找到行数有多少行 if(n % 10 == 0){ line = n / 10; }else{ line = n / 10 + 1; } int weighIndex = 0; for(int l = 0;l \u0026lt; line;l++){ strbuff = data.readLine(); strcol = strbuff.split(\u0026#34; \u0026#34;); for(int index = 0;index \u0026lt; strcol.length;index++){ weigh[weighIndex] = Integer.valueOf(strcol[index]); weighIndex++; } } //文件第三部分为背包容量大小表 if(bagNum % 10 == 0){ line = bagNum / 10; }else{ line = bagNum / 10 + 1; } int bagIndex = 0; for(int l = 0;l \u0026lt; line;l++){ strbuff = data.readLine(); strcol = strbuff.split(\u0026#34; \u0026#34;); for(int index = 0;index \u0026lt; strcol.length;index++){ bagCapacity[bagIndex] = Integer.valueOf(strcol[index]); bagIndex++; } } //文件的第四部分为，各背包的维度值（有很多，两层循环呢） if(n % 10 == 0){ line = n / 10; }else{ line = n / 10 + 1; } for(int b = 0;b \u0026lt; bagNum;b++){ int thingIndex = 0; for(int l = 0;l \u0026lt; line;l++){ strbuff = data.readLine(); strcol = strbuff.split(\u0026#34; \u0026#34;); for(int index = 0;index \u0026lt; strcol.length;index++){ r[b][thingIndex] = Integer.valueOf(strcol[index]); thingIndex++; } } } data.close(); } //Step1.初始化概率向量p(x) private void initP(){ // System.out.println(\u0026#34;Step1.初始化概率向量p(x)\u0026#34;); for(int i = 0;i \u0026lt; n;i++){ p[i] = 0.5; } } //Step2.对p(x)进行随机采样，产生M个个体 private void sampling(){ // System.out.println(\u0026#34;Step2.对p(x)进行随机采样，产生M个个体\u0026#34;); Random R = new Random(); for(int i = 0;i \u0026lt; M;i++){ for(int j = 0;j \u0026lt; n;j++){ if(R.nextDouble() \u0026lt; p[j]){ population[i][j] = 1; }else{ population[i][j] = 0; } } } } //修复不可行解，计算适应值 private void repairAndCalculate(){ // System.out.println(\u0026#34;修复不可行解，计算适应值\u0026#34;); //对每个个体实施遍历 for(int i = 0;i \u0026lt; M;i++){ //每个个体对应bagNum个维度 for(int b = 0;b \u0026lt; bagNum;b++){ //每个维度的值求和 popValue[i][b] = 0; for(int j = 0;j \u0026lt; n;j++){ //x * r popValue[i][b] += population[i][j] * r[b][j]; } //如果在某个维度上非法，则将某些物体扔掉 int index = 0; while(popValue[i][b] \u0026gt; bagCapacity[b]){ if(population[i][index] == 1){ population[i][index] = 0; popValue[i][b] -= r[b][index]; } index++; } } //补维度值，趋近最优 //从后往前遍历物体 for(int j = n - 1;j \u0026gt;= 0;j--){ //如果没被选上，则尝试选上它，观察是否会超过某个维度， //如果通过，则加上去。 if(population[i][j] == 0){ boolean ok = true; for(int b = 0;b \u0026lt; bagNum;b++){ //非法 if(bagCapacity[b] \u0026lt; popValue[i][b] + r[b][j]){ ok = false; break; } } if(ok == true){ for(int b = 0;b \u0026lt; bagNum;b++){ popValue[i][b] += r[b][j]; } } } } //权重求和 popWeigh[i] = 0; for(int j = 0;j \u0026lt; n;j++){ if(population[i][j] == 1){ popWeigh[i] += weigh[j]; } } collection.put(new Integer(i),new Integer(popWeigh[i])); } } private void repair(int i){ //System.out.println(\u0026#34;修复第\u0026#34;+i+\u0026#34;行\u0026#34;); for(int b = 0;b \u0026lt; bagNum;b++){ //每个维度的值求和 popValue[i][b] = 0; for(int j = 0;j \u0026lt; n;j++){ //x * r popValue[i][b] += population[i][j] * r[b][j]; } //如果在某个维度上非法，则将某些物体扔掉 int index = 0; while(popValue[i][b] \u0026gt; bagCapacity[b]){ if(population[i][index] == 1){ population[i][index] = 0; popValue[i][b] -= r[b][index]; } index++; } } //补维度值，趋近最优 //从后往前遍历物体 for(int j = n - 1;j \u0026gt;= 0;j--){ //如果没被选上，则尝试选上它，观察是否会超过某个维度， //如果通过，则加上去。 if(population[i][j] == 0){ boolean ok = true; for(int b = 0;b \u0026lt; bagNum;b++){ //非法 if(bagCapacity[b] \u0026lt; popValue[i][b] + r[b][j]){ ok = false; break; } } if(ok == true){ for(int b = 0;b \u0026lt; bagNum;b++){ popValue[i][b] += r[b][j]; } } } } } private void choose(){ // System.out.println(\u0026#34;选择新解\u0026#34;); List\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt;(collection.entrySet()); collection.clear(); Collections.sort(list,new Comparator\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt;() { //降序排序 @Override public int compare(Entry\u0026lt;Integer, Integer\u0026gt; o1, Entry\u0026lt;Integer, Integer\u0026gt; o2) { return o2.getValue().compareTo(o1.getValue()); } }); int [][]tempPop = new int[N][n]; int index = 0; for(Map.Entry\u0026lt;Integer, Integer\u0026gt; mapping : list){ if(index \u0026lt; N){ for(int i = 0;i \u0026lt; n;i++){ tempPop[index][i] = population[mapping.getKey().intValue()][i]; } index++; }else{ break; } } for(int i = 0;i \u0026lt; N;i++){ for(int j = 0;j \u0026lt; n;j++){ population[i][j] = tempPop[i][j]; } } } private void updateProbability(){ for(int j = 0;j \u0026lt; n;j++){ int bags = 0; for(int i = 0;i \u0026lt; N;i++){ if(population[i][j] == 1){ bags++; } } p[j] = ((1 - alpha)*p[j])+(alpha * ((double)bags / N)); } } private void bestSelect(){ // System.out.println(\u0026#34;查找第一行\u0026#34;); Random R = new Random(); int one = 0,zero = 0; Set\u0026lt;Integer\u0026gt; integers = new HashSet\u0026lt;Integer\u0026gt;(); while(true){ int id = R.nextInt(n); if(!integers.contains(new Integer(id))){ // System.out.println(\u0026#34;未存在\u0026#34;+id); if(population[0][id] == 0){ population[0][id] = 1; if(zero \u0026lt; (s+1)) zero++; integers.add(new Integer(id)); }else{ population[0][id] = 0; if(one \u0026lt; s){ one++; } integers.add(new Integer(id)); } } //s个从1到0 s+1个从0到1 if(one == s \u0026amp;\u0026amp; zero == (s+1)){ break; } } repair(0); } public int getWeigh(int i){ int theWeigh = 0; for(int j = 0;j \u0026lt; n;j++){ if(population[0][j] == 1){ theWeigh += weigh[j]; } } return theWeigh; } public void print(){ System.out.println(bagNum + \u0026#34; \u0026#34;+n); for(int i = 0;i \u0026lt; n;i++){ System.out.print(weigh[i]+\u0026#34; \u0026#34;); if((i+1) % 10 == 0){ System.out.println(); } } for(int i = 0;i \u0026lt; bagNum;i++){ System.out.print(bagCapacity[i]+\u0026#34; \u0026#34;); if((i+1) % 10 == 0){ System.out.println(); } } for(int b = 0;b \u0026lt; bagNum;b++){ for(int j = 0;j \u0026lt; n;j++){ System.out.print(r[b][j] + \u0026#34; \u0026#34;); if((j+1) % 10 == 0){ System.out.println(); } } if(n % 10 != 0){ System.out.println(); } } } public void start(String filename,int endTimes) throws IOException{ BufferedWriter writer = new BufferedWriter( new FileWriter(new File(filename))); initP(); int maxWeigh = 0; for(int time = 0;time \u0026lt; endTimes;time++){ sampling(); repairAndCalculate(); choose(); int nowWeigh = getWeigh(0); if(maxWeigh \u0026lt; nowWeigh){ maxWeigh = nowWeigh; } writer.write(\u0026#34;第\u0026#34;+(time+1)+\u0026#34;次时最佳\u0026#34;+maxWeigh); writer.newLine(); for(int i = 0;i \u0026lt; 50+(time/20);i++){ bestSelect(); } updateProbability(); } writer.close(); } public static void main(String[] args) throws IOException { //10 2 50 40 0.1 eda e = new eda(10,2,50,40,0.1); e.init(\u0026#34;d://SENTO2.DAT\u0026#34;); e.start(\u0026#34;d://result.txt\u0026#34;,20000); } } 最后我实现的结果大概在8400到8600之间。\n实验结果截图： 结果一般，但还是收获良多。本次主要是提供数据集的下载。谢谢大家。\n如对代码有疑惑可以前往 联系我们 和我交流，评论已经关闭，首页置顶的帖子不要理。\n","permalink":"https://windypath.com/posts/distribution_estimation_algorithm/","summary":"作业要求实现《一种求解多维背包问题的混合分布估计算法_王凌》\n百度学术路径\n写这篇文章主要是因为，这论文的数据集实在是找不到，但最后我还是找到了。\nCSDN下载地址\n然后我还是实现了该论文的算法，虽然感觉还是有错，而且结果并不是很好看，但我就是要厚脸皮发出来给大家嘲笑。\n我实现的是SENTO2.DAT，最佳值为8722。\npackage eda2; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.FileWriter; import java.io.InputStreamReader; import java.io.IOException; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Random; import java.util.Set; import java.util.Map.Entry; public class eda { private int N;//最佳个体数 private int s;//搜索时的 private int Y;//初始步长 private int M;//种群规模 private double alpha;//学习因子 private int n;//物体个数 private double []p;//概率向量 private int[][] population; private int[][] popValue; private int bagNum;//维度(背包数) private int []bagCapacity; //核重 private int [][]r;//物体在不同维度上的价值 第一个 维度 第二个 维度值 private int []weigh; private int []popWeigh; private Map\u0026lt;Integer,Integer\u0026gt; collection; //10 2 50 40 0.","title":"[算法]分布估计算法 - 一种求解多维背包问题的混合分布估计算法_王凌"},{"content":" 我做独立博客的原因 记得以前有看到一篇由独立博客站长的博文，介绍独立博客如何搭建，搭建完后的注意事项。其中就有说到独立博客上线后，可以发布一篇《我为什么要做独立博客》的博文。而我认为这个题目是一个问句，自问自答略显古怪。所以我的这篇文章的名字就是《我做独立博客的原因》。\n当我与好友聊起最近为了wordpress的主题与其插件不兼容而必须修改代码焦头烂额时，他反问我：“做博客的话新浪博客不就可以了吗？”我犹豫了一会儿。是的，新浪博客的模板完全免费，有很多的各界大牛，多种多样的功能，与微博绑定且只要开通发几篇像模像样的文章，就很快会被搜索引擎收录。而且也因为与微博绑定，只要一发布，刷微博的好友们马上能看见，这是十分便利的，都不需要自己做SEO优化网站。\n可是，我从很早以前就很想自己搭建一个网站了。14岁那年自己偷偷借书用Dreamweaver 8写一个魔兽争霸战队的官方网站，但我完全是像做word一样在写静态网站，且对网站的配色没有系统的学习，做出来几个静态页面，不伦不类。然而最重要的是，我并不会写动态的代码，甚至于对数据库等一无所知。后来慢慢了解access可以装在网站文件目录下，拼命地寻找免费空间。但那个时候，免费空间都是吸引客户的手段，或者是骗取身份信息。我不是什么天才，也没有足够的时间去学习这部分知识。在我父母与我自己的眼中这就是在玩而已，与学习毫无关系。因此ASP的代码对于14岁的孩子实在太过深奥。\n今年18周岁了，我还是不会ASP，但是我已经知道借助程序搭建一个网站。虽然这并非我的本意。我明白开源的wordpress背后有多少人为它编写主题与插件，使它成为一个优秀的博客，甚至不仅是博客，也是CMS的建站平台。我下一步的目标是要自己写一个主题，编写几个插件，最后自己从头开始写自己的Blog程序。\n我会在独立博客中发布什么样的文章？ 目前分为三类：日常、转载、读后感。我在平时对于生活有着许多感悟，我需要一个平台来倾诉。因此这是必不可少的。因为我觉得自己的文字过于稚嫩，所以我会转载一些别人的优秀文章来丰富自己的博客。读后感是我对书的感悟。我不是个喜欢读书的人，但我明白读书的重要性，甚至我认为不读好书，思维会停滞不前，思想滞后是十分可怕的。\n目前我自己写的文章水平不高，文笔稚嫩，各位看官若是看到不好的地方请务必指正。不要顾及情面，毕竟人只有犯错才会进步。作为一个刚刚成年、稚气未脱的大男孩，我现在无法去装成熟，或者说我必须经历时间的洗礼才能渐渐成熟。\n在我的水平渐渐提高后，我会在建一个文章分类，专门收录自己的原创文章。\n另外，我会涉猎视频制作，也许再过几个月大家就能看到我制作的视频了。\n最后，用一句罗永浩的话来表达我现在的感受：\n我不是为了输赢，我就是认真。\n","permalink":"https://windypath.com/posts/why_i_build_blog/","summary":"我做独立博客的原因 记得以前有看到一篇由独立博客站长的博文，介绍独立博客如何搭建，搭建完后的注意事项。其中就有说到独立博客上线后，可以发布一篇《我为什么要做独立博客》的博文。而我认为这个题目是一个问句，自问自答略显古怪。所以我的这篇文章的名字就是《我做独立博客的原因》。\n当我与好友聊起最近为了wordpress的主题与其插件不兼容而必须修改代码焦头烂额时，他反问我：“做博客的话新浪博客不就可以了吗？”我犹豫了一会儿。是的，新浪博客的模板完全免费，有很多的各界大牛，多种多样的功能，与微博绑定且只要开通发几篇像模像样的文章，就很快会被搜索引擎收录。而且也因为与微博绑定，只要一发布，刷微博的好友们马上能看见，这是十分便利的，都不需要自己做SEO优化网站。\n可是，我从很早以前就很想自己搭建一个网站了。14岁那年自己偷偷借书用Dreamweaver 8写一个魔兽争霸战队的官方网站，但我完全是像做word一样在写静态网站，且对网站的配色没有系统的学习，做出来几个静态页面，不伦不类。然而最重要的是，我并不会写动态的代码，甚至于对数据库等一无所知。后来慢慢了解access可以装在网站文件目录下，拼命地寻找免费空间。但那个时候，免费空间都是吸引客户的手段，或者是骗取身份信息。我不是什么天才，也没有足够的时间去学习这部分知识。在我父母与我自己的眼中这就是在玩而已，与学习毫无关系。因此ASP的代码对于14岁的孩子实在太过深奥。\n今年18周岁了，我还是不会ASP，但是我已经知道借助程序搭建一个网站。虽然这并非我的本意。我明白开源的wordpress背后有多少人为它编写主题与插件，使它成为一个优秀的博客，甚至不仅是博客，也是CMS的建站平台。我下一步的目标是要自己写一个主题，编写几个插件，最后自己从头开始写自己的Blog程序。\n我会在独立博客中发布什么样的文章？ 目前分为三类：日常、转载、读后感。我在平时对于生活有着许多感悟，我需要一个平台来倾诉。因此这是必不可少的。因为我觉得自己的文字过于稚嫩，所以我会转载一些别人的优秀文章来丰富自己的博客。读后感是我对书的感悟。我不是个喜欢读书的人，但我明白读书的重要性，甚至我认为不读好书，思维会停滞不前，思想滞后是十分可怕的。\n目前我自己写的文章水平不高，文笔稚嫩，各位看官若是看到不好的地方请务必指正。不要顾及情面，毕竟人只有犯错才会进步。作为一个刚刚成年、稚气未脱的大男孩，我现在无法去装成熟，或者说我必须经历时间的洗礼才能渐渐成熟。\n在我的水平渐渐提高后，我会在建一个文章分类，专门收录自己的原创文章。\n另外，我会涉猎视频制作，也许再过几个月大家就能看到我制作的视频了。\n最后，用一句罗永浩的话来表达我现在的感受：\n我不是为了输赢，我就是认真。","title":"[日常]我做独立博客的原因"},{"content":"最近在看 想想就开心！ 尊重自己：给予与接收的心灵艺术 最重要的事，只有一件 最喜欢的书籍 深入理解计算机系统 想想就开心！ 人间值得 被讨厌的勇气 ","permalink":"https://windypath.com/mybooks/","summary":"最近在看 想想就开心！ 尊重自己：给予与接收的心灵艺术 最重要的事，只有一件 最喜欢的书籍 深入理解计算机系统 想想就开心！ 人间值得 被讨厌的勇气 ","title":"藏书"},{"content":"95后，男，FJNU，福建厦门人，现居上海；\n小时候玩电脑游戏总是输给别人，突然对网页来了兴趣，保存网页瞎改然后打开看到文字改变，实在是兴奋不已。为了拥有无限的使用电脑的时间，我毅然决然报考计算机专业。\n未曾想做着做着成了游戏服务器开发，在《权力的游戏 凛冬将至》亚太版项目组一晃两年半过去，独立维护服务器长达半年之久，是“北境王国守夜人”。\n我将在这里记录自己一步步成长的过程。\n联系方式 Email: windypathblog@gmail.com Telegram: @windypath\n","permalink":"https://windypath.com/about/","summary":"95后，男，FJNU，福建厦门人，现居上海；\n小时候玩电脑游戏总是输给别人，突然对网页来了兴趣，保存网页瞎改然后打开看到文字改变，实在是兴奋不已。为了拥有无限的使用电脑的时间，我毅然决然报考计算机专业。\n未曾想做着做着成了游戏服务器开发，在《权力的游戏 凛冬将至》亚太版项目组一晃两年半过去，独立维护服务器长达半年之久，是“北境王国守夜人”。\n我将在这里记录自己一步步成长的过程。\n联系方式 Email: windypathblog@gmail.com Telegram: @windypath","title":"关于"},{"content":"工作技能 编程语言: Golang, Java, Kotlin, Python, Shell, SQL\n技术栈: Akka, MongoDB, MySQL, Redis, SpringBoot\n英语：大学英语六级（CET-6）\n工作经历 字节投资的2年创业公司 类征途MMO Golang服务器开发工程师 上海 类征途MMO是一款多人国战MMORPG网络游戏，目前已在微信小程序测试中。 2023年9月 – 2023年11月\n主要负责工作：\n使用 Golang 开发敏感词检测模块，读取100,000条敏感词，构建敏感词检测 Trie 字典树并将其缓存到二进制文件，实现毫秒内完成敏感词匹配，与 Github 其他同类模块（importcjj/sensitive，antlinker/go-dirtyfilter ）相比匹配速度快25%； 快速上手 Mqant 微服务框架，熟悉进程间通信机制，配合使用 MongoDB和 Redis ，开发 MMORPG 战场玩法，实现100名玩家同屏争夺首领尾刀奖励的功能； 配合策划开发新功能，管理员玩家能够将地图内 NPC 外观替换为指定玩家外观。同时快速熟悉玩家的养成维度，整理任务类型，和策划配合完善玩家养成模块的开发，包括新手任务、主线任务、礼包、活动等。 某上市游戏公司 SLG手游 Java服务器开发执行主程序 上海 SLG手游是一款战争策略SLG网络游戏，目前已在Google Play上架3年。 2020年12月 – 2023年5月\n主要负责工作：\n深入参与 SLG 游戏的沙盘玩法开发，包含大地图 AOI 算法和状态同步功能，优化行军及行军线、怪物刷新循环、AI 行为等大功能模块； 精通 Java 。就职期间基于 Akka Cluster 微服务框架开发服务器，使用 MySQL和 Redis 存储服务器数据。主导了一个大型跨服副本玩法的实现（百名玩家同地图抢怪），完成其中的玩家匹配功能和 Boss 特殊争夺机制（驻扎积攒势力值，满足条件后才可攻击）； 与策划协作进行战斗模块的开发和优化，实现多种新技能机制，简化战斗协议数据结构，实现战报大小缩减10%。协助策划打印线上战报信息，排查战斗 Bug 。完善了内城养成模块（英雄、装备、科技、任务等）及外城沙盘玩法，开发了老玩家回归活动； 为了提升开发效率，增加测试时间，重构了项目已有的活动框架代码，去除冗余结构。在不影响线上游戏运营的情况下，节约了开发时间，重构后，活动开发时间缩短一半； 拥有丰富的线上问题排查经验，善于从玩家反馈、后台日志、代码和配置表中找到问题所在。配合运维跟进版本的更新，监控服务器环境和日志，随时解决问题； 工作态度认真负责，及时排查和修复线上 Bug，7*24小时监听线上客服反馈。于2022年9月起独立负责服务器开发，且负责期间无线上重大 Bug 发生。 某创业板上市公司 云API接口开放平台 Vue + SpringBoot全栈开发 福建厦门 整合集团各个子公司提供的API接口到一个统一的平台中进行管理和使用。 2019年5月 – 2020年11月\n负责工作：\n参与开发外部接口的安全传输功能。使用 OAuth 2.0协议标准生成 access_token ，用 Redis 暂存 access_token 并设置过期时间，使用 RSA与 AES 加密算法保证安全传输； 使用 Vue + SpringBoot 开发 API 接口的管理系统，并将用户数据信息及接口使用情况统计存储在 MySQL中； 负责版本更新，使用 Nginx 反向代理将其部署到服务器。 教育经历 2015年9月 - 2019年6月 非985 211本科 软件工程 本科 GPA:3.31/5.0 (专业前8%)\n","permalink":"https://windypath.com/resume/","summary":"工作技能 编程语言: Golang, Java, Kotlin, Python, Shell, SQL\n技术栈: Akka, MongoDB, MySQL, Redis, SpringBoot\n英语：大学英语六级（CET-6）\n工作经历 字节投资的2年创业公司 类征途MMO Golang服务器开发工程师 上海 类征途MMO是一款多人国战MMORPG网络游戏，目前已在微信小程序测试中。 2023年9月 – 2023年11月\n主要负责工作：\n使用 Golang 开发敏感词检测模块，读取100,000条敏感词，构建敏感词检测 Trie 字典树并将其缓存到二进制文件，实现毫秒内完成敏感词匹配，与 Github 其他同类模块（importcjj/sensitive，antlinker/go-dirtyfilter ）相比匹配速度快25%； 快速上手 Mqant 微服务框架，熟悉进程间通信机制，配合使用 MongoDB和 Redis ，开发 MMORPG 战场玩法，实现100名玩家同屏争夺首领尾刀奖励的功能； 配合策划开发新功能，管理员玩家能够将地图内 NPC 外观替换为指定玩家外观。同时快速熟悉玩家的养成维度，整理任务类型，和策划配合完善玩家养成模块的开发，包括新手任务、主线任务、礼包、活动等。 某上市游戏公司 SLG手游 Java服务器开发执行主程序 上海 SLG手游是一款战争策略SLG网络游戏，目前已在Google Play上架3年。 2020年12月 – 2023年5月\n主要负责工作：\n深入参与 SLG 游戏的沙盘玩法开发，包含大地图 AOI 算法和状态同步功能，优化行军及行军线、怪物刷新循环、AI 行为等大功能模块； 精通 Java 。就职期间基于 Akka Cluster 微服务框架开发服务器，使用 MySQL和 Redis 存储服务器数据。主导了一个大型跨服副本玩法的实现（百名玩家同地图抢怪），完成其中的玩家匹配功能和 Boss 特殊争夺机制（驻扎积攒势力值，满足条件后才可攻击）； 与策划协作进行战斗模块的开发和优化，实现多种新技能机制，简化战斗协议数据结构，实现战报大小缩减10%。协助策划打印线上战报信息，排查战斗 Bug 。完善了内城养成模块（英雄、装备、科技、任务等）及外城沙盘玩法，开发了老玩家回归活动； 为了提升开发效率，增加测试时间，重构了项目已有的活动框架代码，去除冗余结构。在不影响线上游戏运营的情况下，节约了开发时间，重构后，活动开发时间缩短一半； 拥有丰富的线上问题排查经验，善于从玩家反馈、后台日志、代码和配置表中找到问题所在。配合运维跟进版本的更新，监控服务器环境和日志，随时解决问题； 工作态度认真负责，及时排查和修复线上 Bug，7*24小时监听线上客服反馈。于2022年9月起独立负责服务器开发，且负责期间无线上重大 Bug 发生。 某创业板上市公司 云API接口开放平台 Vue + SpringBoot全栈开发 福建厦门 整合集团各个子公司提供的API接口到一个统一的平台中进行管理和使用。 2019年5月 – 2020年11月","title":"简历"},{"content":" ","permalink":"https://windypath.com/myfriends/","summary":" ","title":"朋友"}]