<!doctype html><html lang=en dir=auto><head><style></style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e);const t=document.createElement("link");t.href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&&display=swap",t.type="text/css",t.rel="stylesheet",document.head.appendChild(t)})()</script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Various Locking Mechanisms in Java Concurrency Programming | WindyPath - Study And Practice, Years Of It</title>
<meta name=keywords content><meta name=description content="Introduction: This article aims to introduce the relevant usage of synchronized, ReentrantLock, and Condition in Java.
Locking with Synchronized Synchronized can be applied to instance methods, static methods, and code blocks. When used to modify a code block, it can either lock on a specific object or on a class (.class).
Synchronized is a Non-Fair Lock The following code utilizes synchronized to lock on a variable accessible by multiple threads, achieving the orderly printing of numbers."><meta name=author content="JohnathanLin"><link rel=canonical href=https://windypath.com/en/posts/java_juc_briefly/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2f177b1b6eb79e1631c2df839a71d75010d40323c2f391bcbd4fa49da11a1334.css integrity="sha256-Lxd7G263nhYxwt+DmnHXUBDUAyPC85G8vU+knaEaEzQ=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://windypath.com/posts/java_juc_briefly/><link rel=alternate hreflang=en href=https://windypath.com/en/posts/java_juc_briefly/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Various Locking Mechanisms in Java Concurrency Programming"><meta property="og:description" content="Introduction: This article aims to introduce the relevant usage of synchronized, ReentrantLock, and Condition in Java.
Locking with Synchronized Synchronized can be applied to instance methods, static methods, and code blocks. When used to modify a code block, it can either lock on a specific object or on a class (.class).
Synchronized is a Non-Fair Lock The following code utilizes synchronized to lock on a variable accessible by multiple threads, achieving the orderly printing of numbers."><meta property="og:type" content="article"><meta property="og:url" content="https://windypath.com/en/posts/java_juc_briefly/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-04T17:27:44+08:00"><meta property="article:modified_time" content="2023-12-04T17:27:44+08:00"><meta property="og:site_name" content="Windypath"><meta name=twitter:card content="summary"><meta name=twitter:title content="Various Locking Mechanisms in Java Concurrency Programming"><meta name=twitter:description content="Introduction: This article aims to introduce the relevant usage of synchronized, ReentrantLock, and Condition in Java.
Locking with Synchronized Synchronized can be applied to instance methods, static methods, and code blocks. When used to modify a code block, it can either lock on a specific object or on a class (.class).
Synchronized is a Non-Fair Lock The following code utilizes synchronized to lock on a variable accessible by multiple threads, achieving the orderly printing of numbers."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windypath.com/en/posts/"},{"@type":"ListItem","position":2,"name":"Various Locking Mechanisms in Java Concurrency Programming","item":"https://windypath.com/en/posts/java_juc_briefly/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Various Locking Mechanisms in Java Concurrency Programming","name":"Various Locking Mechanisms in Java Concurrency Programming","description":"Introduction: This article aims to introduce the relevant usage of synchronized, ReentrantLock, and Condition in Java.\nLocking with Synchronized Synchronized can be applied to instance methods, static methods, and code blocks. When used to modify a code block, it can either lock on a specific object or on a class (.class).\nSynchronized is a Non-Fair Lock The following code utilizes synchronized to lock on a variable accessible by multiple threads, achieving the orderly printing of numbers.","keywords":[],"articleBody":" Introduction: This article aims to introduce the relevant usage of synchronized, ReentrantLock, and Condition in Java.\nLocking with Synchronized Synchronized can be applied to instance methods, static methods, and code blocks. When used to modify a code block, it can either lock on a specific object or on a class (.class).\nSynchronized is a Non-Fair Lock The following code utilizes synchronized to lock on a variable accessible by multiple threads, achieving the orderly printing of numbers. Additionally, it calculates the frequency of number printing for different threads:\npackage com.windypath.lockcondition; public class Syn { int count = 0; final Object sth = new Object(); void play() { int loopTimes = 1000; SynThread t1 = new SynThread(loopTimes, \"t1\"); SynThread t2 = new SynThread(loopTimes, \"t2\"); SynThread t3 = new SynThread(loopTimes, \"t3\"); SynThread t4 = new SynThread(loopTimes, \"t4\"); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Syn syn = new Syn(); syn.play(); } class SynThread extends Thread { int loopTimes; public SynThread(int loopTimes, String threadName) { super(threadName); this.loopTimes = loopTimes; } @Override public void run() { int times = 0; while (count \u003c= 200000) { synchronized (sth) { count++; // System.out.println(getName() + \" 输出 \" + count); times++; } } System.out.println(getName() + \"一共输出了 \" + times + \" 次\"); } } } Output：\nt2一共输出了 103061 次 t1一共输出了 37174 次 t4一共输出了 33751 次 t3一共输出了 26018 次 It can be observed that the number of times thread t2 outputs is more than the sum of the other three threads. This is because synchronized is a non-fair lock.\nSynchronized’s Waiting Queue The waiting queue for an object locked with synchronized is located in the _waitSet of the ObjectMonitor. This ObjectMonitor is a low-level native (C/C++) component.\nSynchronized Lock Upgrade However, heavyweight locks are not acquired right from the start. Instead, the optimization begins with biased locking. It only upgrades to lightweight locks in the presence of contention, and only when numerous threads are involved in lock contention does it escalate from a lightweight lock to a heavyweight lock.\nThe locked object uses the MarkWord in its object header to store lock information.\nThe storage structure of a Java object in memory consists of three parts:\nObject header Instance variables Padding bytes Among them, the object header mainly stores some runtime data:\nMarkWord Class Metadata Address (points to the object type data) Array Length (if it’s an array, it records the length) The lock information is recorded in the MarkWord of the object header. The following diagram illustrates the different bits of information in the MarkWord for different locks: Biased Lock Biased locking is designed to avoid the resource consumption associated with higher-level locks, such as lightweight locks, when a lock is acquired in a non-multithreaded environment. The term “biased” means that the locked object is biased toward a specific thread. Its object header stores the ID of the biased thread.\nLightweight Lock The lightweight lock is not intended to replace heavyweight locks. Its purpose is to reduce the performance overhead incurred by traditional heavyweight locks in the absence of multithreaded competition. Before explaining the execution process of the lightweight lock, it’s essential to understand that the lightweight lock is suitable for scenarios where threads alternately execute synchronized blocks. Differences Between Lightweight Lock and Biased Lock The process of acquiring a lightweight lock involves multiple CAS (Compare-And-Swap) operations, whereas a biased lock requires only one CAS operation. Lightweight locks are suitable for scenarios where threads alternately execute synchronized blocks. In contrast, biased locks are designed to further improve performance when only one thread executes the synchronized block.\nObservation of Synchronized Lock Escalation Attempt to use an object, and have multiple threads acquire and release a synchronized lock on it at different time intervals to observe its lock state.\nthread1: Acquires and releases immediately.\nthread2: Waits 500ms to acquire, then holds for 1500ms before releasing.\nthread3: Waits 1000ms to acquire, then releases immediately.\nAt this point, there will be lock contention between thread2 and thread3.\nSource Code：\npackage com.windypath; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.openjdk.jol.info.ClassLayout; /** * * Observing the process of synchronized transitioning from biased lock to lightweight lock to heavyweight lock. * Using log4j2 */ public class BiasdLock { final static Logger log = LogManager.getLogger(); public static void main(String[] args) throws InterruptedException { log.debug(Thread.currentThread().getName() + \"最开始的状态:\\n\" + ClassLayout.parseInstance(new Object()).toPrintable()); // After starting, the HotSpot Virtual Machine has a 4-second delay before enabling biased locking mode for each newly created object. Thread.sleep(4000); // 创建一个对象，用于多个不同的线程上锁用 Object obj = new Object(); log.debug(Thread.currentThread().getName() + \"等待4秒后的状态（新对象）:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); //线程1，马上上锁马上释放 new Thread(() -\u003e { log.debug( Thread.currentThread().getName() + \"开始执行准备获取锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); synchronized (obj) { log.debug(Thread.currentThread().getName() + \"获取锁执行中:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); } log.debug(Thread.currentThread().getName() + \"释放锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); }, \"thread1\").start(); // 线程2，等线程1释放锁后再上锁 new Thread(() -\u003e { try { Thread.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } log.debug( Thread.currentThread().getName() + \"开始执行准备获取锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); synchronized (obj) { log.debug(Thread.currentThread().getName() + \"获取锁执行中:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); try { Thread.sleep(1500); } catch (InterruptedException e) { throw new RuntimeException(e); } } log.debug(Thread.currentThread().getName() + \"释放锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); }, \"thread2\").start(); // 线程3，在线程2拥有锁的时候尝试上锁 new Thread(() -\u003e { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } log.debug( Thread.currentThread().getName() + \"开始执行准备获取锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); synchronized (obj) { log.debug(Thread.currentThread().getName() + \"获取锁执行中:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); } log.debug(Thread.currentThread().getName() + \"释放锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); }, \"thread3\").start(); //主线程等待所有线程运行结束，查看状态 Thread.sleep(5000); log.debug(Thread.currentThread().getName() + \"结束状态:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); } } Output(Briefly):\n15:53:58.436 [main] main最开始的状态:non-biasable 15:54:02.854 [main] 等待4秒后的状态（新对象）:biasable 15:54:02.858 [thread1] thread1开始执行准备获取锁:biasable 15:54:02.858 [thread1] thread1获取锁执行中:biased 15:54:02.859 [thread1] thread1释放锁:biased 15:54:03.367 [thread2] thread2开始执行准备获取锁:biased 15:54:03.368 [thread2] thread2获取锁执行中:thin lock 15:54:03.869 [thread3] thread3开始执行准备获取锁:thin lock 15:54:04.872 [thread3] thread3获取锁执行中:fat lock 15:54:04.872 [thread2] thread2释放锁:fat lock 15:54:04.873 [thread3] thread3释放锁:fat lock 15:54:07.868 [main] main结束状态:non-biasable The following conclusions can be drawn from the analysis:\nFor the HotSpot Virtual Machine, objects created immediately after startup are non-biasable. Objects created after 4 seconds are biasable. When thread1 acquires the lock, as there is only one thread holding the synchronized lock for this object, it transitions to the biased lock state. When thread1 releases the lock, the lock object remains in the biased lock state and does not revert to biasable. After 500ms, when thread2 acquires the lock, the lock object’s state is upgraded to a lightweight lock. Another 500ms later, when thread3 also attempts to acquire the lock, its state is lightweight lock (thin lock) until it executes the synchronized block. It then blocks until thread2 releases the lock, at which point it immediately acquires the lock (the timestamps in the third and fourth lines are exactly the same, both 15:54:04.872). Thread3 releases the lock immediately, at this moment, it is still a heavyweight lock. After the main thread waits for 5 seconds, the lock state is restored but becomes non-biasable. You can try commenting out the earlier 4-second delay; in this case, the object would immediately acquire a lightweight lock. Locking with ReentrantLock ReentrantLock is a lightweight, reentrant lock. It can be specified as a fair lock during creation. ReentrantLock can be used in conjunction with Condition. It provides several functions related to concurrent programming, offering higher flexibility compared to synchronized.\nReentrantLock supports whether the lock is fair. In addition to the regular lock() function, ReentrantLock also provides tryLock() for polling and lockInterruptibly() for interruptible locking. After acquiring a lock with ReentrantLock, you can wait on different conditions based on your business logic. ReentrantLock can be used as a fair lock. package com.windypath.lockcondition; import java.util.concurrent.locks.ReentrantLock; public class Reen { int count = 0; final ReentrantLock lock = new ReentrantLock(true); void play() { int loopTimes = 1000; ReenThread t1 = new ReenThread(loopTimes, \"t1\"); ReenThread t2 = new ReenThread(loopTimes, \"t2\"); ReenThread t3 = new ReenThread(loopTimes, \"t3\"); ReenThread t4 = new ReenThread(loopTimes, \"t4\"); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Reen reen = new Reen(); reen.play(); } class ReenThread extends Thread { int loopTimes; public ReenThread(int loopTimes, String threadName) { super(threadName); this.loopTimes = loopTimes; } @Override public void run() { int times = 0; while (count \u003c= 200000) { try { lock.lock(); count++; // System.out.println(getName() + \" 输出 \" + count); times++; } finally { lock.unlock(); } } System.out.println(getName() + \"一共输出了 \" + times + \" 次\"); } } } Output:\nt3一共输出了 49953 次 t4一共输出了 49988 次 t1一共输出了 50077 次 t2一共输出了 49986 次 It can be observed that the output of the four threads is generally around 50,000.\nReentrantLock Simulating the Dining Philosophers Problem Without Using Condition The dining philosophers problem involves five philosophers sitting around a circular table with only five chopsticks. After a philosopher finishes contemplating, they need to simultaneously acquire the chopsticks on their left and right sides to eat.\nHere, we use threads to simulate philosophers and use ReentrantLock to simulate chopsticks.\npackage com.windypath; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class DiningPhilosopher { public static void main(String[] args) { int numPhilosophers = 5; Philosopher[] philosophers = new Philosopher[numPhilosophers]; Chopstick[] chopsticks = new Chopstick[numPhilosophers]; for (int i = 0; i \u003c numPhilosophers; i++) { chopsticks[i] = new Chopstick(); } for (int i = 0; i \u003c numPhilosophers; i++) { Chopstick leftChopstick = chopsticks[i]; Chopstick rightChopstick = chopsticks[(i + 1) % numPhilosophers]; // philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); if (i % 2 == 0) { philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); } else { philosophers[i] = new Philosopher(i, rightChopstick, leftChopstick); } Thread thread = new Thread(philosophers[i]); thread.start(); } } static class Philosopher implements Runnable { private final int id; private final Chopstick leftChopstick; private final Chopstick rightChopstick; private int eatTimes = 0; public Philosopher(int id, Chopstick leftChopstick, Chopstick rightChopstick) { this.id = id; this.leftChopstick = leftChopstick; this.rightChopstick = rightChopstick; } private void think() throws InterruptedException { System.out.println(\"Philosopher \" + id + \" is thinking.\"); Thread.sleep((long) ( 1000)); } private void eat() throws InterruptedException { leftChopstick.pickUp(); rightChopstick.pickUp(); System.out.println(\"Philosopher \" + id + \" picks up both chopsticks and eats.\"); Thread.sleep((long) ( 1000)); System.out.println(\"Philosopher \" + id + \" puts down both chopsticks.\"); rightChopstick.putDown(); leftChopstick.putDown(); eatTimes++; if (eatTimes % 10 == 0) { System.out.println(\"Philosopher \" + id + \" 目前吃了\" + eatTimes + \"次\"); } } @Override public void run() { try { while (true) { think(); eat(); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } static class Chopstick { private final Lock lock = new ReentrantLock(); public void pickUp() { lock.lock(); } public void putDown() { lock.unlock(); } } } In the above code, the chopsticks only need to be locked by philosophers when picked up using the lock() function and unlocked when put down using the unlock() function to achieve the goal of “simultaneously having the chopsticks on the left and right sides.”\nCode Using Condition: package com.windypath; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class DiningPhilosophers { public static void main(String[] args) { int numPhilosophers = 5; Philosopher[] philosophers = new Philosopher[numPhilosophers]; Chopstick[] chopsticks = new Chopstick[numPhilosophers]; for (int i = 0; i \u003c numPhilosophers; i++) { chopsticks[i] = new Chopstick(); } for (int i = 0; i \u003c numPhilosophers; i++) { Chopstick leftChopstick = chopsticks[i]; Chopstick rightChopstick = chopsticks[(i + 1) % numPhilosophers]; // philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); if (i % 2 == 0) { philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); } else { philosophers[i] = new Philosopher(i, rightChopstick, leftChopstick); } Thread thread = new Thread(philosophers[i]); thread.start(); } } static class Philosopher implements Runnable { private final int id; private final Chopstick leftChopstick; private final Chopstick rightChopstick; private int eatTimes = 0; public Philosopher(int id, Chopstick leftChopstick, Chopstick rightChopstick) { this.id = id; this.leftChopstick = leftChopstick; this.rightChopstick = rightChopstick; } private void think() throws InterruptedException { System.out.println(\"Philosopher \" + id + \" is thinking.\"); Thread.sleep((long) ( 1000)); } private void eat() throws InterruptedException { leftChopstick.pickUp(); rightChopstick.pickUp(); System.out.println(\"Philosopher \" + id + \" picks up both chopsticks and eats.\"); Thread.sleep((long) ( 1000)); System.out.println(\"Philosopher \" + id + \" puts down both chopsticks.\"); rightChopstick.putDown(); leftChopstick.putDown(); eatTimes++; if (eatTimes % 10 == 0) { System.out.println(\"Philosopher \" + id + \" 目前吃了\" + eatTimes + \"次\"); } } @Override public void run() { try { while (true) { think(); eat(); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } static class Chopstick { private final Lock lock = new ReentrantLock(true); private final Condition condition = lock.newCondition(); private boolean taken = false; public void pickUp() throws InterruptedException { lock.lock(); try { while (taken) { condition.await(); } taken = true; } finally { lock.unlock(); } } public void putDown() { lock.lock(); try { taken = false; condition.signal(); } finally { lock.unlock(); } } } } You can see that the Chopstick class has an added taken status to determine whether the chopstick is currently possessed by a philosopher. When the first philosopher picks up a chopstick, taken becomes true, and the lock is released. When the second philosopher picks up the same chopstick, they still acquire the same lock but enter a waiting state with condition.await() due to taken being true. At this point, the lock is also released, allowing other philosophers to pick up this chopstick.\nWhen the chopstick is put down, the signal() method is called, and the thread waiting at the previous await() function is awakened, allowing it to execute its subsequent logic.\nIf a fair lock is not used, you might see that two philosophers eat very late in their 10 cycles. With a fair lock, almost all five philosophers synchronize and complete their 10 cycles.\nNote that when initializing philosophers, chopsticks for philosophers with odd numbers are swapped. This is because in the subsequent logic for picking up chopsticks, we always pick up the left chopstick first and then the right one. If we don’t reverse the hands for some philosophers, there would be a situation where all five philosophers pick up the left chopstick simultaneously and then wait for the right one, leading to a deadlock. (Of course, we could also use random numbers to let philosophers decide whether to pick up the left or right chopstick first.)\n","wordCount":"2283","inLanguage":"en","datePublished":"2023-12-04T17:27:44+08:00","dateModified":"2023-12-04T17:27:44+08:00","author":{"@type":"Person","name":"JohnathanLin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://windypath.com/en/posts/java_juc_briefly/"},"publisher":{"@type":"Organization","name":"WindyPath - Study And Practice, Years Of It","logo":{"@type":"ImageObject","url":"https://windypath.com/%3Clink%20/%20abs%20url%3E"}}}</script><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ")</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windypath.com/en/ accesskey=h title="Windypath (Alt + H)">Windypath</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windypath.com/ title=点击这里切换中文网站 aria-label=点击这里切换中文网站>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://windypath.com/en/archives/ title=ARCHIVES><span>ARCHIVES</span></a></li><li><a href=https://windypath.com/en/categories/ title=CATEGORIES><span>CATEGORIES</span></a></li><li><a href=https://windypath.com/en/about/ title=ABOUT><span>ABOUT</span></a></li><li><a href=https://windypath.com/en/mybooks/ title="MY BOOKS"><span>MY BOOKS</span></a></li><li><a href=https://windypath.com/en/myfriends/ title="MY FRIENDS"><span>MY FRIENDS</span></a></li><li><a href=https://windypath.com/en/search/ title="SEARCH (Alt + /)" accesskey=/><span>SEARCH</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Various Locking Mechanisms in Java Concurrency Programming</h1><div class=post-meta>&lt;span title='2023-12-04 17:27:44 +0800 +0800'>December 4, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;JohnathanLin&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://windypath.com/posts/java_juc_briefly/>Zh</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#locking-with-synchronized aria-label="Locking with Synchronized">Locking with Synchronized</a><ul><li><a href=#synchronized-is-a-non-fair-lock aria-label="Synchronized is a Non-Fair Lock">Synchronized is a Non-Fair Lock</a></li><li><a href=#synchronizeds-waiting-queue aria-label="Synchronized&amp;rsquo;s Waiting Queue">Synchronized&rsquo;s Waiting Queue</a></li><li><a href=#synchronized-lock-upgrade aria-label="Synchronized Lock Upgrade">Synchronized Lock Upgrade</a></li><li><a href=#differences-between-lightweight-lock-and-biased-lock aria-label="Differences Between Lightweight Lock and Biased Lock">Differences Between Lightweight Lock and Biased Lock</a></li><li><a href=#observation-of-synchronized-lock-escalation aria-label="Observation of Synchronized Lock Escalation">Observation of Synchronized Lock Escalation</a></li><li><a href=#locking-with-reentrantlock aria-label="Locking with ReentrantLock">Locking with ReentrantLock</a></li><li><a href=#reentrantlock-can-be-used-as-a-fair-lock aria-label="ReentrantLock can be used as a fair lock.">ReentrantLock can be used as a fair lock.</a></li><li><a href=#reentrantlock-simulating-the-dining-philosophers-problem-without-using-condition aria-label="ReentrantLock Simulating the Dining Philosophers Problem Without Using Condition">ReentrantLock Simulating the Dining Philosophers Problem Without Using Condition</a><ul><li><a href=#code-using-condition aria-label="Code Using Condition:">Code Using Condition:</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>Introduction: This article aims to introduce the relevant usage of synchronized, ReentrantLock, and Condition in Java.</p></blockquote><h1 id=locking-with-synchronized>Locking with Synchronized<a hidden class=anchor aria-hidden=true href=#locking-with-synchronized>#</a></h1><p>Synchronized can be applied to instance methods, static methods, and code blocks. When used to modify a code block, it can either lock on a specific object or on a class (.class).</p><h2 id=synchronized-is-a-non-fair-lock>Synchronized is a Non-Fair Lock<a hidden class=anchor aria-hidden=true href=#synchronized-is-a-non-fair-lock>#</a></h2><p>The following code utilizes synchronized to lock on a variable accessible by multiple threads, achieving the orderly printing of numbers. Additionally, it calculates the frequency of number printing for different threads:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath.lockcondition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Syn</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Object sth <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>play</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> loopTimes <span style=color:#f92672>=</span> 1000;
</span></span><span style=display:flex><span>        SynThread t1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynThread(loopTimes, <span style=color:#e6db74>&#34;t1&#34;</span>);
</span></span><span style=display:flex><span>        SynThread t2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynThread(loopTimes, <span style=color:#e6db74>&#34;t2&#34;</span>);
</span></span><span style=display:flex><span>        SynThread t3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynThread(loopTimes, <span style=color:#e6db74>&#34;t3&#34;</span>);
</span></span><span style=display:flex><span>        SynThread t4 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynThread(loopTimes, <span style=color:#e6db74>&#34;t4&#34;</span>);
</span></span><span style=display:flex><span>        t1.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t2.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t3.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t4.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Syn syn <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Syn();
</span></span><span style=display:flex><span>        syn.<span style=color:#a6e22e>play</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SynThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> loopTimes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SynThread</span>(<span style=color:#66d9ef>int</span> loopTimes, String threadName) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>(threadName);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loopTimes</span> <span style=color:#f92672>=</span> loopTimes;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> times <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (count <span style=color:#f92672>&lt;=</span> 200000) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (sth) {
</span></span><span style=display:flex><span>                    count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//                    System.out.println(getName() + &#34; 输出 &#34; + count);</span>
</span></span><span style=display:flex><span>                    times<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getName() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;一共输出了 &#34;</span> <span style=color:#f92672>+</span> times <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 次&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output：</p><pre tabindex=0><code>t2一共输出了 103061 次
t1一共输出了 37174 次
t4一共输出了 33751 次
t3一共输出了 26018 次
</code></pre><p>It can be observed that the number of times thread t2 outputs is more than the sum of the other three threads. This is because synchronized is a non-fair lock.</p><h2 id=synchronizeds-waiting-queue>Synchronized&rsquo;s Waiting Queue<a hidden class=anchor aria-hidden=true href=#synchronizeds-waiting-queue>#</a></h2><p>The waiting queue for an object locked with synchronized is located in the _waitSet of the ObjectMonitor. This ObjectMonitor is a low-level native (C/C++) component.</p><h2 id=synchronized-lock-upgrade>Synchronized Lock Upgrade<a hidden class=anchor aria-hidden=true href=#synchronized-lock-upgrade>#</a></h2><p>However, heavyweight locks are not acquired right from the start. Instead, the optimization begins with biased locking. It only upgrades to lightweight locks in the presence of contention, and only when numerous threads are involved in lock contention does it escalate from a lightweight lock to a heavyweight lock.</p><p>The locked object uses the MarkWord in its object header to store lock information.</p><p>The storage structure of a Java object in memory consists of three parts:</p><ul><li>Object header</li><li>Instance variables</li><li>Padding bytes</li></ul><p>Among them, the object header mainly stores some runtime data:</p><ul><li>MarkWord</li><li>Class Metadata Address (points to the object type data)</li><li>Array Length (if it&rsquo;s an array, it records the length)</li></ul><p>The lock information is recorded in the MarkWord of the object header. The following diagram illustrates the different bits of information in the MarkWord for different locks:
<img loading=lazy src=/images/java_lock_bit_detail.jpg alt></p><ul><li>Biased Lock
Biased locking is designed to avoid the resource consumption associated with higher-level locks, such as lightweight locks, when a lock is acquired in a non-multithreaded environment.</li></ul><p>The term &ldquo;biased&rdquo; means that the locked object is biased toward a specific thread. Its object header stores the ID of the biased thread.</p><ul><li>Lightweight Lock
The lightweight lock is not intended to replace heavyweight locks. Its purpose is to reduce the performance overhead incurred by traditional heavyweight locks in the absence of multithreaded competition. Before explaining the execution process of the lightweight lock, it&rsquo;s essential to understand that the lightweight lock is suitable for scenarios where threads alternately execute synchronized blocks.</li></ul><h2 id=differences-between-lightweight-lock-and-biased-lock>Differences Between Lightweight Lock and Biased Lock<a hidden class=anchor aria-hidden=true href=#differences-between-lightweight-lock-and-biased-lock>#</a></h2><p>The process of acquiring a lightweight lock involves multiple CAS (Compare-And-Swap) operations, whereas a biased lock requires only one CAS operation.
Lightweight locks are suitable for scenarios where threads alternately execute synchronized blocks. In contrast, biased locks are designed to further improve performance when only one thread executes the synchronized block.</p><h2 id=observation-of-synchronized-lock-escalation>Observation of Synchronized Lock Escalation<a hidden class=anchor aria-hidden=true href=#observation-of-synchronized-lock-escalation>#</a></h2><p>Attempt to use an object, and have multiple threads acquire and release a synchronized lock on it at different time intervals to observe its lock state.</p><p>thread1: Acquires and releases immediately.</p><p>thread2: Waits 500ms to acquire, then holds for 1500ms before releasing.</p><p>thread3: Waits 1000ms to acquire, then releases immediately.</p><p>At this point, there will be lock contention between thread2 and thread3.</p><p>Source Code：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.logging.log4j.LogManager;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.logging.log4j.Logger;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.openjdk.jol.info.ClassLayout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Observing the process of synchronized transitioning from biased lock to lightweight lock to heavyweight lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Using log4j2
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BiasdLock</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> Logger log <span style=color:#f92672>=</span> LogManager.<span style=color:#a6e22e>getLogger</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;最开始的状态:\n&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(<span style=color:#66d9ef>new</span> Object()).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// After starting, the HotSpot Virtual Machine has a 4-second delay before enabling biased locking mode for each newly created object.</span>
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(4000);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个对象，用于多个不同的线程上锁用</span>
</span></span><span style=display:flex><span>        Object obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;等待4秒后的状态（新对象）:\n&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>//线程1，马上上锁马上释放</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;开始执行准备获取锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;获取锁执行中:\n&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;释放锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;thread1&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程2，等线程1释放锁后再上锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>sleep</span>(500);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;开始执行准备获取锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;获取锁执行中:\n&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>sleep</span>(1500);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;释放锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;thread2&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程3，在线程2拥有锁的时候尝试上锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>sleep</span>(1000);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;开始执行准备获取锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;获取锁执行中:\n&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;释放锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;thread3&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>//主线程等待所有线程运行结束，查看状态</span>
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(5000);
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;结束状态:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output(Briefly):</p><pre tabindex=0><code>15:53:58.436 [main] main最开始的状态:non-biasable
15:54:02.854 [main] 等待4秒后的状态（新对象）:biasable
15:54:02.858 [thread1] thread1开始执行准备获取锁:biasable
15:54:02.858 [thread1] thread1获取锁执行中:biased
15:54:02.859 [thread1] thread1释放锁:biased
15:54:03.367 [thread2] thread2开始执行准备获取锁:biased
15:54:03.368 [thread2] thread2获取锁执行中:thin lock
15:54:03.869 [thread3] thread3开始执行准备获取锁:thin lock
15:54:04.872 [thread3] thread3获取锁执行中:fat lock
15:54:04.872 [thread2] thread2释放锁:fat lock
15:54:04.873 [thread3] thread3释放锁:fat lock
15:54:07.868 [main] main结束状态:non-biasable
</code></pre><p>The following conclusions can be drawn from the analysis:</p><ul><li>For the HotSpot Virtual Machine, objects created immediately after startup are non-biasable.</li><li>Objects created after 4 seconds are biasable.</li><li>When thread1 acquires the lock, as there is only one thread holding the synchronized lock for this object, it transitions to the biased lock state.</li><li>When thread1 releases the lock, the lock object remains in the biased lock state and does not revert to biasable.</li><li>After 500ms, when thread2 acquires the lock, the lock object&rsquo;s state is upgraded to a lightweight lock.</li><li>Another 500ms later, when thread3 also attempts to acquire the lock, its state is lightweight lock (thin lock) until it executes the synchronized block. It then blocks until thread2 releases the lock, at which point it immediately acquires the lock (the timestamps in the third and fourth lines are exactly the same, both 15:54:04.872).</li><li>Thread3 releases the lock immediately, at this moment, it is still a heavyweight lock.</li><li>After the main thread waits for 5 seconds, the lock state is restored but becomes non-biasable.</li><li>You can try commenting out the earlier 4-second delay; in this case, the object would immediately acquire a lightweight lock.</li></ul><h2 id=locking-with-reentrantlock>Locking with ReentrantLock<a hidden class=anchor aria-hidden=true href=#locking-with-reentrantlock>#</a></h2><p>ReentrantLock is a lightweight, reentrant lock. It can be specified as a fair lock during creation. ReentrantLock can be used in conjunction with Condition. It provides several functions related to concurrent programming, offering higher flexibility compared to synchronized.</p><ul><li>ReentrantLock supports whether the lock is fair.</li><li>In addition to the regular lock() function, ReentrantLock also provides tryLock() for polling and lockInterruptibly() for interruptible locking.</li><li>After acquiring a lock with ReentrantLock, you can wait on different conditions based on your business logic.</li></ul><h2 id=reentrantlock-can-be-used-as-a-fair-lock>ReentrantLock can be used as a fair lock.<a hidden class=anchor aria-hidden=true href=#reentrantlock-can-be-used-as-a-fair-lock>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath.lockcondition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.ReentrantLock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Reen</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ReentrantLock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>play</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> loopTimes <span style=color:#f92672>=</span> 1000;
</span></span><span style=display:flex><span>        ReenThread t1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReenThread(loopTimes, <span style=color:#e6db74>&#34;t1&#34;</span>);
</span></span><span style=display:flex><span>        ReenThread t2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReenThread(loopTimes, <span style=color:#e6db74>&#34;t2&#34;</span>);
</span></span><span style=display:flex><span>        ReenThread t3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReenThread(loopTimes, <span style=color:#e6db74>&#34;t3&#34;</span>);
</span></span><span style=display:flex><span>        ReenThread t4 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReenThread(loopTimes, <span style=color:#e6db74>&#34;t4&#34;</span>);
</span></span><span style=display:flex><span>        t1.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t2.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t3.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t4.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Reen reen <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Reen();
</span></span><span style=display:flex><span>        reen.<span style=color:#a6e22e>play</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReenThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> loopTimes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ReenThread</span>(<span style=color:#66d9ef>int</span> loopTimes, String threadName) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>(threadName);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loopTimes</span> <span style=color:#f92672>=</span> loopTimes;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> times <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (count <span style=color:#f92672>&lt;=</span> 200000) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>                    count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//                    System.out.println(getName() + &#34; 输出 &#34; + count);</span>
</span></span><span style=display:flex><span>                    times<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getName() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;一共输出了 &#34;</span> <span style=color:#f92672>+</span> times <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 次&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output:</p><pre tabindex=0><code>t3一共输出了 49953 次
t4一共输出了 49988 次
t1一共输出了 50077 次
t2一共输出了 49986 次
</code></pre><p>It can be observed that the output of the four threads is generally around 50,000.</p><h2 id=reentrantlock-simulating-the-dining-philosophers-problem-without-using-condition>ReentrantLock Simulating the Dining Philosophers Problem Without Using Condition<a hidden class=anchor aria-hidden=true href=#reentrantlock-simulating-the-dining-philosophers-problem-without-using-condition>#</a></h2><p>The dining philosophers problem involves five philosophers sitting around a circular table with only five chopsticks. After a philosopher finishes contemplating, they need to simultaneously acquire the chopsticks on their left and right sides to eat.</p><p>Here, we use threads to simulate philosophers and use ReentrantLock to simulate chopsticks.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.Condition;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.Lock;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.ReentrantLock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DiningPhilosopher</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numPhilosophers <span style=color:#f92672>=</span> 5;
</span></span><span style=display:flex><span>        Philosopher<span style=color:#f92672>[]</span> philosophers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher<span style=color:#f92672>[</span>numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        Chopstick<span style=color:#f92672>[]</span> chopsticks <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Chopstick<span style=color:#f92672>[</span>numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> numPhilosophers; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            chopsticks<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Chopstick();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> numPhilosophers; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            Chopstick leftChopstick <span style=color:#f92672>=</span> chopsticks<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            Chopstick rightChopstick <span style=color:#f92672>=</span> chopsticks<span style=color:#f92672>[</span>(i <span style=color:#f92672>+</span> 1) <span style=color:#f92672>%</span> numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//            philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> 2 <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher(i, leftChopstick, rightChopstick);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher(i, rightChopstick, leftChopstick);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Philosopher</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Chopstick leftChopstick;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Chopstick rightChopstick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> eatTimes <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Philosopher</span>(<span style=color:#66d9ef>int</span> id, Chopstick leftChopstick, Chopstick rightChopstick) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> id;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>leftChopstick</span> <span style=color:#f92672>=</span> leftChopstick;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>rightChopstick</span> <span style=color:#f92672>=</span> rightChopstick;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>think</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; is thinking.&#34;</span>);
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>((<span style=color:#66d9ef>long</span>) ( 1000));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>eat</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            leftChopstick.<span style=color:#a6e22e>pickUp</span>();
</span></span><span style=display:flex><span>            rightChopstick.<span style=color:#a6e22e>pickUp</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; picks up both chopsticks and eats.&#34;</span>);
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>((<span style=color:#66d9ef>long</span>) ( 1000));
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; puts down both chopsticks.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            rightChopstick.<span style=color:#a6e22e>putDown</span>();
</span></span><span style=display:flex><span>            leftChopstick.<span style=color:#a6e22e>putDown</span>();
</span></span><span style=display:flex><span>            eatTimes<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (eatTimes <span style=color:#f92672>%</span> 10 <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 目前吃了&#34;</span> <span style=color:#f92672>+</span> eatTimes <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;次&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                    think();
</span></span><span style=display:flex><span>                    eat();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Chopstick</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pickUp</span>() {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>putDown</span>() {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the above code, the chopsticks only need to be locked by philosophers when picked up using the lock() function and unlocked when put down using the unlock() function to achieve the goal of &ldquo;simultaneously having the chopsticks on the left and right sides.&rdquo;</p><h3 id=code-using-condition>Code Using Condition:<a hidden class=anchor aria-hidden=true href=#code-using-condition>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.Condition;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.Lock;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.ReentrantLock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DiningPhilosophers</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numPhilosophers <span style=color:#f92672>=</span> 5;
</span></span><span style=display:flex><span>        Philosopher<span style=color:#f92672>[]</span> philosophers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher<span style=color:#f92672>[</span>numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        Chopstick<span style=color:#f92672>[]</span> chopsticks <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Chopstick<span style=color:#f92672>[</span>numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> numPhilosophers; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            chopsticks<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Chopstick();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> numPhilosophers; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            Chopstick leftChopstick <span style=color:#f92672>=</span> chopsticks<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            Chopstick rightChopstick <span style=color:#f92672>=</span> chopsticks<span style=color:#f92672>[</span>(i <span style=color:#f92672>+</span> 1) <span style=color:#f92672>%</span> numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//            philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> 2 <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher(i, leftChopstick, rightChopstick);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher(i, rightChopstick, leftChopstick);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Philosopher</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Chopstick leftChopstick;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Chopstick rightChopstick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> eatTimes <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Philosopher</span>(<span style=color:#66d9ef>int</span> id, Chopstick leftChopstick, Chopstick rightChopstick) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> id;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>leftChopstick</span> <span style=color:#f92672>=</span> leftChopstick;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>rightChopstick</span> <span style=color:#f92672>=</span> rightChopstick;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>think</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; is thinking.&#34;</span>);
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>((<span style=color:#66d9ef>long</span>) ( 1000));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>eat</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            leftChopstick.<span style=color:#a6e22e>pickUp</span>();
</span></span><span style=display:flex><span>            rightChopstick.<span style=color:#a6e22e>pickUp</span>();
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; picks up both chopsticks and eats.&#34;</span>);
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>((<span style=color:#66d9ef>long</span>) ( 1000));
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; puts down both chopsticks.&#34;</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            rightChopstick.<span style=color:#a6e22e>putDown</span>();
</span></span><span style=display:flex><span>            leftChopstick.<span style=color:#a6e22e>putDown</span>();
</span></span><span style=display:flex><span>            eatTimes<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (eatTimes <span style=color:#f92672>%</span> 10 <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 目前吃了&#34;</span> <span style=color:#f92672>+</span> eatTimes <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;次&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                    think();
</span></span><span style=display:flex><span>                    eat();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Chopstick</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Condition condition <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>newCondition</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> taken <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pickUp</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (taken) {
</span></span><span style=display:flex><span>                    condition.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                taken <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>putDown</span>() {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                taken <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                condition.<span style=color:#a6e22e>signal</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You can see that the Chopstick class has an added taken status to determine whether the chopstick is currently possessed by a philosopher. When the first philosopher picks up a chopstick, taken becomes true, and the lock is released. When the second philosopher picks up the same chopstick, they still acquire the same lock but enter a waiting state with condition.await() due to taken being true. At this point, the lock is also released, allowing other philosophers to pick up this chopstick.</p><p>When the chopstick is put down, the signal() method is called, and the thread waiting at the previous await() function is awakened, allowing it to execute its subsequent logic.</p><blockquote><p>If a fair lock is not used, you might see that two philosophers eat very late in their 10 cycles. With a fair lock, almost all five philosophers synchronize and complete their 10 cycles.</p></blockquote><blockquote><p>Note that when initializing philosophers, chopsticks for philosophers with odd numbers are swapped. This is because in the subsequent logic for picking up chopsticks, we always pick up the left chopstick first and then the right one. If we don&rsquo;t reverse the hands for some philosophers, there would be a situation where all five philosophers pick up the left chopstick simultaneously and then wait for the right one, leading to a deadlock. (Of course, we could also use random numbers to let philosophers decide whether to pick up the left or right chopstick first.)</p></blockquote></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://windypath.com/en/posts/how_to_split_a_string_in_cpp/><span class=title>Next »</span><br><span>How To Split A String In C++?</span></a></nav></footer></article></main><footer class=footer><span>Windypath 风萧古道 <strong>For Chinese Software</strong>. <a href=https://beian.miit.gov.cn/>闽ICP备15016446号-3</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>