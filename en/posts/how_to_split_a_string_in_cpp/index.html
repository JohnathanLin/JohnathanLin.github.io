<!doctype html><html lang=en dir=auto><head><style></style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e);const t=document.createElement("link");t.href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&&display=swap",t.type="text/css",t.rel="stylesheet",document.head.appendChild(t)})()</script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How To Split A String In C++? | WindyPath - Study And Practice, Years Of It</title>
<meta name=keywords content><meta name=description content="Preface During a coding interview, I encountered a question that involved two lines of input. Each line contained an unknown number of numbers separated by spaces. The input format was as follows:
12 34 567 888 99 100 358 74 58454 742 4469 88 They did not provide the number of digits in each line in advance. Instead, they required the user to split them themselves.
During the coding exam, I didn&rsquo;t implement this functionality using C++, but instead used the split() method available in Java to handle it."><meta name=author content="JohnathanLin"><link rel=canonical href=https://windypath.com/en/posts/how_to_split_a_string_in_cpp/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.c4a8acbcd788f82f107eab9ebf91b4465779d62ab520247cf796f1e2f3fe622e.css integrity="sha256-xKisvNeI+C8Qfquev5G0Rld51iq1ICR895bx4vP+Yi4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://windypath.com/posts/how_to_split_a_string_in_cpp/><link rel=alternate hreflang=en href=https://windypath.com/en/posts/how_to_split_a_string_in_cpp/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ",{anonymize_ip:!1})}</script><meta property="og:title" content="How To Split A String In C++?"><meta property="og:description" content="Preface During a coding interview, I encountered a question that involved two lines of input. Each line contained an unknown number of numbers separated by spaces. The input format was as follows:
12 34 567 888 99 100 358 74 58454 742 4469 88 They did not provide the number of digits in each line in advance. Instead, they required the user to split them themselves.
During the coding exam, I didn&rsquo;t implement this functionality using C++, but instead used the split() method available in Java to handle it."><meta property="og:type" content="article"><meta property="og:url" content="https://windypath.com/en/posts/how_to_split_a_string_in_cpp/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-02T11:54:44+08:00"><meta property="article:modified_time" content="2023-07-02T11:54:44+08:00"><meta property="og:site_name" content="Windypath"><meta name=twitter:card content="summary"><meta name=twitter:title content="How To Split A String In C++?"><meta name=twitter:description content="Preface During a coding interview, I encountered a question that involved two lines of input. Each line contained an unknown number of numbers separated by spaces. The input format was as follows:
12 34 567 888 99 100 358 74 58454 742 4469 88 They did not provide the number of digits in each line in advance. Instead, they required the user to split them themselves.
During the coding exam, I didn&rsquo;t implement this functionality using C++, but instead used the split() method available in Java to handle it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windypath.com/en/posts/"},{"@type":"ListItem","position":2,"name":"How To Split A String In C++?","item":"https://windypath.com/en/posts/how_to_split_a_string_in_cpp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How To Split A String In C++?","name":"How To Split A String In C\u002b\u002b?","description":"Preface During a coding interview, I encountered a question that involved two lines of input. Each line contained an unknown number of numbers separated by spaces. The input format was as follows:\n12 34 567 888 99 100 358 74 58454 742 4469 88 They did not provide the number of digits in each line in advance. Instead, they required the user to split them themselves.\nDuring the coding exam, I didn\u0026rsquo;t implement this functionality using C++, but instead used the split() method available in Java to handle it.","keywords":[],"articleBody":"Preface During a coding interview, I encountered a question that involved two lines of input. Each line contained an unknown number of numbers separated by spaces. The input format was as follows:\n12 34 567 888 99 100 358 74 58454 742 4469 88 They did not provide the number of digits in each line in advance. Instead, they required the user to split them themselves.\nDuring the coding exam, I didn’t implement this functionality using C++, but instead used the split() method available in Java to handle it.\nLater, after the exam was over, I searched online for ways to split strings in C++, and I found that C++ does not have a built-in method similar to split(character) like in Java.\nSo, what methods can be used as alternatives?\nMethod 1: Splitting using string’s find() function along with substr() According to the response from a Zhihu user, the first solution they suggested is:\nC++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/36642771/answer/865135551\n#include #include #include void split(const std::string\u0026 s, std::vector\u003cstd::string\u003e\u0026 tokens, const std::string\u0026 delimiters = \" \") { std::string::size_type lastPos = s.find_first_not_of(delimiters, 0); std::string::size_type pos = s.find_first_of(delimiters, lastPos); while (std::string::npos != pos || std::string::npos != lastPos) { tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s.find_first_not_of(delimiters, pos); pos = s.find_first_of(delimiters, lastPos); } } int main() { std::string str = \"12 34 567 888 99 100\"; std::vector\u003cstd::string\u003e res; split(str, res, \" \"); for (auto r: res) { printf(\"%s\\n\", r.c_str()); } return 0; } The output is：\n12 34 567 888 99 100 The split() function works by keeping track of two indices to determine the substrings to be extracted:\nThe first index, lastPos, finds the index of the first character after the start of the string that is not a delimiter. The second index, pos, finds the index of the first character after lastPos that is a delimiter. By doing this, the substring between lastPos and pos is the portion of the string that needs to be extracted. After extracting the first substring, both indices are moved forward according to the previous logic, until both indices cannot find suitable values (returning string::npos). This marks the end of the process.\nFunction Introduction: find_first_of() The find_first_of() function of string takes two parameters. The first parameter is the character to search for, which can be a string, char*, or char. The second parameter is the index to start searching from (it is optional and defaults to 0). It searches from the specified index onward until it finds the character being searched for, and then returns the index where the character is found.\nfind_first_not_of() The find_first_not_of() function of string accepts the same parameters as find_first_of(). However, it searches until it encounters a character that is not in the search characters. It returns the index of the first character that is not part of the search characters.\nsubstr() The substr() function is used to extract a substring from a string. It takes two parameters, pos and len, indicating the starting position and the length of the substring to be extracted. The original string is not modified.\nC++ document location：\nfind_first_of()：https://cplusplus.com/reference/string/string/find_first_of/\nfind_first_not_of()：https://cplusplus.com/reference/string/string/find_first_not_of/\nsubstr()：https://cplusplus.com/reference/string/string/substr/\nMethod 2：C++11 regular expression #include #include #include int main() { std::string str = \"12 34 567 888 99 100\"; std::regex ws_re(\"\\\\s+\"); std::vector\u003cstd::string\u003e res( std::sregex_token_iterator( str.begin(), str.end(), ws_re, -1 ), std::sregex_token_iterator() ); for (auto r: res) { printf(\"%s\\n\", r.c_str()); } return 0; } This example comes from the introduction to regex token iterator.\nhttps://en.cppreference.com/w/cpp/regex/regex_token_iterator\nUsing the sregex_token_iterator() iterator for splitting operations (where s refers to a string type). In this example, in lines 9-11, a sregex_token_iterator iterator is constructed with four parameters: the iterator to the beginning of the string, the iterator to the end of the string, a regular expression object, and whether to use the matched parts (0 for using, -1 for not using).\nBy constructing the sregex_token_iterator(), it is determined to start searching from the beginning of the string and continue until the end of the string, using regular expression matching, and finding the unmatched parts.\nThe end of this iterator is represented by a default-constructed sregex_token_iterator() object.\nIn the constructor of vector, by passing in two iterators, the elements between the iterators can be obtained.\nMethod 3: Splitting strings using stringstream (supports only space, newline, tab) Source：https://www.cnblogs.com/narjaja/p/10044157.html\n#include #include #include int main() { std::string str = \"12 34 567 888 99 100\"; std::vector\u003cstd::string\u003e res; std::istringstream ss(str); std::string word; while(ss\u003e\u003eword) { res.push_back(word); } for (auto r: res) { printf(\"%s\\n\", r.c_str()); } return 0; } By using the » operator in C++, similar to how cin works for user input, we can “input” a string and achieve the splitting effect.\nIf you want to support custom delimiters, you can use getline() for handling.\n#include #include #include using namespace std; int main() { std::string data = \"1_2_3_4_5_6\"; std::stringstream ss(data); std::string item; cout \u003c\u003c data \u003c\u003c endl; while (std::getline(ss, item, '_')) cout \u003c\u003c item \u003c\u003c ' '; } Method 4: Implementing with the C function strtok() The first incorrect approach Another approach is to use the strtok() function from C language for handling the string splitting.\nOn the internet, you may come across code structures similar to the following:\n#include #include int main() { char str[] = \"A B C D\"; char* p = strtok(str, \" \"); std::cout \u003c\u003c p \u003c\u003c std::endl; while (p != NULL) { p = strtok(NULL, \" \"); std::cout \u003c\u003c p \u003c\u003c std::endl; } return 0; } The output is：\nA B C D However, when I attempted to perform a cout output on line 11, I found that the result was not displayed correctly:\n#include #include int main() { char str[] = \"A B C D\"; char* p = strtok(str, \" \"); std::cout \u003c\u003c p \u003c\u003c std::endl; while (p != NULL) { p = strtok(NULL, \" \"); std::cout \u003c\u003c p \u003c\u003c std::endl; } std::cout \u003c\u003c \"abc\" \u003c\u003c std::endl; return 0; } The output is：\nA B C D The final “abc” is missing in the output。\nAfter consulting with ChatGPT, the explanation received is as follows:\nThe issue in this C++ code is that when iterating and outputting the split substrings, the value of p is printed first before proceeding to the next iteration. This causes the value of p to be set as NULL after the last iteration, and then attempting to print the value of p leads to undefined behavior.\nIn line 8, you print the value of p and then in line 9, it is set to the next split substring. Then, in line 10, when the loop begins again, you print the value of p again, but at this point, it may already be NULL, resulting in undefined behavior.\nTo fix this issue, you can move the printing statement to the end of the loop, so that the value of p is printed after proceeding to the next iteration, ensuring that p is not NULL.\nHere is the corrected code:\n#include #include int main() { char str[] = \"A B C D\"; char* p = strtok(str, \" \"); while (p != NULL) { std::cout \u003c\u003c p \u003c\u003c std::endl; p = strtok(NULL, \" \"); } std::cout \u003c\u003c \"abc\" \u003c\u003c std::endl; return 0; } After making this modification, the code will correctly output the split substrings and then output “abc”. Please note that std::endl is used to add a newline character after the output to ensure the correct formatting of the output result.\nThe second incorrect approach #include #include int main() { char s[] = \"A B C D\"; char *p; const char *d = \" \"; p = strtok(s, d); while(p) { printf(\"%s\\n\", p); p = strtok(NULL, \" \"); } printf(\"abc\"); return 0; } This time, we output the previous split p first within the loop body and then read the next p. However, the string “abc” still doesn’t output correctly. Here’s ChatGPT’s answer:\nChatGPT:\nThe reason why “abc” cannot be output correctly in this code is that when using the strtok function to split the string, it replaces the delimiter in the original string with a null character ‘\\0’ to separate the substrings. This modification alters the original string s, and subsequent printf statements will terminate prematurely when encountering ‘\\0’.\nIn the code, the content of the original string s is “A B C D”, and strtok(s, d) will split it into four substrings: “A”, “B”, “C”, and “D”. Therefore, the printf statement in the loop will output these four substrings: “A”, “B”, “C”, and “D”.\nThen, in the last call to strtok(NULL, \" “), since there are no more delimiters, strtok will return NULL and terminate the loop. Subsequently, the printf(“abc”) statement in the code will attempt to output “abc”. However, due to the previous strtok calls modifying the original string s and replacing the spaces with ‘\\0’, when reaching the printf statement, the function encounters the ‘\\0’ character, treating it as the end of the string and causing the output to terminate prematurely.\nIf you want to output “abc”, you can add a newline character \\n to the printf statement as shown below:\n#include #include int main() { char s[] = \"A B C D\"; char *p; const char *d = \" \"; p = strtok(s, d); while (p) { printf(\"%s\\n\", p); p = strtok(NULL, \" \"); } printf(\"abc\\n\"); // 在\"abc\"后添加换行符\\n return 0; } With the above modification, the code will be able to output “A”, “B”, “C”, “D”, and “abc” correctly.\nstrtok() Function After the strtok() function performs the splitting, it fills the cut positions with ‘\\0’, thereby modifying the original string. Therefore, it is essential to exercise caution and use this function carefully. 通过上述修改，代码将能够正常输出\"A”、“B”、“C”、“D\"和\"abc”。 strtok()函数\n","wordCount":"1615","inLanguage":"en","datePublished":"2023-07-02T11:54:44+08:00","dateModified":"2023-07-02T11:54:44+08:00","author":{"@type":"Person","name":"JohnathanLin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://windypath.com/en/posts/how_to_split_a_string_in_cpp/"},"publisher":{"@type":"Organization","name":"WindyPath - Study And Practice, Years Of It","logo":{"@type":"ImageObject","url":"https://windypath.com/%3Clink%20/%20abs%20url%3E"}}}</script><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ")</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windypath.com/en/ accesskey=h title="Windypath (Alt + H)">Windypath</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windypath.com/ title=点击这里切换中文网站 aria-label=点击这里切换中文网站>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://windypath.com/en/archives/ title=ARCHIVES><span>ARCHIVES</span></a></li><li><a href=https://windypath.com/en/categories/ title=CATEGORIES><span>CATEGORIES</span></a></li><li><a href=https://windypath.com/en/about/ title=ABOUT><span>ABOUT</span></a></li><li><a href=https://windypath.com/en/mybooks/ title="MY BOOKS"><span>MY BOOKS</span></a></li><li><a href=https://windypath.com/en/myfriends/ title="MY FRIENDS"><span>MY FRIENDS</span></a></li><li><a href=https://windypath.com/en/search/ title="SEARCH (Alt + /)" accesskey=/><span>SEARCH</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>How To Split A String In C++?</h1><div class=post-meta>&lt;span title='2023-07-02 11:54:44 +0800 +0800'>July 2, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;JohnathanLin&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://windypath.com/posts/how_to_split_a_string_in_cpp/>Zh</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#preface aria-label=Preface>Preface</a></li><li><a href=#method-1-splitting-using-strings-find-function-along-with-substr aria-label="Method 1: Splitting using string&amp;rsquo;s find() function along with substr()">Method 1: Splitting using string&rsquo;s find() function along with substr()</a><ul><li><a href=#function-introduction aria-label="Function Introduction:">Function Introduction:</a><ul><li><a href=#find_first_of aria-label=find_first_of()>find_first_of()</a></li><li><a href=#find_first_not_of aria-label=find_first_not_of()>find_first_not_of()</a></li><li><a href=#substr aria-label=substr()>substr()</a></li></ul></li></ul></li><li><a href=#method-2c11-regular-expression aria-label="Method 2：C++11 regular expression">Method 2：C++11 regular expression</a></li><li><a href=#method-3-splitting-strings-using-stringstream-supports-only-space-newline-tab aria-label="Method 3: Splitting strings using stringstream (supports only space, newline, tab)">Method 3: Splitting strings using stringstream (supports only space, newline, tab)</a></li><li><a href=#method-4-implementing-with-the-c-function-strtok aria-label="Method 4: Implementing with the C function strtok()">Method 4: Implementing with the C function strtok()</a><ul><li><a href=#the-first-incorrect-approach aria-label="The first incorrect approach">The first incorrect approach</a></li><li><a href=#the-second-incorrect-approach aria-label="The second incorrect approach">The second incorrect approach</a></li></ul></li><li><a href=#strtok-function aria-label="strtok() Function">strtok() Function</a></li></ul></div></details></div><div class=post-content><h1 id=preface>Preface<a hidden class=anchor aria-hidden=true href=#preface>#</a></h1><p>During a coding interview, I encountered a question that involved two lines of input. Each line contained an unknown number of numbers separated by spaces. The input format was as follows:</p><pre tabindex=0><code>12 34 567 888 99 100
358 74 58454 742 4469 88
</code></pre><p>They did not provide the number of digits in each line in advance. Instead, they required the user to split them themselves.</p><p>During the coding exam, I didn&rsquo;t implement this functionality using C++, but instead used the split() method available in Java to handle it.</p><p>Later, after the exam was over, I searched online for ways to split strings in C++, and I found that C++ does not have a built-in method similar to split(character) like in Java.</p><p>So, what methods can be used as alternatives?</p><h1 id=method-1-splitting-using-strings-find-function-along-with-substr>Method 1: Splitting using string&rsquo;s find() function along with substr()<a hidden class=anchor aria-hidden=true href=#method-1-splitting-using-strings-find-function-along-with-substr>#</a></h1><p>According to the response from a Zhihu user, the first solution they suggested is:</p><p>C++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎
<a href=https://www.zhihu.com/question/36642771/answer/865135551>https://www.zhihu.com/question/36642771/answer/865135551</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>split</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> s, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&amp;</span> tokens, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> delimiters <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; &#34;</span>) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>size_type lastPos <span style=color:#f92672>=</span> s.find_first_not_of(delimiters, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>size_type pos <span style=color:#f92672>=</span> s.find_first_of(delimiters, lastPos);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>npos <span style=color:#f92672>!=</span> pos <span style=color:#f92672>||</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>npos <span style=color:#f92672>!=</span> lastPos) {
</span></span><span style=display:flex><span>        tokens.push_back(s.substr(lastPos, pos <span style=color:#f92672>-</span> lastPos));
</span></span><span style=display:flex><span>        lastPos <span style=color:#f92672>=</span> s.find_first_not_of(delimiters, pos);
</span></span><span style=display:flex><span>        pos <span style=color:#f92672>=</span> s.find_first_of(delimiters, lastPos);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;12 34 567 888 99 100&#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>    split(str, res, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> r: res) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, r.c_str());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The output is：</p><pre tabindex=0><code>12
34
567
888
99
100
</code></pre><p>The split() function works by keeping track of two indices to determine the substrings to be extracted:</p><p>The first index, lastPos, finds the index of the first character after the start of the string that is not a delimiter.
The second index, pos, finds the index of the first character after lastPos that is a delimiter.
By doing this, the substring between lastPos and pos is the portion of the string that needs to be extracted.
After extracting the first substring, both indices are moved forward according to the previous logic, until both indices cannot find suitable values (returning string::npos). This marks the end of the process.</p><h2 id=function-introduction>Function Introduction:<a hidden class=anchor aria-hidden=true href=#function-introduction>#</a></h2><h3 id=find_first_of>find_first_of()<a hidden class=anchor aria-hidden=true href=#find_first_of>#</a></h3><p>The find_first_of() function of string takes two parameters. The first parameter is the character to search for, which can be a string, char*, or char. The second parameter is the index to start searching from (it is optional and defaults to 0). It searches from the specified index onward until it finds the character being searched for, and then returns the index where the character is found.</p><h3 id=find_first_not_of>find_first_not_of()<a hidden class=anchor aria-hidden=true href=#find_first_not_of>#</a></h3><p>The find_first_not_of() function of string accepts the same parameters as find_first_of(). However, it searches until it encounters a character that is not in the search characters. It returns the index of the first character that is not part of the search characters.</p><h3 id=substr>substr()<a hidden class=anchor aria-hidden=true href=#substr>#</a></h3><p>The substr() function is used to extract a substring from a string. It takes two parameters, pos and len, indicating the starting position and the length of the substring to be extracted. The original string is not modified.</p><p>C++ document location：</p><p>find_first_of()：<a href=https://cplusplus.com/reference/string/string/find_first_of/>https://cplusplus.com/reference/string/string/find_first_of/</a></p><p>find_first_not_of()：<a href=https://cplusplus.com/reference/string/string/find_first_not_of/>https://cplusplus.com/reference/string/string/find_first_not_of/</a></p><p>substr()：<a href=https://cplusplus.com/reference/string/string/substr/>https://cplusplus.com/reference/string/string/substr/</a></p><h1 id=method-2c11-regular-expression>Method 2：C++11 regular expression<a hidden class=anchor aria-hidden=true href=#method-2c11-regular-expression>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;regex&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;12 34 567 888 99 100&#34;</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>regex ws_re(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>s+&#34;</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> res(
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>sregex_token_iterator(
</span></span><span style=display:flex><span>            str.begin(), str.end(), ws_re, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>sregex_token_iterator()
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> r: res) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, r.c_str());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This example comes from the introduction to regex token iterator.</p><p><a href=https://en.cppreference.com/w/cpp/regex/regex_token_iterator>https://en.cppreference.com/w/cpp/regex/regex_token_iterator</a></p><p>Using the sregex_token_iterator() iterator for splitting operations (where s refers to a string type). In this example, in lines 9-11, a sregex_token_iterator iterator is constructed with four parameters: the iterator to the beginning of the string, the iterator to the end of the string, a regular expression object, and whether to use the matched parts (0 for using, -1 for not using).</p><p>By constructing the sregex_token_iterator(), it is determined to start searching from the beginning of the string and continue until the end of the string, using regular expression matching, and finding the unmatched parts.</p><p>The end of this iterator is represented by a default-constructed sregex_token_iterator() object.</p><p>In the constructor of vector, by passing in two iterators, the elements between the iterators can be obtained.</p><h1 id=method-3-splitting-strings-using-stringstream-supports-only-space-newline-tab>Method 3: Splitting strings using stringstream (supports only space, newline, tab)<a hidden class=anchor aria-hidden=true href=#method-3-splitting-strings-using-stringstream-supports-only-space-newline-tab>#</a></h1><p>Source：<a href=https://www.cnblogs.com/narjaja/p/10044157.html>https://www.cnblogs.com/narjaja/p/10044157.html</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;12 34 567 888 99 100&#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>istringstream ss(str);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string word;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(ss<span style=color:#f92672>&gt;&gt;</span>word) {
</span></span><span style=display:flex><span>        res.push_back(word);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> r: res) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, r.c_str());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>By using the &#187; operator in C++, similar to how cin works for user input, we can &ldquo;input&rdquo; a string and achieve the splitting effect.</p><p>If you want to support custom delimiters, you can use getline() for handling.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1_2_3_4_5_6&#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>stringstream ss(data);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string item;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> data <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (std<span style=color:#f92672>::</span>getline(ss, item, <span style=color:#e6db74>&#39;_&#39;</span>)) 
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> item <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=method-4-implementing-with-the-c-function-strtok>Method 4: Implementing with the C function strtok()<a hidden class=anchor aria-hidden=true href=#method-4-implementing-with-the-c-function-strtok>#</a></h1><h2 id=the-first-incorrect-approach>The first incorrect approach<a hidden class=anchor aria-hidden=true href=#the-first-incorrect-approach>#</a></h2><p>Another approach is to use the strtok() function from C language for handling the string splitting.</p><p>On the internet, you may come across code structures similar to the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> str[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> strtok(str, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The output is：</p><pre tabindex=0><code>A
B
C
D
</code></pre><p>However, when I attempted to perform a cout output on line 11, I found that the result was not displayed correctly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> str[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> strtok(str, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;abc&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The output is：</p><pre tabindex=0><code>A
B
C
D
</code></pre><p>The final &ldquo;abc&rdquo; is missing in the output。</p><p>After consulting with ChatGPT, the explanation received is as follows:</p><p>The issue in this C++ code is that when iterating and outputting the split substrings, the value of p is printed first before proceeding to the next iteration. This causes the value of p to be set as NULL after the last iteration, and then attempting to print the value of p leads to undefined behavior.</p><p>In line 8, you print the value of p and then in line 9, it is set to the next split substring. Then, in line 10, when the loop begins again, you print the value of p again, but at this point, it may already be NULL, resulting in undefined behavior.</p><p>To fix this issue, you can move the printing statement to the end of the loop, so that the value of p is printed after proceeding to the next iteration, ensuring that p is not NULL.</p><p>Here is the corrected code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> str[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> strtok(str, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;abc&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After making this modification, the code will correctly output the split substrings and then output &ldquo;abc&rdquo;. Please note that std::endl is used to add a newline character after the output to ensure the correct formatting of the output result.</p><h2 id=the-second-incorrect-approach>The second incorrect approach<a hidden class=anchor aria-hidden=true href=#the-second-incorrect-approach>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;string.h&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> s[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p; 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>d <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>  p <span style=color:#f92672>=</span> strtok(s, d);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span>(p)
</span></span><span style=display:flex><span>  {  
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p);  
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;abc&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This time, we output the previous split p first within the loop body and then read the next p. However, the string &ldquo;abc&rdquo; still doesn&rsquo;t output correctly. Here&rsquo;s ChatGPT&rsquo;s answer:</p><p>ChatGPT:</p><p>The reason why &ldquo;abc&rdquo; cannot be output correctly in this code is that when using the strtok function to split the string, it replaces the delimiter in the original string with a null character &lsquo;\0&rsquo; to separate the substrings. This modification alters the original string s, and subsequent printf statements will terminate prematurely when encountering &lsquo;\0&rsquo;.</p><p>In the code, the content of the original string s is &ldquo;A B C D&rdquo;, and strtok(s, d) will split it into four substrings: &ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, and &ldquo;D&rdquo;. Therefore, the printf statement in the loop will output these four substrings: &ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, and &ldquo;D&rdquo;.</p><p>Then, in the last call to strtok(NULL, " &ldquo;), since there are no more delimiters, strtok will return NULL and terminate the loop. Subsequently, the printf(&ldquo;abc&rdquo;) statement in the code will attempt to output &ldquo;abc&rdquo;. However, due to the previous strtok calls modifying the original string s and replacing the spaces with &lsquo;\0&rsquo;, when reaching the printf statement, the function encounters the &lsquo;\0&rsquo; character, treating it as the end of the string and causing the output to terminate prematurely.</p><p>If you want to output &ldquo;abc&rdquo;, you can add a newline character \n to the printf statement as shown below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> s[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>d <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>  p <span style=color:#f92672>=</span> strtok(s, d);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (p)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p);
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;abc</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);  <span style=color:#75715e>// 在&#34;abc&#34;后添加换行符\n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With the above modification, the code will be able to output &ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;D&rdquo;, and &ldquo;abc&rdquo; correctly.</p><h1 id=strtok-function>strtok() Function<a hidden class=anchor aria-hidden=true href=#strtok-function>#</a></h1><p>After the strtok() function performs the splitting, it fills the cut positions with &lsquo;\0&rsquo;, thereby modifying the original string. Therefore, it is essential to exercise caution and use this function carefully.
通过上述修改，代码将能够正常输出"A&rdquo;、&ldquo;B&rdquo;、&ldquo;C&rdquo;、&ldquo;D"和"abc&rdquo;。
strtok()函数</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://windypath.com/en/posts/java_juc_briefly/><span class=title>« Prev</span><br><span>Various Locking Mechanisms in Java Concurrency Programming</span>
</a><a class=next href=https://windypath.com/en/posts/about_myself/><span class=title>Next »</span><br><span>My Self-introduction</span></a></nav></footer></article></main><footer class=footer><span>Windypath 风萧古道 <strong>For Chinese Software</strong>. <a href=https://beian.miit.gov.cn/>闽ICP备15016446号-3</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>