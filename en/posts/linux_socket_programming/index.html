<!doctype html><html lang=en dir=auto><head><style>:root{--sys-font-family:"Noto Serif SC";--zh-font-family:"Noto Serif SC";--base-font-family:"Noto Serif SC";--code-font-family:"Noto Serif SC";--article-font-family:"Noto Serif SC"}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux C++ Socket in Action | WindyPath - Study And Practice, Years Of It</title>
<meta name=keywords content="Linux,Socket"><meta name=description content="This article primarily introduces the basics of Linux C++ Socket network programming. Most of the knowledge is sourced from the website: https://www.geeksforgeeks.org/socket-programming-cc/
Socket Programming State Diagram From the diagram, we can see that the server side needs to go through four steps to enter the &ldquo;waiting for connection&rdquo; state, while the client side only requires two.
Brief Analysis of Socket Programming Functions This analysis is for personal understanding and may have some omissions."><meta name=author content="JohnathanLin"><link rel=canonical href=https://windypath.com/en/posts/linux_socket_programming/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.eac269fd456bbc5decf5ec3fed956c33a791c95561d9ffc47422c34d673f662d.css integrity="sha256-6sJp/UVrvF3s9ew/7ZVsM6eRyVVh2f/EdCLDTWc/Zi0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://windypath.com/posts/linux_socket_programming/><link rel=alternate hreflang=en href=https://windypath.com/en/posts/linux_socket_programming/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Linux C++ Socket in Action"><meta property="og:description" content="This article primarily introduces the basics of Linux C++ Socket network programming. Most of the knowledge is sourced from the website: https://www.geeksforgeeks.org/socket-programming-cc/
Socket Programming State Diagram From the diagram, we can see that the server side needs to go through four steps to enter the &ldquo;waiting for connection&rdquo; state, while the client side only requires two.
Brief Analysis of Socket Programming Functions This analysis is for personal understanding and may have some omissions."><meta property="og:type" content="article"><meta property="og:url" content="https://windypath.com/en/posts/linux_socket_programming/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-30T23:23:49+08:00"><meta property="article:modified_time" content="2022-04-30T23:23:49+08:00"><meta property="og:site_name" content="Windypath"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux C++ Socket in Action"><meta name=twitter:description content="This article primarily introduces the basics of Linux C++ Socket network programming. Most of the knowledge is sourced from the website: https://www.geeksforgeeks.org/socket-programming-cc/
Socket Programming State Diagram From the diagram, we can see that the server side needs to go through four steps to enter the &ldquo;waiting for connection&rdquo; state, while the client side only requires two.
Brief Analysis of Socket Programming Functions This analysis is for personal understanding and may have some omissions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windypath.com/en/posts/"},{"@type":"ListItem","position":2,"name":"Linux C++ Socket in Action","item":"https://windypath.com/en/posts/linux_socket_programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux C++ Socket in Action","name":"Linux C\u002b\u002b Socket in Action","description":"This article primarily introduces the basics of Linux C++ Socket network programming. Most of the knowledge is sourced from the website: https://www.geeksforgeeks.org/socket-programming-cc/\nSocket Programming State Diagram From the diagram, we can see that the server side needs to go through four steps to enter the \u0026ldquo;waiting for connection\u0026rdquo; state, while the client side only requires two.\nBrief Analysis of Socket Programming Functions This analysis is for personal understanding and may have some omissions.","keywords":["Linux","Socket"],"articleBody":" This article primarily introduces the basics of Linux C++ Socket network programming. Most of the knowledge is sourced from the website: https://www.geeksforgeeks.org/socket-programming-cc/\nSocket Programming State Diagram From the diagram, we can see that the server side needs to go through four steps to enter the “waiting for connection” state, while the client side only requires two.\nBrief Analysis of Socket Programming Functions This analysis is for personal understanding and may have some omissions. If there are any, please correct them. The original article summarizes the knowledge better than I do. Please refer to the original article as much as possible. My understanding is only for auxiliary purposes.\nServer Let’s start with the server. The server needs to specify a port and listen, so it needs to use bind() to bind the port, use listen() to enter the listening state, and then use accept() to block and wait for messages from the client.\nC++ including:\n#include socket() setsockopt() bind() listen() accept() #include struct sockaddr_in #include read() #include inet_pton() socket() This function is used to create a socket. Among the three parameters, the first two are particularly important. It returns a socket number, which is an integer value.\nint sockfd = socket(domain, type, protocol)\ndomain: Use AF_INET for IPv4, and AF_INET6 for IPv6. type: Use SOCK_STREAM for TCP, and SOCK_DGRAM for UDP.\nsetsockopt() This function is used to set properties for the socket returned by the socket() function above. As a server, for convenience, you can set the options for address and port reuse.\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);\nTo reuse the address and port, you need to do the following:\nSet level to SOL_SOCKET, which represents which module the property value you are setting is for. Set optname to SO_REUSEADDR|SO_REUSEPORT, which means you intend to set both of these properties at the same time. optval should be a pointer to an int, pointing to a specific number. optlen should be sizeof() of the above optval. Many C++ socket functions require you to pass a length to determine how long the data you really want to pass to this function is.\nsockaddr_in So how is an address represented in socket programming? It’s defined using struct sockaddr_in.\nWhen using it, you need to set three values: sin_family, sin_addr.s_addr, and sin_port.\nsin_family: Same as the domain parameter in the socket() function, it’s AF_INET. sin_addr.s_addr: This property converts our dotted decimal IP address into a number, and it requires a dedicated function for processing, such as inet_pton(). sin_port: Specifies the port number, but it’s not directly passed as an integer. You need to use htons() to convert it into a hexadecimal number. bind() This function is used to bind address information to a socket.\nIn the previous section, we discussed how to set up the address. In this section, we’ll talk about binding the socket with an address.\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nAs usual, associate sockFd with the address.\nNote: The type of addr here is struct sockaddr *, not struct sockaddr_in *. The structure of struct sockaddr does not provide properties to hold the IP address and port number, so you need to use struct sockaddr_in for type casting. In the documentation, the author mentions that the lengths of struct sockaddr and struct sockaddr_in must be the same, so you can definitely perform the type casting without worry. https://www.gta.ufrj.br/ensino/eel878/sockets/sockaddr_inman.html Note that addrlen later is a value, not a pointer.\nlisten() int listen(int sockfd, int backlog);\nThis function switches the socket to passive mode, entering the listening state. The second parameter backlog specifies the maximum length of the message waiting queue.\naccept() int new_socket= accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); After this function is executed, the socket will wait for a client connection. Once the connection is established, it returns a new socket for communication between the client and server.\nNote: The third parameter socklen_t *addrlen of accept() is different from the third parameter socklen_t addrlen of bind(). accept() requires a pointer. Some say that the parameter of accept() is a bidirectional parameter and will update the length value of the address. However, others say that in the accept() function, it doesn’t know if an int can hold this length. If the length is particularly large, it might not be suitable for storage. To ensure a uniform storage structure, just pass a pointer.\nsend() send() is used to send messages to the other party through the socket.\nread() The read() function is included in #include . It uses a char array to store the received message.\nClient Now let’s talk about the client. The client needs to specify the IP address and port number, and then initiate the connection.\nconnect() int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nThe client also needs to create a socket, specify sockaddr_in, and then typecast. This socket is responsible not only for initiating the connection but also for sending and receiving data.\nSample Code (Without Error Handling) Currently, I only want to learn these low-level socket APIs, so I don’t want to spend too much effort on memorizing what the return values of the APIs might indicate in terms of errors. I just want to focus on successfully implementing a very basic server and client.\nServer-side Code: server.cpp\n#include #include #include #include #include using namespace std; #define PORT 8000 int main() { int sockFd, newSockFd, valread; int opt = 1; char buffer[1024] = {0}; char* helloFromServer = \"hello from server\"; struct sockaddr_in address; sockFd = socket(AF_INET, SOCK_STREAM, 0); setsockopt(sockFd, SOL_SOCKET, SO_REUSEADDR|SO_REUSEPORT, \u0026opt, sizeof(opt)); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); int addrlen = sizeof(address); bind(sockFd, (struct sockaddr*)\u0026address, addrlen); listen(sockFd, 3); newSockFd = accept(sockFd, (struct sockaddr*)\u0026address, (socklen_t*)\u0026addrlen); read(newSockFd, buffer, 1024); printf(\"receive: %s\\n\", buffer); send(newSockFd, helloFromServer, strlen(helloFromServer), 0); printf(\"server sent message\\n\"); return 0; } Client-side Code: client.cpp\n#include #include #include #include #include #include #define PORT 8000 using namespace std; int main() { int sockFd = 0; char buffer[1024] = {0}; char* helloFromClient = \"hello from client\"; struct sockaddr_in address; address.sin_family = AF_INET; inet_pton(AF_INET, \"127.0.0.1\", \u0026address.sin_addr.s_addr); address.sin_port = htons(PORT); sockFd = socket(AF_INET, SOCK_STREAM, 0); connect(sockFd, (struct sockaddr*)\u0026address, sizeof(address)); send(sockFd, helloFromClient, strlen(helloFromClient), 0); printf(\"client sent\\n\"); read(sockFd, buffer, 1024); printf(\"read message:%s\\n\", buffer); return 0; } Compilation, Execution, and Targeted Output In the Linux command line, input the following separately:\ng++ -o server server.cpp g++ -o client client.cpp Then open two terminals, and input the following respectively:\n./server ./client The expected outputs are:\nFor the server:\nreceive: hello from client server sent message client输出：\nclient sent message receive: hello from server ","wordCount":"1107","inLanguage":"en","datePublished":"2022-04-30T23:23:49+08:00","dateModified":"2022-04-30T23:23:49+08:00","author":{"@type":"Person","name":"JohnathanLin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://windypath.com/en/posts/linux_socket_programming/"},"publisher":{"@type":"Organization","name":"WindyPath - Study And Practice, Years Of It","logo":{"@type":"ImageObject","url":"https://windypath.com/%3Clink%20/%20abs%20url%3E"}}}</script><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ")</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windypath.com/en/ accesskey=h title="Windypath (Alt + H)">Windypath</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windypath.com/ title=点击这里切换中文网站 aria-label=点击这里切换中文网站>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://windypath.com/en/archives/ title=ARCHIVES><span>ARCHIVES</span></a></li><li><a href=https://windypath.com/en/categories/ title=CATEGORIES><span>CATEGORIES</span></a></li><li><a href=https://windypath.com/en/about/ title=ABOUT><span>ABOUT</span></a></li><li><a href=https://windypath.com/en/mybooks/ title="MY BOOKS"><span>MY BOOKS</span></a></li><li><a href=https://windypath.com/en/myfriends/ title="MY FRIENDS"><span>MY FRIENDS</span></a></li><li><a href=https://windypath.com/en/search/ title="SEARCH (Alt + /)" accesskey=/><span>SEARCH</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Linux C++ Socket in Action</h1><div class=post-meta>&lt;span title='2022-04-30 23:23:49 +0800 +0800'>April 30, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;JohnathanLin&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://windypath.com/posts/linux_socket_programming/>Zh</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#socket-programming-state-diagram aria-label="Socket Programming State Diagram">Socket Programming State Diagram</a></li><li><a href=#brief-analysis-of-socket-programming-functions aria-label="Brief Analysis of Socket Programming Functions">Brief Analysis of Socket Programming Functions</a><ul><li><a href=#server aria-label=Server>Server</a><ul><li><a href=#socket aria-label=socket()>socket()</a></li><li><a href=#setsockopt aria-label=setsockopt()>setsockopt()</a></li><li><a href=#sockaddr_in aria-label=sockaddr_in>sockaddr_in</a></li><li><a href=#bind aria-label=bind()>bind()</a></li><li><a href=#listen aria-label=listen()>listen()</a></li><li><a href=#accept aria-label=accept()>accept()</a></li><li><a href=#send aria-label=send()>send()</a></li><li><a href=#read aria-label=read()>read()</a></li></ul></li><li><a href=#client aria-label=Client>Client</a><ul><li><a href=#connect aria-label=connect()>connect()</a></li></ul></li><li><a href=#sample-code-without-error-handling aria-label="Sample Code (Without Error Handling)">Sample Code (Without Error Handling)</a><ul><li><a href=#server-side-code aria-label="Server-side Code:">Server-side Code:</a></li><li><a href=#client-side-code aria-label="Client-side Code:">Client-side Code:</a></li><li><a href=#compilation-execution-and-targeted-output aria-label="Compilation, Execution, and Targeted Output">Compilation, Execution, and Targeted Output</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>This article primarily introduces the basics of Linux C++ Socket network programming.
Most of the knowledge is sourced from the website: <a href=https://www.geeksforgeeks.org/socket-programming-cc/>https://www.geeksforgeeks.org/socket-programming-cc/</a></p></blockquote><h2 id=socket-programming-state-diagram>Socket Programming State Diagram<a hidden class=anchor aria-hidden=true href=#socket-programming-state-diagram>#</a></h2><p><img loading=lazy src=/images/StatediagramforserverandclientmodelofSocketdrawio2-448x660.png alt></p><p>From the diagram, we can see that the server side needs to go through four steps to enter the &ldquo;waiting for connection&rdquo; state, while the client side only requires two.</p><h2 id=brief-analysis-of-socket-programming-functions>Brief Analysis of Socket Programming Functions<a hidden class=anchor aria-hidden=true href=#brief-analysis-of-socket-programming-functions>#</a></h2><p>This analysis is for personal understanding and may have some omissions. If there are any, please correct them.
The original article summarizes the knowledge better than I do. Please refer to the original article as much as possible. My understanding is only for auxiliary purposes.</p><h3 id=server>Server<a hidden class=anchor aria-hidden=true href=#server>#</a></h3><p>Let&rsquo;s start with the server. The server needs to specify a port and listen, so it needs to use bind() to bind the port, use listen() to enter the listening state, and then use accept() to block and wait for messages from the client.</p><p>C++ including:</p><ul><li>#include &lt;sys/socket><ul><li>socket()</li><li>setsockopt()</li><li>bind()</li><li>listen()</li><li>accept()</li></ul></li><li>#include &lt;netinet/in.h><ul><li>struct sockaddr_in</li></ul></li><li>#include &lt;unistd.h><ul><li>read()</li></ul></li><li>#include &lt;arpa/inet.h><ul><li>inet_pton()</li></ul></li></ul><h4 id=socket>socket()<a hidden class=anchor aria-hidden=true href=#socket>#</a></h4><p>This function is used to create a socket. Among the three parameters, the first two are particularly important. It returns a socket number, which is an integer value.</p><blockquote><p>int sockfd = socket(domain, type, protocol)</p></blockquote><p>domain: Use AF_INET for IPv4, and AF_INET6 for IPv6.
type: Use SOCK_STREAM for TCP, and SOCK_DGRAM for UDP.</p><h4 id=setsockopt>setsockopt()<a hidden class=anchor aria-hidden=true href=#setsockopt>#</a></h4><p>This function is used to set properties for the socket returned by the socket() function above. As a server, for convenience, you can set the options for address and port reuse.</p><blockquote><p>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</p></blockquote><p>To reuse the address and port, you need to do the following:</p><ul><li>Set level to SOL_SOCKET, which represents which module the property value you are setting is for.</li><li>Set optname to SO_REUSEADDR|SO_REUSEPORT, which means you intend to set both of these properties at the same time.</li><li>optval should be a pointer to an int, pointing to a specific number.</li><li>optlen should be sizeof() of the above optval.</li></ul><p>Many C++ socket functions require you to pass a length to determine how long the data you really want to pass to this function is.</p><h4 id=sockaddr_in>sockaddr_in<a hidden class=anchor aria-hidden=true href=#sockaddr_in>#</a></h4><p>So how is an address represented in socket programming? It&rsquo;s defined using struct sockaddr_in.</p><p>When using it, you need to set three values: sin_family, sin_addr.s_addr, and sin_port.</p><ul><li>sin_family: Same as the domain parameter in the socket() function, it&rsquo;s AF_INET.</li><li>sin_addr.s_addr: This property converts our dotted decimal IP address into a number, and it requires a dedicated function for processing, such as inet_pton().</li><li>sin_port: Specifies the port number, but it&rsquo;s not directly passed as an integer. You need to use htons() to convert it into a hexadecimal number.</li></ul><h4 id=bind>bind()<a hidden class=anchor aria-hidden=true href=#bind>#</a></h4><p>This function is used to bind address information to a socket.</p><p>In the previous section, we discussed how to set up the address. In this section, we&rsquo;ll talk about binding the socket with an address.</p><blockquote><p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p></blockquote><p>As usual, associate sockFd with the address.</p><blockquote><p>Note: The type of addr here is struct sockaddr *, not struct sockaddr_in *.
The structure of struct sockaddr does not provide properties to hold the IP address and port number, so you need to use struct sockaddr_in for type casting.
In the documentation, the author mentions that the lengths of struct sockaddr and struct sockaddr_in must be the same, so you can definitely perform the type casting without worry.
<a href=https://www.gta.ufrj.br/ensino/eel878/sockets/sockaddr_inman.html>https://www.gta.ufrj.br/ensino/eel878/sockets/sockaddr_inman.html</a>
Note that addrlen later is a value, not a pointer.</p></blockquote><h4 id=listen>listen()<a hidden class=anchor aria-hidden=true href=#listen>#</a></h4><blockquote><p>int listen(int sockfd, int backlog);</p></blockquote><p>This function switches the socket to passive mode, entering the listening state. The second parameter backlog specifies the maximum length of the message waiting queue.</p><h4 id=accept>accept()<a hidden class=anchor aria-hidden=true href=#accept>#</a></h4><blockquote><p>int new_socket= accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
After this function is executed, the socket will wait for a client connection. Once the connection is established, it returns a new socket for communication between the client and server.</p></blockquote><blockquote><p>Note: The third parameter socklen_t *addrlen of accept() is different from the third parameter socklen_t addrlen of bind(). accept() requires a pointer.
Some say that the parameter of accept() is a bidirectional parameter and will update the length value of the address. However, others say that in the accept() function, it doesn&rsquo;t know if an int can hold this length. If the length is particularly large, it might not be suitable for storage. To ensure a uniform storage structure, just pass a pointer.</p></blockquote><h4 id=send>send()<a hidden class=anchor aria-hidden=true href=#send>#</a></h4><p>send() is used to send messages to the other party through the socket.</p><h4 id=read>read()<a hidden class=anchor aria-hidden=true href=#read>#</a></h4><p>The read() function is included in #include &lt;unistd.h>. It uses a char array to store the received message.</p><h3 id=client>Client<a hidden class=anchor aria-hidden=true href=#client>#</a></h3><p>Now let&rsquo;s talk about the client. The client needs to specify the IP address and port number, and then initiate the connection.</p><h4 id=connect>connect()<a hidden class=anchor aria-hidden=true href=#connect>#</a></h4><blockquote><p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p></blockquote><p>The client also needs to create a socket, specify sockaddr_in, and then typecast. This socket is responsible not only for initiating the connection but also for sending and receiving data.</p><h3 id=sample-code-without-error-handling>Sample Code (Without Error Handling)<a hidden class=anchor aria-hidden=true href=#sample-code-without-error-handling>#</a></h3><p>Currently, I only want to learn these low-level socket APIs, so I don&rsquo;t want to spend too much effort on memorizing what the return values of the APIs might indicate in terms of errors. I just want to focus on successfully implementing a very basic server and client.</p><h4 id=server-side-code>Server-side Code:<a hidden class=anchor aria-hidden=true href=#server-side-code>#</a></h4><p>server.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#75715e>#define PORT 8000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockFd, newSockFd, valread;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> opt <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>1024</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> helloFromServer <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello from server&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> address;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sockFd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    setsockopt(sockFd, SOL_SOCKET, SO_REUSEADDR<span style=color:#f92672>|</span>SO_REUSEPORT, <span style=color:#f92672>&amp;</span>opt, <span style=color:#66d9ef>sizeof</span>(opt));
</span></span><span style=display:flex><span>    address.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    address.sin_addr.s_addr <span style=color:#f92672>=</span> INADDR_ANY;
</span></span><span style=display:flex><span>    address.sin_port <span style=color:#f92672>=</span> htons(PORT);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> addrlen <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(address);
</span></span><span style=display:flex><span>    bind(sockFd, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>address, addrlen);
</span></span><span style=display:flex><span>    listen(sockFd, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    newSockFd <span style=color:#f92672>=</span> accept(sockFd, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>address, (socklen_t<span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addrlen);
</span></span><span style=display:flex><span>    read(newSockFd, buffer, <span style=color:#ae81ff>1024</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;receive: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buffer);
</span></span><span style=display:flex><span>    send(newSockFd, helloFromServer, strlen(helloFromServer), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;server sent message</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=client-side-code>Client-side Code:<a hidden class=anchor aria-hidden=true href=#client-side-code>#</a></h4><p>client.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PORT 8000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockFd <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>1024</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> helloFromClient <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello from client&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> address;
</span></span><span style=display:flex><span>    address.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    inet_pton(AF_INET, <span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, <span style=color:#f92672>&amp;</span>address.sin_addr.s_addr);
</span></span><span style=display:flex><span>    address.sin_port <span style=color:#f92672>=</span> htons(PORT);
</span></span><span style=display:flex><span>    sockFd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    connect(sockFd, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>address, <span style=color:#66d9ef>sizeof</span>(address));
</span></span><span style=display:flex><span>    send(sockFd, helloFromClient, strlen(helloFromClient), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;client sent</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    read(sockFd, buffer, <span style=color:#ae81ff>1024</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;read message:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buffer);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=compilation-execution-and-targeted-output>Compilation, Execution, and Targeted Output<a hidden class=anchor aria-hidden=true href=#compilation-execution-and-targeted-output>#</a></h4><p>In the Linux command line, input the following separately:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>g++ -o server server.cpp
</span></span><span style=display:flex><span>g++ -o client client.cpp
</span></span></code></pre></div><p>Then open two terminals, and input the following respectively:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./server
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./client
</span></span></code></pre></div><p>The expected outputs are:</p><p>For the server:</p><pre tabindex=0><code>receive: hello from client
server sent message
</code></pre><p>client输出：</p><pre tabindex=0><code>client sent message
receive: hello from server
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://windypath.com/en/tags/linux/>Linux</a></li><li><a href=https://windypath.com/en/tags/socket/>Socket</a></li></ul><nav class=paginav><a class=prev href=https://windypath.com/en/posts/about_java_treeset/><span class=title>« Prev</span><br><span>Some Usage and features on Java TreeSet</span>
</a><a class=next href=https://windypath.com/en/posts/compare_web_with_game_server/><span class=title>Next »</span><br><span>Traditional Software Server vs. Game Server Architecture Differences</span></a></nav></footer></article></main><footer class=footer><span>Windypath 风萧古道 <strong>For Chinese Software</strong>. <a href=https://beian.miit.gov.cn/>闽ICP备15016446号-3</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>