[{"content":"Preface During a coding interview, I encountered a question that involved two lines of input. Each line contained an unknown number of numbers separated by spaces. The input format was as follows:\n12 34 567 888 99 100 358 74 58454 742 4469 88 They did not provide the number of digits in each line in advance. Instead, they required the user to split them themselves.\nDuring the coding exam, I didn\u0026rsquo;t implement this functionality using C++, but instead used the split() method available in Java to handle it.\nLater, after the exam was over, I searched online for ways to split strings in C++, and I found that C++ does not have a built-in method similar to split(character) like in Java.\nSo, what methods can be used as alternatives?\nMethod 1: Splitting using string\u0026rsquo;s find() function along with substr() According to the response from a Zhihu user, the first solution they suggested is:\nC++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/36642771/answer/865135551\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; void split(const std::string\u0026amp; s, std::vector\u0026lt;std::string\u0026gt;\u0026amp; tokens, const std::string\u0026amp; delimiters = \u0026#34; \u0026#34;) { std::string::size_type lastPos = s.find_first_not_of(delimiters, 0); std::string::size_type pos = s.find_first_of(delimiters, lastPos); while (std::string::npos != pos || std::string::npos != lastPos) { tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s.find_first_not_of(delimiters, pos); pos = s.find_first_of(delimiters, lastPos); } } int main() { std::string str = \u0026#34;12 34 567 888 99 100\u0026#34;; std::vector\u0026lt;std::string\u0026gt; res; split(str, res, \u0026#34; \u0026#34;); for (auto r: res) { printf(\u0026#34;%s\\n\u0026#34;, r.c_str()); } return 0; } The output is：\n12 34 567 888 99 100 The split() function works by keeping track of two indices to determine the substrings to be extracted:\nThe first index, lastPos, finds the index of the first character after the start of the string that is not a delimiter. The second index, pos, finds the index of the first character after lastPos that is a delimiter. By doing this, the substring between lastPos and pos is the portion of the string that needs to be extracted. After extracting the first substring, both indices are moved forward according to the previous logic, until both indices cannot find suitable values (returning string::npos). This marks the end of the process.\nFunction Introduction: find_first_of() The find_first_of() function of string takes two parameters. The first parameter is the character to search for, which can be a string, char*, or char. The second parameter is the index to start searching from (it is optional and defaults to 0). It searches from the specified index onward until it finds the character being searched for, and then returns the index where the character is found.\nfind_first_not_of() The find_first_not_of() function of string accepts the same parameters as find_first_of(). However, it searches until it encounters a character that is not in the search characters. It returns the index of the first character that is not part of the search characters.\nsubstr() The substr() function is used to extract a substring from a string. It takes two parameters, pos and len, indicating the starting position and the length of the substring to be extracted. The original string is not modified.\nC++ document location：\nfind_first_of()：https://cplusplus.com/reference/string/string/find_first_of/\nfind_first_not_of()：https://cplusplus.com/reference/string/string/find_first_not_of/\nsubstr()：https://cplusplus.com/reference/string/string/substr/\nMethod 2：C++11 regular expression #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;regex\u0026gt; int main() { std::string str = \u0026#34;12 34 567 888 99 100\u0026#34;; std::regex ws_re(\u0026#34;\\\\s+\u0026#34;); std::vector\u0026lt;std::string\u0026gt; res( std::sregex_token_iterator( str.begin(), str.end(), ws_re, -1 ), std::sregex_token_iterator() ); for (auto r: res) { printf(\u0026#34;%s\\n\u0026#34;, r.c_str()); } return 0; } This example comes from the introduction to regex token iterator.\nhttps://en.cppreference.com/w/cpp/regex/regex_token_iterator\nUsing the sregex_token_iterator() iterator for splitting operations (where s refers to a string type). In this example, in lines 9-11, a sregex_token_iterator iterator is constructed with four parameters: the iterator to the beginning of the string, the iterator to the end of the string, a regular expression object, and whether to use the matched parts (0 for using, -1 for not using).\nBy constructing the sregex_token_iterator(), it is determined to start searching from the beginning of the string and continue until the end of the string, using regular expression matching, and finding the unmatched parts.\nThe end of this iterator is represented by a default-constructed sregex_token_iterator() object.\nIn the constructor of vector, by passing in two iterators, the elements between the iterators can be obtained.\nMethod 3: Splitting strings using stringstream (supports only space, newline, tab) Source：https://www.cnblogs.com/narjaja/p/10044157.html\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::string str = \u0026#34;12 34 567 888 99 100\u0026#34;; std::vector\u0026lt;std::string\u0026gt; res; std::istringstream ss(str); std::string word; while(ss\u0026gt;\u0026gt;word) { res.push_back(word); } for (auto r: res) { printf(\u0026#34;%s\\n\u0026#34;, r.c_str()); } return 0; } By using the \u0026raquo; operator in C++, similar to how cin works for user input, we can \u0026ldquo;input\u0026rdquo; a string and achieve the splitting effect.\nIf you want to support custom delimiters, you can use getline() for handling.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { std::string data = \u0026#34;1_2_3_4_5_6\u0026#34;; std::stringstream ss(data); std::string item; cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; while (std::getline(ss, item, \u0026#39;_\u0026#39;)) cout \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } Method 4: Implementing with the C function strtok() The first incorrect approach Another approach is to use the strtok() function from C language for handling the string splitting.\nOn the internet, you may come across code structures similar to the following:\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { char str[] = \u0026#34;A B C D\u0026#34;; char* p = strtok(str, \u0026#34; \u0026#34;); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; while (p != NULL) { p = strtok(NULL, \u0026#34; \u0026#34;); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; } return 0; } The output is：\nA B C D However, when I attempted to perform a cout output on line 11, I found that the result was not displayed correctly:\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { char str[] = \u0026#34;A B C D\u0026#34;; char* p = strtok(str, \u0026#34; \u0026#34;); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; while (p != NULL) { p = strtok(NULL, \u0026#34; \u0026#34;); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;abc\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } The output is：\nA B C D The final \u0026ldquo;abc\u0026rdquo; is missing in the output。\nAfter consulting with ChatGPT, the explanation received is as follows:\nThe issue in this C++ code is that when iterating and outputting the split substrings, the value of p is printed first before proceeding to the next iteration. This causes the value of p to be set as NULL after the last iteration, and then attempting to print the value of p leads to undefined behavior.\nIn line 8, you print the value of p and then in line 9, it is set to the next split substring. Then, in line 10, when the loop begins again, you print the value of p again, but at this point, it may already be NULL, resulting in undefined behavior.\nTo fix this issue, you can move the printing statement to the end of the loop, so that the value of p is printed after proceeding to the next iteration, ensuring that p is not NULL.\nHere is the corrected code:\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { char str[] = \u0026#34;A B C D\u0026#34;; char* p = strtok(str, \u0026#34; \u0026#34;); while (p != NULL) { std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; p = strtok(NULL, \u0026#34; \u0026#34;); } std::cout \u0026lt;\u0026lt; \u0026#34;abc\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } After making this modification, the code will correctly output the split substrings and then output \u0026ldquo;abc\u0026rdquo;. Please note that std::endl is used to add a newline character after the output to ensure the correct formatting of the output result.\nThe second incorrect approach #include \u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { char s[] = \u0026#34;A B C D\u0026#34;; char *p; const char *d = \u0026#34; \u0026#34;; p = strtok(s, d); while(p) { printf(\u0026#34;%s\\n\u0026#34;, p); p = strtok(NULL, \u0026#34; \u0026#34;); } printf(\u0026#34;abc\u0026#34;); return 0; } This time, we output the previous split p first within the loop body and then read the next p. However, the string \u0026ldquo;abc\u0026rdquo; still doesn\u0026rsquo;t output correctly. Here\u0026rsquo;s ChatGPT\u0026rsquo;s answer:\nChatGPT:\nThe reason why \u0026ldquo;abc\u0026rdquo; cannot be output correctly in this code is that when using the strtok function to split the string, it replaces the delimiter in the original string with a null character \u0026lsquo;\\0\u0026rsquo; to separate the substrings. This modification alters the original string s, and subsequent printf statements will terminate prematurely when encountering \u0026lsquo;\\0\u0026rsquo;.\nIn the code, the content of the original string s is \u0026ldquo;A B C D\u0026rdquo;, and strtok(s, d) will split it into four substrings: \u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;, \u0026ldquo;C\u0026rdquo;, and \u0026ldquo;D\u0026rdquo;. Therefore, the printf statement in the loop will output these four substrings: \u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;, \u0026ldquo;C\u0026rdquo;, and \u0026ldquo;D\u0026rdquo;.\nThen, in the last call to strtok(NULL, \u0026quot; \u0026ldquo;), since there are no more delimiters, strtok will return NULL and terminate the loop. Subsequently, the printf(\u0026ldquo;abc\u0026rdquo;) statement in the code will attempt to output \u0026ldquo;abc\u0026rdquo;. However, due to the previous strtok calls modifying the original string s and replacing the spaces with \u0026lsquo;\\0\u0026rsquo;, when reaching the printf statement, the function encounters the \u0026lsquo;\\0\u0026rsquo; character, treating it as the end of the string and causing the output to terminate prematurely.\nIf you want to output \u0026ldquo;abc\u0026rdquo;, you can add a newline character \\n to the printf statement as shown below:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char s[] = \u0026#34;A B C D\u0026#34;; char *p; const char *d = \u0026#34; \u0026#34;; p = strtok(s, d); while (p) { printf(\u0026#34;%s\\n\u0026#34;, p); p = strtok(NULL, \u0026#34; \u0026#34;); } printf(\u0026#34;abc\\n\u0026#34;); // 在\u0026#34;abc\u0026#34;后添加换行符\\n return 0; } With the above modification, the code will be able to output \u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;, \u0026ldquo;C\u0026rdquo;, \u0026ldquo;D\u0026rdquo;, and \u0026ldquo;abc\u0026rdquo; correctly.\nstrtok() Function After the strtok() function performs the splitting, it fills the cut positions with \u0026lsquo;\\0\u0026rsquo;, thereby modifying the original string. Therefore, it is essential to exercise caution and use this function carefully. 通过上述修改，代码将能够正常输出\u0026quot;A\u0026rdquo;、\u0026ldquo;B\u0026rdquo;、\u0026ldquo;C\u0026rdquo;、\u0026ldquo;D\u0026quot;和\u0026quot;abc\u0026rdquo;。 strtok()函数\n","permalink":"https://windypath.com/en/posts/how_to_split_a_string_in_cpp/","summary":"Preface During a coding interview, I encountered a question that involved two lines of input. Each line contained an unknown number of numbers separated by spaces. The input format was as follows:\n12 34 567 888 99 100 358 74 58454 742 4469 88 They did not provide the number of digits in each line in advance. Instead, they required the user to split them themselves.\nDuring the coding exam, I didn\u0026rsquo;t implement this functionality using C++, but instead used the split() method available in Java to handle it.","title":"How To Split A String In C++?"},{"content":"Welcome Hello and welcome to WindyPath. I am the owner of this website. My English name is Johnathan.\nMy Chinese nickname is \u0026ldquo;凌虚\u0026rdquo; which comes from a Chinese animated film called The Legend of Qin. \u0026ldquo;凌虚\u0026rdquo; is the name of a sword that belong to Zhang Liang(张良), a famous strategist in the Warring Period. The name of this website is WindyPath, and its Chinese name is \u0026ldquo;风萧古道\u0026rdquo;.\nThe first two characters, \u0026ldquo;风萧\u0026rdquo; come from poetry \u0026ldquo;风萧萧兮易水寒\u0026rdquo; while the last two characters, \u0026ldquo;古道\u0026rdquo; are derived from poetry \u0026ldquo;古道西风瘦马\u0026rdquo;.\nAbout Me I work as a Game Server Engineer and I have previously developed website, including both frontend and backend. However, I no longer develop websites.\nI graduated from university in 2019, and I moved to ShangHai in December 2020.\nYou can read more about my computer story HERE.\nMy Idealism For a long time, I didn\u0026rsquo;t know what to study software development for. I have earned some money in these years, but I wanted to move forward in my career of software development. I am interested in developing Chinese software.\nFor Chinese Software My Articles I do not update my blog frequently, but I do browse articles on other blogs. I have noticed that some blogs have many articles that are little more than complaints or notes. These types of articles do not effectively improve software development.\nOn my blog, I only publish technology articles. Even if I feel compelled to complain about something, I always try to tie it back to a software development concept so that visitors can learn something from it.\nI post other daily life observations and complaints on my Twitter account.\nContact Email: windypathblog@gmail.com Telegram: @windypath\n","permalink":"https://windypath.com/en/posts/about_myself/","summary":"Welcome Hello and welcome to WindyPath. I am the owner of this website. My English name is Johnathan.\nMy Chinese nickname is \u0026ldquo;凌虚\u0026rdquo; which comes from a Chinese animated film called The Legend of Qin. \u0026ldquo;凌虚\u0026rdquo; is the name of a sword that belong to Zhang Liang(张良), a famous strategist in the Warring Period. The name of this website is WindyPath, and its Chinese name is \u0026ldquo;风萧古道\u0026rdquo;.\nThe first two characters, \u0026ldquo;风萧\u0026rdquo; come from poetry \u0026ldquo;风萧萧兮易水寒\u0026rdquo; while the last two characters, \u0026ldquo;古道\u0026rdquo; are derived from poetry \u0026ldquo;古道西风瘦马\u0026rdquo;.","title":"My Self-introduction"},{"content":"Click here to download my virtual machine image Download virtual machine image:\nLink：https://pan.baidu.com/s/1yfY0SjDrtOeuTiEWf7YizA?pwd=374l\nFetch Code：374l\nMy VirtualBox version is 6.1\nLet me talk about nostalgic For most people, Win95 is their youth, so they create UI component library React95, or create an OS serenity together. But for most Chinese people, when they got PC in 2000-2010, they used Windows XP in their PC.\nsh1zuku is from China, Taiwan, he created a Windows XP simulator on website: Project Link, Online Demo, and another programmer from Vietnam wrote a Windows 7 Simulator on website Online Demo.\nHonestly, I don\u0026rsquo;t have enough ability to develop simulator program like them, but I have an idea that I can install a Windows XP virtual machine on my PC.\nThe steps you might choose Install VirtualBox. Download Image: Find Windows XP Image in MSDN Itellyou and then download it. Install the Image in VirtualBox. Run the installed image, and install the OS. Then, you will discover that the Windows XP only has 30-day trail. In the early 2000s, piracy was rampant, and Microsoft took strong measures to limit it. Even if you enter the correct serial number when you install, Microsoft will ask you to activate using a phone, etc.\nBut I just want to experienct the old OS in my PC! (It\u0026rsquo;s too hard for me to activate a copyrighted WinXP!)\nThe Right Solution So I don\u0026rsquo;t use this copyrighted WinXP image anymore, I should search some WinXP image without activation.\nHere, I found github WinXPImage from Github, but his Image file saved on Google Drive. I have downloaded that and uploaded to Baidu Cloud:\nLink：https://pan.baidu.com/s/1ypKeaZixJXnbqAo4ZT0YLQ?pwd=30dd Fetch Code：30dd\nWhen you install this image on VirtualBox, you will get a WinXP(English Edition) that you can use indefinitely.\nBut you may not be able to start this Image successfully, you should execute this after importing the OVA File:\nvbox-img geometry --filename Windows_XP_Professional-disk1.vdi --format VDI --cylinders 5874 --heads 255 --sectors 56 From github issue streeg\u0026rsquo;s solution.\nHow to Chinesize Windows XP? I want to use Chinese Windows XP to reminisce about the past, but this image doesn\u0026rsquo;t have Chinese language support.\nAfter searching many source, I finally found a language package mui_win_xp_pro_n_cd1 in here.\nI downloaded it and uploaded to Baidu Cloud:\nLink：https://pan.baidu.com/s/18mW9OCRejMDoEpUcih-zlA?pwd=peu4\nFetch Code：peu4\nThen,\nConfigure share folder in Windows XP virtual machine. Source Transfer mui_win_xp_pro_n_cd1.iso to Windows XP virtual machine by share folder. Install it, Source Finally, reboot Windows XP virtual machine.\nScreenshot: ","permalink":"https://windypath.com/en/posts/nostalgic_winxp/","summary":"Click here to download my virtual machine image Download virtual machine image:\nLink：https://pan.baidu.com/s/1yfY0SjDrtOeuTiEWf7YizA?pwd=374l\nFetch Code：374l\nMy VirtualBox version is 6.1\nLet me talk about nostalgic For most people, Win95 is their youth, so they create UI component library React95, or create an OS serenity together. But for most Chinese people, when they got PC in 2000-2010, they used Windows XP in their PC.\nsh1zuku is from China, Taiwan, he created a Windows XP simulator on website: Project Link, Online Demo, and another programmer from Vietnam wrote a Windows 7 Simulator on website Online Demo.","title":"Windows XP Virtual Machine Chinese Version Without Activation Image Download"},{"content":"An Example (kotlin) import java.util.TreeSet /** * Define a data class to test TreeSet Collection * Sort by TreeSet * id: player id * score: player score */ data class PlayerScore(var id: Int, var score: Int): Comparable\u0026lt;PlayerScore\u0026gt; { override fun compareTo(other: PlayerScore): Int { return if (score \u0026gt; other.score) { 1 } else if (score \u0026lt; other.score) { -1 } else { 0 } } } fun main() { //create a TreeSet val treeSet: TreeSet\u0026lt;PlayerScore\u0026gt; = TreeSet() //create 3 PlayerScore object，and use \u0026#39;id101Obj\u0026#39; reference to the first obj //put these objects into the treeset val id101Obj = PlayerScore(101,100) //put in different order treeSet.add(PlayerScore(102,200)) treeSet.add(id101Obj) treeSet.add(PlayerScore(103,300)) println(\u0026#34;Add the objects in a different order and print out by score from smallest to largest:\u0026#34;) showTreeSet(treeSet) println(\u0026#34;Add an object with duplicated id but different score, and print out by score from smallest to largest:\u0026#34;) treeSet.add(PlayerScore(101,500)) showTreeSet(treeSet) println(\u0026#34;Change the score of the object whose id is 101 to 400， and print out by score from smallest to largest:\u0026#34;) id101Obj.score = 400 showTreeSet(treeSet) } private fun showTreeSet(treeSet: TreeSet\u0026lt;PlayerScore\u0026gt;) { treeSet.forEachIndexed { index, s -\u0026gt; println(\u0026#34;rank:${index+1} score:${s.score} id:${s.id}\u0026#34;) } println() } Console output:\nAdd the objects in a different order and print out by score from smallest to largest: rank:1 score:100 id:101 rank:2 score:200 id:102 rank:3 score:300 id:103 Add an object with duplicated id but different score, and print out by score from smallest to largest: rank:1 score:100 id:101 rank:2 score:200 id:102 rank:3 score:300 id:103 rank:4 score:500 id:101 Change the score of the object whose id is 101 to 400， and print out by score from smallest to largest: rank:1 score:400 id:101 rank:2 score:200 id:102 rank:3 score:300 id:103 rank:4 score:500 id:101 Analysis First, PlayerScore implements Comparable interface , implements the function of sorting from smallest to largest. If there are only three data pieces at the beginning, insert them in different order, treeset does sort normally.\nThen, when player 101 score was changed, we need to resort. We tried 2 ways to resort.\nChange id101Obj\u0026rsquo;s score by reference. Add a new obj which id is 101 and has a new score into treeset. Result:\nid101Obj\u0026rsquo;s score was changed, but its rank is still 1. Although the score is sorted, it has two objects which id is 101. So how to resort treeset when player\u0026rsquo;s score was changed?\nOne solution is that you can remove the object from treeset, and change its score, then add it to treeset. This is because the underlying TreeSet is a red-black tree, and the tree structure is adjusted when it is deleted and inserted.\nCode:\n//create a TreeSet val treeSet: TreeSet\u0026lt;PlayerScore\u0026gt; = TreeSet() //create 3 PlayerScore object，and use \u0026#39;id101Obj\u0026#39; reference to the first obj //put these objects into the treeset val id101Obj = PlayerScore(101,100) //put in different order treeSet.add(PlayerScore(102,200)) treeSet.add(id101Obj) treeSet.add(PlayerScore(103,300)) println(\u0026#34;Add the objects in a different order and print out by score from smallest to largest:\u0026#34;) showTreeSet(treeSet) treeSet.remove(id101Obj) id101Obj.score = 400 treeSet.add(id101Obj) println(\u0026#34;remove id101Obj from TreeSet，change score，and then add to treeSet中， print out by score from smallest to largest:\u0026#34;) showTreeSet(treeSet) Console output:\nAdd the objects in a different order and print out by score from smallest to largest: rank:1 score:100 id:101 rank:2 score:200 id:102 rank:3 score:300 id:103 remove id101Obj from TreeSet，change score，and then add to treeSet中， print out by score from smallest to largest: rank:1 score:200 id:102 rank:2 score:300 id:103 rank:3 score:400 id:101 Move Forward The solution that \u0026ldquo;Remove it, edit it, and add it\u0026rdquo; can finish resort, but treeSet is thread-unsafe. If there are many threads update player\u0026rsquo;s score, it might be cause some problems.\nAlthough TreeSet can sort as it inserts, it only allow insert once. The modification of the score after insertion does not change the sorting.\nTreeSet doesn\u0026rsquo;t make sense for rank list that move around a lot.\nAnother Rank List Solution I use TreeSet because it can sort as it inserts, but it\u0026rsquo;s not appropriate for a rank list.\nSo, if So another way to think about it is, if you only use a longer ArrayList to store the player\u0026rsquo;s score object, you also sort it on insert/update/delete?\nInsert/update/delete, modify the data in the ArrayList, and then sort.\n","permalink":"https://windypath.com/en/posts/about_java_treeset/","summary":"An Example (kotlin) import java.util.TreeSet /** * Define a data class to test TreeSet Collection * Sort by TreeSet * id: player id * score: player score */ data class PlayerScore(var id: Int, var score: Int): Comparable\u0026lt;PlayerScore\u0026gt; { override fun compareTo(other: PlayerScore): Int { return if (score \u0026gt; other.score) { 1 } else if (score \u0026lt; other.score) { -1 } else { 0 } } } fun main() { //create a TreeSet val treeSet: TreeSet\u0026lt;PlayerScore\u0026gt; = TreeSet() //create 3 PlayerScore object，and use \u0026#39;id101Obj\u0026#39; reference to the first obj //put these objects into the treeset val id101Obj = PlayerScore(101,100) //put in different order treeSet.","title":"Some Usage and features on Java TreeSet"},{"content":" This article primarily introduces the basics of Linux C++ Socket network programming. Most of the knowledge is sourced from the website: https://www.geeksforgeeks.org/socket-programming-cc/\nSocket Programming State Diagram From the diagram, we can see that the server side needs to go through four steps to enter the \u0026ldquo;waiting for connection\u0026rdquo; state, while the client side only requires two.\nBrief Analysis of Socket Programming Functions This analysis is for personal understanding and may have some omissions. If there are any, please correct them. The original article summarizes the knowledge better than I do. Please refer to the original article as much as possible. My understanding is only for auxiliary purposes.\nServer Let\u0026rsquo;s start with the server. The server needs to specify a port and listen, so it needs to use bind() to bind the port, use listen() to enter the listening state, and then use accept() to block and wait for messages from the client.\nC++ including:\n#include \u0026lt;sys/socket\u0026gt; socket() setsockopt() bind() listen() accept() #include \u0026lt;netinet/in.h\u0026gt; struct sockaddr_in #include \u0026lt;unistd.h\u0026gt; read() #include \u0026lt;arpa/inet.h\u0026gt; inet_pton() socket() This function is used to create a socket. Among the three parameters, the first two are particularly important. It returns a socket number, which is an integer value.\nint sockfd = socket(domain, type, protocol)\ndomain: Use AF_INET for IPv4, and AF_INET6 for IPv6. type: Use SOCK_STREAM for TCP, and SOCK_DGRAM for UDP.\nsetsockopt() This function is used to set properties for the socket returned by the socket() function above. As a server, for convenience, you can set the options for address and port reuse.\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);\nTo reuse the address and port, you need to do the following:\nSet level to SOL_SOCKET, which represents which module the property value you are setting is for. Set optname to SO_REUSEADDR|SO_REUSEPORT, which means you intend to set both of these properties at the same time. optval should be a pointer to an int, pointing to a specific number. optlen should be sizeof() of the above optval. Many C++ socket functions require you to pass a length to determine how long the data you really want to pass to this function is.\nsockaddr_in So how is an address represented in socket programming? It\u0026rsquo;s defined using struct sockaddr_in.\nWhen using it, you need to set three values: sin_family, sin_addr.s_addr, and sin_port.\nsin_family: Same as the domain parameter in the socket() function, it\u0026rsquo;s AF_INET. sin_addr.s_addr: This property converts our dotted decimal IP address into a number, and it requires a dedicated function for processing, such as inet_pton(). sin_port: Specifies the port number, but it\u0026rsquo;s not directly passed as an integer. You need to use htons() to convert it into a hexadecimal number. bind() This function is used to bind address information to a socket.\nIn the previous section, we discussed how to set up the address. In this section, we\u0026rsquo;ll talk about binding the socket with an address.\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nAs usual, associate sockFd with the address.\nNote: The type of addr here is struct sockaddr *, not struct sockaddr_in *. The structure of struct sockaddr does not provide properties to hold the IP address and port number, so you need to use struct sockaddr_in for type casting. In the documentation, the author mentions that the lengths of struct sockaddr and struct sockaddr_in must be the same, so you can definitely perform the type casting without worry. https://www.gta.ufrj.br/ensino/eel878/sockets/sockaddr_inman.html Note that addrlen later is a value, not a pointer.\nlisten() int listen(int sockfd, int backlog);\nThis function switches the socket to passive mode, entering the listening state. The second parameter backlog specifies the maximum length of the message waiting queue.\naccept() int new_socket= accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); After this function is executed, the socket will wait for a client connection. Once the connection is established, it returns a new socket for communication between the client and server.\nNote: The third parameter socklen_t *addrlen of accept() is different from the third parameter socklen_t addrlen of bind(). accept() requires a pointer. Some say that the parameter of accept() is a bidirectional parameter and will update the length value of the address. However, others say that in the accept() function, it doesn\u0026rsquo;t know if an int can hold this length. If the length is particularly large, it might not be suitable for storage. To ensure a uniform storage structure, just pass a pointer.\nsend() send() is used to send messages to the other party through the socket.\nread() The read() function is included in #include \u0026lt;unistd.h\u0026gt;. It uses a char array to store the received message.\nClient Now let\u0026rsquo;s talk about the client. The client needs to specify the IP address and port number, and then initiate the connection.\nconnect() int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nThe client also needs to create a socket, specify sockaddr_in, and then typecast. This socket is responsible not only for initiating the connection but also for sending and receiving data.\nSample Code (Without Error Handling) Currently, I only want to learn these low-level socket APIs, so I don\u0026rsquo;t want to spend too much effort on memorizing what the return values of the APIs might indicate in terms of errors. I just want to focus on successfully implementing a very basic server and client.\nServer-side Code: server.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; #define PORT 8000 int main() { int sockFd, newSockFd, valread; int opt = 1; char buffer[1024] = {0}; char* helloFromServer = \u0026#34;hello from server\u0026#34;; struct sockaddr_in address; sockFd = socket(AF_INET, SOCK_STREAM, 0); setsockopt(sockFd, SOL_SOCKET, SO_REUSEADDR|SO_REUSEPORT, \u0026amp;opt, sizeof(opt)); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); int addrlen = sizeof(address); bind(sockFd, (struct sockaddr*)\u0026amp;address, addrlen); listen(sockFd, 3); newSockFd = accept(sockFd, (struct sockaddr*)\u0026amp;address, (socklen_t*)\u0026amp;addrlen); read(newSockFd, buffer, 1024); printf(\u0026#34;receive: %s\\n\u0026#34;, buffer); send(newSockFd, helloFromServer, strlen(helloFromServer), 0); printf(\u0026#34;server sent message\\n\u0026#34;); return 0; } Client-side Code: client.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define PORT 8000 using namespace std; int main() { int sockFd = 0; char buffer[1024] = {0}; char* helloFromClient = \u0026#34;hello from client\u0026#34;; struct sockaddr_in address; address.sin_family = AF_INET; inet_pton(AF_INET, \u0026#34;127.0.0.1\u0026#34;, \u0026amp;address.sin_addr.s_addr); address.sin_port = htons(PORT); sockFd = socket(AF_INET, SOCK_STREAM, 0); connect(sockFd, (struct sockaddr*)\u0026amp;address, sizeof(address)); send(sockFd, helloFromClient, strlen(helloFromClient), 0); printf(\u0026#34;client sent\\n\u0026#34;); read(sockFd, buffer, 1024); printf(\u0026#34;read message:%s\\n\u0026#34;, buffer); return 0; } Compilation, Execution, and Targeted Output In the Linux command line, input the following separately:\ng++ -o server server.cpp g++ -o client client.cpp Then open two terminals, and input the following respectively:\n./server ./client The expected outputs are:\nFor the server:\nreceive: hello from client server sent message client输出：\nclient sent message receive: hello from server ","permalink":"https://windypath.com/en/posts/linux_socket_programming/","summary":"This article primarily introduces the basics of Linux C++ Socket network programming. Most of the knowledge is sourced from the website: https://www.geeksforgeeks.org/socket-programming-cc/\nSocket Programming State Diagram From the diagram, we can see that the server side needs to go through four steps to enter the \u0026ldquo;waiting for connection\u0026rdquo; state, while the client side only requires two.\nBrief Analysis of Socket Programming Functions This analysis is for personal understanding and may have some omissions.","title":"Linux C++ Socket in Action"},{"content":"Born in the mid-1990s, male, from FJNU (Fujian Normal University), a native of Xiamen, Fujian, currently residing in Shanghai.\nAs a child, I always lost in computer games. Suddenly, I became interested in web pages. I would randomly modify saved web pages and open them to see the text change. It was incredibly exciting. In order to have unlimited time using computers, I decisively applied for a major in computer science.\nNever did I imagine that I would end up working as a game server developer. Two and a half years have passed in the project team of \u0026ldquo;Game of Thrones: Winter is Coming\u0026rdquo; Asia-Pacific version. I independently maintained the server for as long as half a year, becoming the \u0026ldquo;Guardian of the North Kingdom.\u0026rdquo;\nHere, I document the process of my step-by-step growth.\nContact Email: windypathblog@gmail.com Telegram: @windypath\n","permalink":"https://windypath.com/en/about/","summary":"Born in the mid-1990s, male, from FJNU (Fujian Normal University), a native of Xiamen, Fujian, currently residing in Shanghai.\nAs a child, I always lost in computer games. Suddenly, I became interested in web pages. I would randomly modify saved web pages and open them to see the text change. It was incredibly exciting. In order to have unlimited time using computers, I decisively applied for a major in computer science.","title":"About"},{"content":"Recently Computer Systems: A Programmer\u0026#39;s Perspective (3rd Edition) C\u0026#43;\u0026#43; Concurrency in Action, Second Edition I deliver packages in Beijing（我在北京送快递） Favorite Life Is Worth Living (Chinese Edition) The Power of Now: A Guide to Spiritual Enlightenment The Courage to Be Disliked Computer Systems: A Programmer\u0026#39;s Perspective (3rd Edition) ","permalink":"https://windypath.com/en/mybooks/","summary":"Recently Computer Systems: A Programmer\u0026#39;s Perspective (3rd Edition) C\u0026#43;\u0026#43; Concurrency in Action, Second Edition I deliver packages in Beijing（我在北京送快递） Favorite Life Is Worth Living (Chinese Edition) The Power of Now: A Guide to Spiritual Enlightenment The Courage to Be Disliked Computer Systems: A Programmer\u0026#39;s Perspective (3rd Edition) ","title":"My Books"},{"content":" ","permalink":"https://windypath.com/en/myfriends/","summary":" ","title":"My Friends"}]