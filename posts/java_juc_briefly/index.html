<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java并发编程中上锁的几种方式 | 风萧古道 - 勤学苦练，年复一年</title>
<meta name=keywords content><meta name=description content="前言：本文想要介绍Synchronized，ReentrantLock和ReentrantLock的Condition的相关用法。
Synchronized上锁 Synchronized可以修饰实例方法、静态方法和代码块。修饰代码块时，可以对具体的对象上锁，也可以对某个类(.class)上锁。
Synchronized是非公平锁 以下代码是通过给一个多线程能访问到的变量使用synchronized进行上锁，实现有序打印数字的功能。并且在最后会统计不同线程打印数字的次数：
package com.windypath.lockcondition; public class Syn { int count = 0; final Object sth = new Object(); void play() { int loopTimes = 1000; SynThread t1 = new SynThread(loopTimes, &#34;t1&#34;); SynThread t2 = new SynThread(loopTimes, &#34;t2&#34;); SynThread t3 = new SynThread(loopTimes, &#34;t3&#34;); SynThread t4 = new SynThread(loopTimes, &#34;t4&#34;); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Syn syn = new Syn(); syn.play(); } class SynThread extends Thread { int loopTimes; public SynThread(int loopTimes, String threadName) { super(threadName); this."><meta name=author content="JohnathanLin"><link rel=canonical href=https://windypath.com/posts/java_juc_briefly/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.eac269fd456bbc5decf5ec3fed956c33a791c95561d9ffc47422c34d673f662d.css integrity="sha256-6sJp/UVrvF3s9ew/7ZVsM6eRyVVh2f/EdCLDTWc/Zi0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://windypath.com/posts/java_juc_briefly/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Java并发编程中上锁的几种方式"><meta property="og:description" content="前言：本文想要介绍Synchronized，ReentrantLock和ReentrantLock的Condition的相关用法。
Synchronized上锁 Synchronized可以修饰实例方法、静态方法和代码块。修饰代码块时，可以对具体的对象上锁，也可以对某个类(.class)上锁。
Synchronized是非公平锁 以下代码是通过给一个多线程能访问到的变量使用synchronized进行上锁，实现有序打印数字的功能。并且在最后会统计不同线程打印数字的次数：
package com.windypath.lockcondition; public class Syn { int count = 0; final Object sth = new Object(); void play() { int loopTimes = 1000; SynThread t1 = new SynThread(loopTimes, &#34;t1&#34;); SynThread t2 = new SynThread(loopTimes, &#34;t2&#34;); SynThread t3 = new SynThread(loopTimes, &#34;t3&#34;); SynThread t4 = new SynThread(loopTimes, &#34;t4&#34;); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Syn syn = new Syn(); syn.play(); } class SynThread extends Thread { int loopTimes; public SynThread(int loopTimes, String threadName) { super(threadName); this."><meta property="og:type" content="article"><meta property="og:url" content="https://windypath.com/posts/java_juc_briefly/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-04T17:27:44+08:00"><meta property="article:modified_time" content="2023-12-04T17:27:44+08:00"><meta property="og:site_name" content="Windypath"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java并发编程中上锁的几种方式"><meta name=twitter:description content="前言：本文想要介绍Synchronized，ReentrantLock和ReentrantLock的Condition的相关用法。
Synchronized上锁 Synchronized可以修饰实例方法、静态方法和代码块。修饰代码块时，可以对具体的对象上锁，也可以对某个类(.class)上锁。
Synchronized是非公平锁 以下代码是通过给一个多线程能访问到的变量使用synchronized进行上锁，实现有序打印数字的功能。并且在最后会统计不同线程打印数字的次数：
package com.windypath.lockcondition; public class Syn { int count = 0; final Object sth = new Object(); void play() { int loopTimes = 1000; SynThread t1 = new SynThread(loopTimes, &#34;t1&#34;); SynThread t2 = new SynThread(loopTimes, &#34;t2&#34;); SynThread t3 = new SynThread(loopTimes, &#34;t3&#34;); SynThread t4 = new SynThread(loopTimes, &#34;t4&#34;); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Syn syn = new Syn(); syn.play(); } class SynThread extends Thread { int loopTimes; public SynThread(int loopTimes, String threadName) { super(threadName); this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windypath.com/posts/"},{"@type":"ListItem","position":2,"name":"Java并发编程中上锁的几种方式","item":"https://windypath.com/posts/java_juc_briefly/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java并发编程中上锁的几种方式","name":"Java并发编程中上锁的几种方式","description":"前言：本文想要介绍Synchronized，ReentrantLock和ReentrantLock的Condition的相关用法。\nSynchronized上锁 Synchronized可以修饰实例方法、静态方法和代码块。修饰代码块时，可以对具体的对象上锁，也可以对某个类(.class)上锁。\nSynchronized是非公平锁 以下代码是通过给一个多线程能访问到的变量使用synchronized进行上锁，实现有序打印数字的功能。并且在最后会统计不同线程打印数字的次数：\npackage com.windypath.lockcondition; public class Syn { int count = 0; final Object sth = new Object(); void play() { int loopTimes = 1000; SynThread t1 = new SynThread(loopTimes, \u0026#34;t1\u0026#34;); SynThread t2 = new SynThread(loopTimes, \u0026#34;t2\u0026#34;); SynThread t3 = new SynThread(loopTimes, \u0026#34;t3\u0026#34;); SynThread t4 = new SynThread(loopTimes, \u0026#34;t4\u0026#34;); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Syn syn = new Syn(); syn.play(); } class SynThread extends Thread { int loopTimes; public SynThread(int loopTimes, String threadName) { super(threadName); this.","keywords":[],"articleBody":" 前言：本文想要介绍Synchronized，ReentrantLock和ReentrantLock的Condition的相关用法。\nSynchronized上锁 Synchronized可以修饰实例方法、静态方法和代码块。修饰代码块时，可以对具体的对象上锁，也可以对某个类(.class)上锁。\nSynchronized是非公平锁 以下代码是通过给一个多线程能访问到的变量使用synchronized进行上锁，实现有序打印数字的功能。并且在最后会统计不同线程打印数字的次数：\npackage com.windypath.lockcondition; public class Syn { int count = 0; final Object sth = new Object(); void play() { int loopTimes = 1000; SynThread t1 = new SynThread(loopTimes, \"t1\"); SynThread t2 = new SynThread(loopTimes, \"t2\"); SynThread t3 = new SynThread(loopTimes, \"t3\"); SynThread t4 = new SynThread(loopTimes, \"t4\"); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Syn syn = new Syn(); syn.play(); } class SynThread extends Thread { int loopTimes; public SynThread(int loopTimes, String threadName) { super(threadName); this.loopTimes = loopTimes; } @Override public void run() { int times = 0; while (count \u003c= 200000) { synchronized (sth) { count++; // System.out.println(getName() + \" 输出 \" + count); times++; } } System.out.println(getName() + \"一共输出了 \" + times + \" 次\"); } } } 输出结果如下：\nt2一共输出了 103061 次 t1一共输出了 37174 次 t4一共输出了 33751 次 t3一共输出了 26018 次 可以看到线程t2输出的次数比其他三个线程加起来还要多。因为synchronized是非公平锁。\nsynchronized的等待队列 使用synchronized上锁的对象的等待队列位于ObjectMonitor中的_waitSet。这个ObjectMonitor是底层native(也就是C/C++)的内容。\nsynchronized锁升级 但并不是一开始就上重量级锁，而是先优化成偏向锁，如有竞争才会升级为轻量级锁，大量的线程参与锁的竞争时，才会从轻量级锁升级到重量级锁。\n上锁的对象使用其对象头中的MarkWord来存储锁的信息。\n一个Java对象在内存中的存储结构包括三个部分：\n对象头 实例变量 填充字节 其中对象头中主要存储一些运行时的数据：\nMarkWord Class Metadata Address (指向对象类型数据的指针) Array Length (是数组的话，记录长度) 锁的信息记录在对象头的MarkWord中。下图是不同的锁的MarkWord的不同位的信息： 偏向锁（biased lock） 偏向锁是为了避免在非多线程环境下，执行synchronized上锁时使用轻量级锁等更高等级的锁消耗资源。 偏向的意思是，被上锁的对象偏向于某个线程。其对象头会存储偏向的线程id。\n轻量级锁（lightweight lock） 轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况。 轻量级锁和偏向锁的区别 轻量级锁的加锁过程需要多次CAS操作，而偏向锁仅需要一次CAS操作。 轻量级锁所适应的场景是线程交替执行同步块的情况。而偏向锁则是在只有一个线程执行同步块时进一步提高性能。\nsynchronized锁升级观察 尝试使用一个对象，多个线程在不同的时间段为其上synchronized锁，来观察其锁状态。 thread1:马上获取，马上释放 thread2:等500ms获取，然后使用1500毫秒再释放 thread3:等待1000ms获取，然后马上释放。\n此时，thread2和thread3会出现锁竞争。\n源代码如下：\npackage com.windypath; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.openjdk.jol.info.ClassLayout; /** * 观察synchronized从偏向锁 -\u003e 轻量级锁 -\u003e 重量级锁 的过程 * 项目使用log4j2 */ public class BiasdLock { final static Logger log = LogManager.getLogger(); public static void main(String[] args) throws InterruptedException { log.debug(Thread.currentThread().getName() + \"最开始的状态:\\n\" + ClassLayout.parseInstance(new Object()).toPrintable()); // HotSpot 虚拟机在启动后有个 4s 的延迟才会对每个新建的对象开启偏向锁模式 Thread.sleep(4000); // 创建一个对象，用于多个不同的线程上锁用 Object obj = new Object(); log.debug(Thread.currentThread().getName() + \"等待4秒后的状态（新对象）:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); //线程1，马上上锁马上释放 new Thread(() -\u003e { log.debug( Thread.currentThread().getName() + \"开始执行准备获取锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); synchronized (obj) { log.debug(Thread.currentThread().getName() + \"获取锁执行中:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); } log.debug(Thread.currentThread().getName() + \"释放锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); }, \"thread1\").start(); // 线程2，等线程1释放锁后再上锁 new Thread(() -\u003e { try { Thread.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } log.debug( Thread.currentThread().getName() + \"开始执行准备获取锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); synchronized (obj) { log.debug(Thread.currentThread().getName() + \"获取锁执行中:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); try { Thread.sleep(1500); } catch (InterruptedException e) { throw new RuntimeException(e); } } log.debug(Thread.currentThread().getName() + \"释放锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); }, \"thread2\").start(); // 线程3，在线程2拥有锁的时候尝试上锁 new Thread(() -\u003e { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } log.debug( Thread.currentThread().getName() + \"开始执行准备获取锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); synchronized (obj) { log.debug(Thread.currentThread().getName() + \"获取锁执行中:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); } log.debug(Thread.currentThread().getName() + \"释放锁:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); }, \"thread3\").start(); //主线程等待所有线程运行结束，查看状态 Thread.sleep(5000); log.debug(Thread.currentThread().getName() + \"结束状态:\\n\" + ClassLayout.parseInstance(obj).toPrintable()); } } 输出如下(精简之后):\n15:53:58.436 [main] main最开始的状态:non-biasable 15:54:02.854 [main] 等待4秒后的状态（新对象）:biasable 15:54:02.858 [thread1] thread1开始执行准备获取锁:biasable 15:54:02.858 [thread1] thread1获取锁执行中:biased 15:54:02.859 [thread1] thread1释放锁:biased 15:54:03.367 [thread2] thread2开始执行准备获取锁:biased 15:54:03.368 [thread2] thread2获取锁执行中:thin lock 15:54:03.869 [thread3] thread3开始执行准备获取锁:thin lock 15:54:04.872 [thread3] thread3获取锁执行中:fat lock 15:54:04.872 [thread2] thread2释放锁:fat lock 15:54:04.873 [thread3] thread3释放锁:fat lock 15:54:07.868 [main] main结束状态:non-biasable 可以分析得到以下结论：\n对于hotspot虚拟机，刚启动时创建的对象是不可偏向(non-biasable)的 4秒后创建的对象，状态为可偏向(biasable) thread1获取锁时，由于仅有一个线程为此对象上synchronized锁，因此转为偏向锁状态(biased) thread1释放锁时，锁对象状态依旧为偏向锁(biased)，并不会回到可偏向(biasable) 500ms后，thread2获取锁时，锁对象的状态会升级为轻量级锁(thin lock) 再过500ms后，thread3也开始获取锁，未执行到synchronized代码块时，状态为轻量级锁(thin lock)，执行到synchronized时，阻塞，直到thread2释放的同时马上获取锁(倒数第三第四行的日志时间一模一样都是15:54:04.872) thread3马上释放锁，这一刻还是重量级锁(fat lock) 主线程等待5秒后，锁状态恢复，但是是变为不可偏向(non-biasable)状态。 可以尝试把前面的等待4秒注释，这样的话一上来就会获取轻量级锁 ReentrantLock上锁 ReentrantLock是轻量级、可重入锁。在创建时可指定是否是公平锁。 ReentrantLock可以和Condition配套使用。 ReentrantLock提供了多个并发编程相关的函数可供使用，相比于synchronized而言，灵活性更高。\nReentrantLock可支持锁是否是公平锁 ReentrantLock提供了常规的lock()上锁的函数之外，还提供了用于轮询使用的tryLock()函数和可被打断的lockInterruptly()函数 ReentrantLock上锁之后，可以根据业务等待不同的Condition ReentrantLock，可以是公平锁 package com.windypath.lockcondition; import java.util.concurrent.locks.ReentrantLock; public class Reen { int count = 0; final ReentrantLock lock = new ReentrantLock(true); void play() { int loopTimes = 1000; ReenThread t1 = new ReenThread(loopTimes, \"t1\"); ReenThread t2 = new ReenThread(loopTimes, \"t2\"); ReenThread t3 = new ReenThread(loopTimes, \"t3\"); ReenThread t4 = new ReenThread(loopTimes, \"t4\"); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Reen reen = new Reen(); reen.play(); } class ReenThread extends Thread { int loopTimes; public ReenThread(int loopTimes, String threadName) { super(threadName); this.loopTimes = loopTimes; } @Override public void run() { int times = 0; while (count \u003c= 200000) { try { lock.lock(); count++; // System.out.println(getName() + \" 输出 \" + count); times++; } finally { lock.unlock(); } } System.out.println(getName() + \"一共输出了 \" + times + \" 次\"); } } } 输出结果如下：\nt3一共输出了 49953 次 t4一共输出了 49988 次 t1一共输出了 50077 次 t2一共输出了 49986 次 可以看到4个线程的输出基本都在50000左右。\nReentrantLock不使用Condition模拟哲学家就餐 哲学家就餐问题，即5个哲学家围在一个圆桌吃饭，但桌上只有5只筷子。哲学家思考结束后，需要同时获取左手边的筷子和右手边的筷子才能吃饭。 在这里，我们使用线程来模拟哲学家，使用ReentrantLock模拟筷子。\npackage com.windypath; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class DiningPhilosopher { public static void main(String[] args) { int numPhilosophers = 5; Philosopher[] philosophers = new Philosopher[numPhilosophers]; Chopstick[] chopsticks = new Chopstick[numPhilosophers]; for (int i = 0; i \u003c numPhilosophers; i++) { chopsticks[i] = new Chopstick(); } for (int i = 0; i \u003c numPhilosophers; i++) { Chopstick leftChopstick = chopsticks[i]; Chopstick rightChopstick = chopsticks[(i + 1) % numPhilosophers]; // philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); if (i % 2 == 0) { philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); } else { philosophers[i] = new Philosopher(i, rightChopstick, leftChopstick); } Thread thread = new Thread(philosophers[i]); thread.start(); } } static class Philosopher implements Runnable { private final int id; private final Chopstick leftChopstick; private final Chopstick rightChopstick; private int eatTimes = 0; public Philosopher(int id, Chopstick leftChopstick, Chopstick rightChopstick) { this.id = id; this.leftChopstick = leftChopstick; this.rightChopstick = rightChopstick; } private void think() throws InterruptedException { System.out.println(\"Philosopher \" + id + \" is thinking.\"); Thread.sleep((long) ( 1000)); } private void eat() throws InterruptedException { leftChopstick.pickUp(); rightChopstick.pickUp(); System.out.println(\"Philosopher \" + id + \" picks up both chopsticks and eats.\"); Thread.sleep((long) ( 1000)); System.out.println(\"Philosopher \" + id + \" puts down both chopsticks.\"); rightChopstick.putDown(); leftChopstick.putDown(); eatTimes++; if (eatTimes % 10 == 0) { System.out.println(\"Philosopher \" + id + \" 目前吃了\" + eatTimes + \"次\"); } } @Override public void run() { try { while (true) { think(); eat(); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } static class Chopstick { private final Lock lock = new ReentrantLock(); public void pickUp() { lock.lock(); } public void putDown() { lock.unlock(); } } } 在上面的代码中，筷子只需要在被哲学家拿起时调用lock()函数，在放下时调用unlock()函数即可完成“同时拥有左手边的筷子和右手边的筷子”的目标。\n使用Condition的代码： package com.windypath; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class DiningPhilosophers { public static void main(String[] args) { int numPhilosophers = 5; Philosopher[] philosophers = new Philosopher[numPhilosophers]; Chopstick[] chopsticks = new Chopstick[numPhilosophers]; for (int i = 0; i \u003c numPhilosophers; i++) { chopsticks[i] = new Chopstick(); } for (int i = 0; i \u003c numPhilosophers; i++) { Chopstick leftChopstick = chopsticks[i]; Chopstick rightChopstick = chopsticks[(i + 1) % numPhilosophers]; // philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); if (i % 2 == 0) { philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick); } else { philosophers[i] = new Philosopher(i, rightChopstick, leftChopstick); } Thread thread = new Thread(philosophers[i]); thread.start(); } } static class Philosopher implements Runnable { private final int id; private final Chopstick leftChopstick; private final Chopstick rightChopstick; private int eatTimes = 0; public Philosopher(int id, Chopstick leftChopstick, Chopstick rightChopstick) { this.id = id; this.leftChopstick = leftChopstick; this.rightChopstick = rightChopstick; } private void think() throws InterruptedException { System.out.println(\"Philosopher \" + id + \" is thinking.\"); Thread.sleep((long) ( 1000)); } private void eat() throws InterruptedException { leftChopstick.pickUp(); rightChopstick.pickUp(); System.out.println(\"Philosopher \" + id + \" picks up both chopsticks and eats.\"); Thread.sleep((long) ( 1000)); System.out.println(\"Philosopher \" + id + \" puts down both chopsticks.\"); rightChopstick.putDown(); leftChopstick.putDown(); eatTimes++; if (eatTimes % 10 == 0) { System.out.println(\"Philosopher \" + id + \" 目前吃了\" + eatTimes + \"次\"); } } @Override public void run() { try { while (true) { think(); eat(); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } static class Chopstick { private final Lock lock = new ReentrantLock(true); private final Condition condition = lock.newCondition(); private boolean taken = false; public void pickUp() throws InterruptedException { lock.lock(); try { while (taken) { condition.await(); } taken = true; } finally { lock.unlock(); } } public void putDown() { lock.lock(); try { taken = false; condition.signal(); } finally { lock.unlock(); } } } } 可以看到，筷子类Chopstick加上了状态taken，用于判定目前筷子是否被某个哲学家拥有。 当第一个哲学家拥有某一只筷子的时候，taken为true；锁释放。当第二个哲学家拿起这只筷子时，还是会获得相同的锁，但会因为taken为true而进入condition.await()等待，此时也会释放锁，让其他哲学家能够获取这只筷子。 当筷子被放下时，调用signal()方法，此时之前await()函数的线程会被唤醒，执行其后序逻辑。\n如果不使用公平锁，那么输出里你可能会看到有两个哲学家很晚才吃10次。如果使用公平锁，则5个哲学家几乎是同步吃到10次。\n注意到在初始化哲学家时，奇数号哲学家的筷子是左右反过来拿的。这是因为在后续的获取筷子的逻辑中，我们总是先拿左手边的筷子，再拿右手边的筷子。如果不这样让一部分哲学家左右相反，那么会出现5个哲学家同时拿起左手边的筷子，然后等待右手边的筷子，造成死锁。（当然我们也可以通过随机数来让哲学家选择先左后右，还是先右后左。）\n","wordCount":"1162","inLanguage":"zh","datePublished":"2023-12-04T17:27:44+08:00","dateModified":"2023-12-04T17:27:44+08:00","author":{"@type":"Person","name":"JohnathanLin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://windypath.com/posts/java_juc_briefly/"},"publisher":{"@type":"Organization","name":"风萧古道 - 勤学苦练，年复一年","logo":{"@type":"ImageObject","url":"https://windypath.com/%3Clink%20/%20abs%20url%3E"}}}</script><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ")</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windypath.com/ accesskey=h title="风萧古道 (Alt + H)">风萧古道</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windypath.com/en/ title="Switch to English Page" aria-label="Switch to English Page">En</a></li></ul></div></div><ul id=menu><li><a href=https://windypath.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://windypath.com/categories/ title=分类><span>分类</span></a></li><li><a href=https://windypath.com/about/ title=关于><span>关于</span></a></li><li><a href=https://windypath.com/mybooks/ title=藏书><span>藏书</span></a></li><li><a href=https://windypath.com/myfriends/ title=朋友><span>朋友</span></a></li><li><a href=https://windypath.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Java并发编程中上锁的几种方式</h1><div class=post-meta>&lt;span title='2023-12-04 17:27:44 +0800 +0800'>十二月 4, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;JohnathanLin</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#synchronized%e4%b8%8a%e9%94%81 aria-label=Synchronized上锁>Synchronized上锁</a><ul><li><a href=#synchronized%e6%98%af%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81 aria-label=Synchronized是非公平锁>Synchronized是非公平锁</a></li><li><a href=#synchronized%e7%9a%84%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97 aria-label=synchronized的等待队列>synchronized的等待队列</a></li><li><a href=#synchronized%e9%94%81%e5%8d%87%e7%ba%a7 aria-label=synchronized锁升级>synchronized锁升级</a></li><li><a href=#%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81%e5%92%8c%e5%81%8f%e5%90%91%e9%94%81%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=轻量级锁和偏向锁的区别>轻量级锁和偏向锁的区别</a></li><li><a href=#synchronized%e9%94%81%e5%8d%87%e7%ba%a7%e8%a7%82%e5%af%9f aria-label=synchronized锁升级观察>synchronized锁升级观察</a></li></ul></li><li><a href=#reentrantlock%e4%b8%8a%e9%94%81 aria-label=ReentrantLock上锁>ReentrantLock上锁</a><ul><li><a href=#reentrantlock%e5%8f%af%e4%bb%a5%e6%98%af%e5%85%ac%e5%b9%b3%e9%94%81 aria-label=ReentrantLock，可以是公平锁>ReentrantLock，可以是公平锁</a></li><li><a href=#reentrantlock%e4%b8%8d%e4%bd%bf%e7%94%a8condition%e6%a8%a1%e6%8b%9f%e5%93%b2%e5%ad%a6%e5%ae%b6%e5%b0%b1%e9%a4%90 aria-label=ReentrantLock不使用Condition模拟哲学家就餐>ReentrantLock不使用Condition模拟哲学家就餐</a><ul><li><a href=#%e4%bd%bf%e7%94%a8condition%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=使用Condition的代码：>使用Condition的代码：</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>前言：本文想要介绍Synchronized，ReentrantLock和ReentrantLock的Condition的相关用法。</p></blockquote><h1 id=synchronized上锁>Synchronized上锁<a hidden class=anchor aria-hidden=true href=#synchronized上锁>#</a></h1><p>Synchronized可以修饰实例方法、静态方法和代码块。修饰代码块时，可以对具体的对象上锁，也可以对某个类(.class)上锁。</p><h2 id=synchronized是非公平锁>Synchronized是非公平锁<a hidden class=anchor aria-hidden=true href=#synchronized是非公平锁>#</a></h2><p>以下代码是通过给一个多线程能访问到的变量使用synchronized进行上锁，实现有序打印数字的功能。并且在最后会统计不同线程打印数字的次数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath.lockcondition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Syn</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Object sth <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>play</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> loopTimes <span style=color:#f92672>=</span> 1000;
</span></span><span style=display:flex><span>        SynThread t1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynThread(loopTimes, <span style=color:#e6db74>&#34;t1&#34;</span>);
</span></span><span style=display:flex><span>        SynThread t2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynThread(loopTimes, <span style=color:#e6db74>&#34;t2&#34;</span>);
</span></span><span style=display:flex><span>        SynThread t3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynThread(loopTimes, <span style=color:#e6db74>&#34;t3&#34;</span>);
</span></span><span style=display:flex><span>        SynThread t4 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynThread(loopTimes, <span style=color:#e6db74>&#34;t4&#34;</span>);
</span></span><span style=display:flex><span>        t1.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t2.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t3.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t4.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Syn syn <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Syn();
</span></span><span style=display:flex><span>        syn.<span style=color:#a6e22e>play</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SynThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> loopTimes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SynThread</span>(<span style=color:#66d9ef>int</span> loopTimes, String threadName) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>(threadName);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loopTimes</span> <span style=color:#f92672>=</span> loopTimes;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> times <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (count <span style=color:#f92672>&lt;=</span> 200000) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (sth) {
</span></span><span style=display:flex><span>                    count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//                    System.out.println(getName() + &#34; 输出 &#34; + count);</span>
</span></span><span style=display:flex><span>                    times<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getName() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;一共输出了 &#34;</span> <span style=color:#f92672>+</span> times <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 次&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出结果如下：</p><pre tabindex=0><code>t2一共输出了 103061 次
t1一共输出了 37174 次
t4一共输出了 33751 次
t3一共输出了 26018 次
</code></pre><p>可以看到线程t2输出的次数比其他三个线程加起来还要多。因为synchronized是非公平锁。</p><h2 id=synchronized的等待队列>synchronized的等待队列<a hidden class=anchor aria-hidden=true href=#synchronized的等待队列>#</a></h2><p>使用synchronized上锁的对象的等待队列位于ObjectMonitor中的_waitSet。这个ObjectMonitor是底层native(也就是C/C++)的内容。</p><h2 id=synchronized锁升级>synchronized锁升级<a hidden class=anchor aria-hidden=true href=#synchronized锁升级>#</a></h2><p>但并不是一开始就上重量级锁，而是先优化成偏向锁，如有竞争才会升级为轻量级锁，大量的线程参与锁的竞争时，才会从轻量级锁升级到重量级锁。</p><p>上锁的对象使用其对象头中的MarkWord来存储锁的信息。</p><p>一个Java对象在内存中的存储结构包括三个部分：</p><ul><li>对象头</li><li>实例变量</li><li>填充字节</li></ul><p>其中对象头中主要存储一些运行时的数据：</p><ul><li>MarkWord</li><li>Class Metadata Address (指向对象类型数据的指针)</li><li>Array Length (是数组的话，记录长度)</li></ul><p>锁的信息记录在对象头的MarkWord中。下图是不同的锁的MarkWord的不同位的信息：
<img loading=lazy src=/images/java_lock_bit_detail.jpg alt></p><ul><li>偏向锁（biased lock）
偏向锁是为了避免在非多线程环境下，执行synchronized上锁时使用轻量级锁等更高等级的锁消耗资源。</li></ul><p>偏向的意思是，被上锁的对象偏向于某个线程。其对象头会存储偏向的线程id。</p><ul><li>轻量级锁（lightweight lock）
轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况。</li></ul><h2 id=轻量级锁和偏向锁的区别>轻量级锁和偏向锁的区别<a hidden class=anchor aria-hidden=true href=#轻量级锁和偏向锁的区别>#</a></h2><p>轻量级锁的加锁过程需要多次CAS操作，而偏向锁仅需要一次CAS操作。
轻量级锁所适应的场景是线程交替执行同步块的情况。而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p><h2 id=synchronized锁升级观察>synchronized锁升级观察<a hidden class=anchor aria-hidden=true href=#synchronized锁升级观察>#</a></h2><p>尝试使用一个对象，多个线程在不同的时间段为其上synchronized锁，来观察其锁状态。
thread1:马上获取，马上释放
thread2:等500ms获取，然后使用1500毫秒再释放
thread3:等待1000ms获取，然后马上释放。</p><p>此时，thread2和thread3会出现锁竞争。</p><p>源代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.logging.log4j.LogManager;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.logging.log4j.Logger;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.openjdk.jol.info.ClassLayout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 观察synchronized从偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁 的过程
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 项目使用log4j2
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BiasdLock</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> Logger log <span style=color:#f92672>=</span> LogManager.<span style=color:#a6e22e>getLogger</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;最开始的状态:\n&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(<span style=color:#66d9ef>new</span> Object()).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// HotSpot 虚拟机在启动后有个 4s 的延迟才会对每个新建的对象开启偏向锁模式</span>
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(4000);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个对象，用于多个不同的线程上锁用</span>
</span></span><span style=display:flex><span>        Object obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;等待4秒后的状态（新对象）:\n&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>//线程1，马上上锁马上释放</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;开始执行准备获取锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;获取锁执行中:\n&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;释放锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;thread1&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程2，等线程1释放锁后再上锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>sleep</span>(500);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;开始执行准备获取锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;获取锁执行中:\n&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>sleep</span>(1500);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;释放锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;thread2&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程3，在线程2拥有锁的时候尝试上锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>sleep</span>(1000);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;开始执行准备获取锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;获取锁执行中:\n&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;释放锁:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;thread3&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>//主线程等待所有线程运行结束，查看状态</span>
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(5000);
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>debug</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;结束状态:\n&#34;</span> <span style=color:#f92672>+</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj).<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出如下(精简之后):</p><pre tabindex=0><code>15:53:58.436 [main] main最开始的状态:non-biasable
15:54:02.854 [main] 等待4秒后的状态（新对象）:biasable
15:54:02.858 [thread1] thread1开始执行准备获取锁:biasable
15:54:02.858 [thread1] thread1获取锁执行中:biased
15:54:02.859 [thread1] thread1释放锁:biased
15:54:03.367 [thread2] thread2开始执行准备获取锁:biased
15:54:03.368 [thread2] thread2获取锁执行中:thin lock
15:54:03.869 [thread3] thread3开始执行准备获取锁:thin lock
15:54:04.872 [thread3] thread3获取锁执行中:fat lock
15:54:04.872 [thread2] thread2释放锁:fat lock
15:54:04.873 [thread3] thread3释放锁:fat lock
15:54:07.868 [main] main结束状态:non-biasable
</code></pre><p>可以分析得到以下结论：</p><ul><li>对于hotspot虚拟机，刚启动时创建的对象是不可偏向(non-biasable)的</li><li>4秒后创建的对象，状态为可偏向(biasable)</li><li>thread1获取锁时，由于仅有一个线程为此对象上synchronized锁，因此转为偏向锁状态(biased)</li><li>thread1释放锁时，锁对象状态依旧为偏向锁(biased)，并不会回到可偏向(biasable)</li><li>500ms后，thread2获取锁时，锁对象的状态会升级为轻量级锁(thin lock)</li><li>再过500ms后，thread3也开始获取锁，未执行到synchronized代码块时，状态为轻量级锁(thin lock)，执行到synchronized时，阻塞，直到thread2释放的同时马上获取锁(倒数第三第四行的日志时间一模一样都是15:54:04.872)</li><li>thread3马上释放锁，这一刻还是重量级锁(fat lock)</li><li>主线程等待5秒后，锁状态恢复，但是是变为不可偏向(non-biasable)状态。</li><li>可以尝试把前面的等待4秒注释，这样的话一上来就会获取轻量级锁</li></ul><h1 id=reentrantlock上锁>ReentrantLock上锁<a hidden class=anchor aria-hidden=true href=#reentrantlock上锁>#</a></h1><p>ReentrantLock是轻量级、可重入锁。在创建时可指定是否是公平锁。
ReentrantLock可以和Condition配套使用。
ReentrantLock提供了多个并发编程相关的函数可供使用，相比于synchronized而言，灵活性更高。</p><ul><li>ReentrantLock可支持锁是否是公平锁</li><li>ReentrantLock提供了常规的lock()上锁的函数之外，还提供了用于轮询使用的tryLock()函数和可被打断的lockInterruptly()函数</li><li>ReentrantLock上锁之后，可以根据业务等待不同的Condition</li></ul><h2 id=reentrantlock可以是公平锁>ReentrantLock，可以是公平锁<a hidden class=anchor aria-hidden=true href=#reentrantlock可以是公平锁>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath.lockcondition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.ReentrantLock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Reen</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ReentrantLock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>play</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> loopTimes <span style=color:#f92672>=</span> 1000;
</span></span><span style=display:flex><span>        ReenThread t1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReenThread(loopTimes, <span style=color:#e6db74>&#34;t1&#34;</span>);
</span></span><span style=display:flex><span>        ReenThread t2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReenThread(loopTimes, <span style=color:#e6db74>&#34;t2&#34;</span>);
</span></span><span style=display:flex><span>        ReenThread t3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReenThread(loopTimes, <span style=color:#e6db74>&#34;t3&#34;</span>);
</span></span><span style=display:flex><span>        ReenThread t4 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReenThread(loopTimes, <span style=color:#e6db74>&#34;t4&#34;</span>);
</span></span><span style=display:flex><span>        t1.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t2.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t3.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t4.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Reen reen <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Reen();
</span></span><span style=display:flex><span>        reen.<span style=color:#a6e22e>play</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReenThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> loopTimes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ReenThread</span>(<span style=color:#66d9ef>int</span> loopTimes, String threadName) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>(threadName);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loopTimes</span> <span style=color:#f92672>=</span> loopTimes;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> times <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (count <span style=color:#f92672>&lt;=</span> 200000) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>                    count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//                    System.out.println(getName() + &#34; 输出 &#34; + count);</span>
</span></span><span style=display:flex><span>                    times<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getName() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;一共输出了 &#34;</span> <span style=color:#f92672>+</span> times <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 次&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出结果如下：</p><pre tabindex=0><code>t3一共输出了 49953 次
t4一共输出了 49988 次
t1一共输出了 50077 次
t2一共输出了 49986 次
</code></pre><p>可以看到4个线程的输出基本都在50000左右。</p><h2 id=reentrantlock不使用condition模拟哲学家就餐>ReentrantLock不使用Condition模拟哲学家就餐<a hidden class=anchor aria-hidden=true href=#reentrantlock不使用condition模拟哲学家就餐>#</a></h2><p>哲学家就餐问题，即5个哲学家围在一个圆桌吃饭，但桌上只有5只筷子。哲学家思考结束后，需要同时获取左手边的筷子和右手边的筷子才能吃饭。
在这里，我们使用线程来模拟哲学家，使用ReentrantLock模拟筷子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.Condition;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.Lock;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.ReentrantLock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DiningPhilosopher</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numPhilosophers <span style=color:#f92672>=</span> 5;
</span></span><span style=display:flex><span>        Philosopher<span style=color:#f92672>[]</span> philosophers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher<span style=color:#f92672>[</span>numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        Chopstick<span style=color:#f92672>[]</span> chopsticks <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Chopstick<span style=color:#f92672>[</span>numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> numPhilosophers; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            chopsticks<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Chopstick();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> numPhilosophers; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            Chopstick leftChopstick <span style=color:#f92672>=</span> chopsticks<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            Chopstick rightChopstick <span style=color:#f92672>=</span> chopsticks<span style=color:#f92672>[</span>(i <span style=color:#f92672>+</span> 1) <span style=color:#f92672>%</span> numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//            philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> 2 <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher(i, leftChopstick, rightChopstick);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher(i, rightChopstick, leftChopstick);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Philosopher</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Chopstick leftChopstick;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Chopstick rightChopstick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> eatTimes <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Philosopher</span>(<span style=color:#66d9ef>int</span> id, Chopstick leftChopstick, Chopstick rightChopstick) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> id;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>leftChopstick</span> <span style=color:#f92672>=</span> leftChopstick;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>rightChopstick</span> <span style=color:#f92672>=</span> rightChopstick;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>think</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; is thinking.&#34;</span>);
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>((<span style=color:#66d9ef>long</span>) ( 1000));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>eat</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            leftChopstick.<span style=color:#a6e22e>pickUp</span>();
</span></span><span style=display:flex><span>            rightChopstick.<span style=color:#a6e22e>pickUp</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; picks up both chopsticks and eats.&#34;</span>);
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>((<span style=color:#66d9ef>long</span>) ( 1000));
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; puts down both chopsticks.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            rightChopstick.<span style=color:#a6e22e>putDown</span>();
</span></span><span style=display:flex><span>            leftChopstick.<span style=color:#a6e22e>putDown</span>();
</span></span><span style=display:flex><span>            eatTimes<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (eatTimes <span style=color:#f92672>%</span> 10 <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 目前吃了&#34;</span> <span style=color:#f92672>+</span> eatTimes <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;次&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                    think();
</span></span><span style=display:flex><span>                    eat();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Chopstick</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pickUp</span>() {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>putDown</span>() {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面的代码中，筷子只需要在被哲学家拿起时调用lock()函数，在放下时调用unlock()函数即可完成“同时拥有左手边的筷子和右手边的筷子”的目标。</p><h3 id=使用condition的代码>使用Condition的代码：<a hidden class=anchor aria-hidden=true href=#使用condition的代码>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.windypath;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.Condition;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.Lock;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.ReentrantLock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DiningPhilosophers</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numPhilosophers <span style=color:#f92672>=</span> 5;
</span></span><span style=display:flex><span>        Philosopher<span style=color:#f92672>[]</span> philosophers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher<span style=color:#f92672>[</span>numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        Chopstick<span style=color:#f92672>[]</span> chopsticks <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Chopstick<span style=color:#f92672>[</span>numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> numPhilosophers; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            chopsticks<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Chopstick();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> numPhilosophers; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            Chopstick leftChopstick <span style=color:#f92672>=</span> chopsticks<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            Chopstick rightChopstick <span style=color:#f92672>=</span> chopsticks<span style=color:#f92672>[</span>(i <span style=color:#f92672>+</span> 1) <span style=color:#f92672>%</span> numPhilosophers<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//            philosophers[i] = new Philosopher(i, leftChopstick, rightChopstick);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> 2 <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher(i, leftChopstick, rightChopstick);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Philosopher(i, rightChopstick, leftChopstick);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(philosophers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Philosopher</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Chopstick leftChopstick;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Chopstick rightChopstick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> eatTimes <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Philosopher</span>(<span style=color:#66d9ef>int</span> id, Chopstick leftChopstick, Chopstick rightChopstick) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> id;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>leftChopstick</span> <span style=color:#f92672>=</span> leftChopstick;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>rightChopstick</span> <span style=color:#f92672>=</span> rightChopstick;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>think</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; is thinking.&#34;</span>);
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>((<span style=color:#66d9ef>long</span>) ( 1000));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>eat</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            leftChopstick.<span style=color:#a6e22e>pickUp</span>();
</span></span><span style=display:flex><span>            rightChopstick.<span style=color:#a6e22e>pickUp</span>();
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; picks up both chopsticks and eats.&#34;</span>);
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>((<span style=color:#66d9ef>long</span>) ( 1000));
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; puts down both chopsticks.&#34;</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            rightChopstick.<span style=color:#a6e22e>putDown</span>();
</span></span><span style=display:flex><span>            leftChopstick.<span style=color:#a6e22e>putDown</span>();
</span></span><span style=display:flex><span>            eatTimes<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (eatTimes <span style=color:#f92672>%</span> 10 <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Philosopher &#34;</span> <span style=color:#f92672>+</span> id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 目前吃了&#34;</span> <span style=color:#f92672>+</span> eatTimes <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;次&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                    think();
</span></span><span style=display:flex><span>                    eat();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Chopstick</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Condition condition <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>newCondition</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> taken <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pickUp</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (taken) {
</span></span><span style=display:flex><span>                    condition.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                taken <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>putDown</span>() {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                taken <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                condition.<span style=color:#a6e22e>signal</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，筷子类Chopstick加上了状态taken，用于判定目前筷子是否被某个哲学家拥有。
当第一个哲学家拥有某一只筷子的时候，taken为true；锁释放。当第二个哲学家拿起这只筷子时，还是会获得相同的锁，但会因为taken为true而进入condition.await()等待，此时也会释放锁，让其他哲学家能够获取这只筷子。
当筷子被放下时，调用signal()方法，此时之前await()函数的线程会被唤醒，执行其后序逻辑。</p><blockquote><p>如果不使用公平锁，那么输出里你可能会看到有两个哲学家很晚才吃10次。如果使用公平锁，则5个哲学家几乎是同步吃到10次。</p></blockquote><blockquote><p>注意到在初始化哲学家时，奇数号哲学家的筷子是左右反过来拿的。这是因为在后续的获取筷子的逻辑中，我们总是先拿左手边的筷子，再拿右手边的筷子。如果不这样让一部分哲学家左右相反，那么会出现5个哲学家同时拿起左手边的筷子，然后等待右手边的筷子，造成死锁。（当然我们也可以通过随机数来让哲学家选择先左后右，还是先右后左。）</p></blockquote></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://windypath.com/posts/how_to_split_a_string_in_cpp/><span class=title>下一页 »</span><br><span>如何用C++分割一个字符串？</span></a></nav></footer></article></main><footer class=footer><span>Windypath 风萧古道 <strong>For Chinese Software</strong>. <a href=https://beian.miit.gov.cn/>闽ICP备15016446号-3</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>