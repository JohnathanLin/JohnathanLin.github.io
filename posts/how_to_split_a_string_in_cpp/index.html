<!doctype html><html lang=zh dir=auto><head><style>:root{--sys-font-family:"Noto Serif SC";--zh-font-family:"Noto Serif SC";--base-font-family:"Noto Serif SC";--code-font-family:"Noto Serif SC";--article-font-family:"Noto Serif SC"}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何用C++分割一个字符串？ | 风萧古道 - 勤学苦练，年复一年</title>
<meta name=keywords content><meta name=description content="前言 在上机面试的时候，遇到了一道题，它的输入是两行字符串，每行字符串有未知数量的数字（两行数字数量一致），用空格分隔开，输入形如：
12 34 567 888 99 100 358 74 58454 742 4469 88 并不提前提供每行的数字数量。而是让用户自己切分。
当时在上机考试时，我没有使用C++实现这一功能，而是使用Java里的split()进行处理。
后来，考试结束后，我上网查询C++切分字符串的写法，发现C++并没有原生提供类似split(某个字符)的写法。
那么有什么方法能替代呢？
方法1：使用string的find等函数()配合substr()进行切分 根据知乎大佬的回答，他提供的第一种解决方案是：
C++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/36642771/answer/865135551
#include <iostream> #include <cstring> #include <vector> void split(const std::string& s, std::vector<std::string>& tokens, const std::string& delimiters = &#34; &#34;) { std::string::size_type lastPos = s.find_first_not_of(delimiters, 0); std::string::size_type pos = s.find_first_of(delimiters, lastPos); while (std::string::npos != pos || std::string::npos != lastPos) { tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s."><meta name=author content="JohnathanLin"><link rel=canonical href=https://windypath.com/posts/how_to_split_a_string_in_cpp/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2215af6a28c52331bad04ae84f42d6ac21a53b6982f4d9347e9394a6b1089004.css integrity="sha256-IhWvaijFIzG60EroT0LWrCGlO2mC9Nk0fpOUprEIkAQ=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://windypath.com/posts/how_to_split_a_string_in_cpp/><link rel=alternate hreflang=en href=https://windypath.com/en/posts/how_to_split_a_string_in_cpp/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ",{anonymize_ip:!1})}</script><meta property="og:title" content="如何用C++分割一个字符串？"><meta property="og:description" content="前言 在上机面试的时候，遇到了一道题，它的输入是两行字符串，每行字符串有未知数量的数字（两行数字数量一致），用空格分隔开，输入形如：
12 34 567 888 99 100 358 74 58454 742 4469 88 并不提前提供每行的数字数量。而是让用户自己切分。
当时在上机考试时，我没有使用C++实现这一功能，而是使用Java里的split()进行处理。
后来，考试结束后，我上网查询C++切分字符串的写法，发现C++并没有原生提供类似split(某个字符)的写法。
那么有什么方法能替代呢？
方法1：使用string的find等函数()配合substr()进行切分 根据知乎大佬的回答，他提供的第一种解决方案是：
C++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/36642771/answer/865135551
#include <iostream> #include <cstring> #include <vector> void split(const std::string& s, std::vector<std::string>& tokens, const std::string& delimiters = &#34; &#34;) { std::string::size_type lastPos = s.find_first_not_of(delimiters, 0); std::string::size_type pos = s.find_first_of(delimiters, lastPos); while (std::string::npos != pos || std::string::npos != lastPos) { tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s."><meta property="og:type" content="article"><meta property="og:url" content="https://windypath.com/posts/how_to_split_a_string_in_cpp/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-02T11:54:44+08:00"><meta property="article:modified_time" content="2023-07-02T11:54:44+08:00"><meta property="og:site_name" content="Windypath"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何用C++分割一个字符串？"><meta name=twitter:description content="前言 在上机面试的时候，遇到了一道题，它的输入是两行字符串，每行字符串有未知数量的数字（两行数字数量一致），用空格分隔开，输入形如：
12 34 567 888 99 100 358 74 58454 742 4469 88 并不提前提供每行的数字数量。而是让用户自己切分。
当时在上机考试时，我没有使用C++实现这一功能，而是使用Java里的split()进行处理。
后来，考试结束后，我上网查询C++切分字符串的写法，发现C++并没有原生提供类似split(某个字符)的写法。
那么有什么方法能替代呢？
方法1：使用string的find等函数()配合substr()进行切分 根据知乎大佬的回答，他提供的第一种解决方案是：
C++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/36642771/answer/865135551
#include <iostream> #include <cstring> #include <vector> void split(const std::string& s, std::vector<std::string>& tokens, const std::string& delimiters = &#34; &#34;) { std::string::size_type lastPos = s.find_first_not_of(delimiters, 0); std::string::size_type pos = s.find_first_of(delimiters, lastPos); while (std::string::npos != pos || std::string::npos != lastPos) { tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windypath.com/posts/"},{"@type":"ListItem","position":2,"name":"如何用C++分割一个字符串？","item":"https://windypath.com/posts/how_to_split_a_string_in_cpp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何用C++分割一个字符串？","name":"如何用C\u002b\u002b分割一个字符串？","description":"前言 在上机面试的时候，遇到了一道题，它的输入是两行字符串，每行字符串有未知数量的数字（两行数字数量一致），用空格分隔开，输入形如：\n12 34 567 888 99 100 358 74 58454 742 4469 88 并不提前提供每行的数字数量。而是让用户自己切分。\n当时在上机考试时，我没有使用C++实现这一功能，而是使用Java里的split()进行处理。\n后来，考试结束后，我上网查询C++切分字符串的写法，发现C++并没有原生提供类似split(某个字符)的写法。\n那么有什么方法能替代呢？\n方法1：使用string的find等函数()配合substr()进行切分 根据知乎大佬的回答，他提供的第一种解决方案是：\nC++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/36642771/answer/865135551\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; void split(const std::string\u0026amp; s, std::vector\u0026lt;std::string\u0026gt;\u0026amp; tokens, const std::string\u0026amp; delimiters = \u0026#34; \u0026#34;) { std::string::size_type lastPos = s.find_first_not_of(delimiters, 0); std::string::size_type pos = s.find_first_of(delimiters, lastPos); while (std::string::npos != pos || std::string::npos != lastPos) { tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s.","keywords":[],"articleBody":"前言 在上机面试的时候，遇到了一道题，它的输入是两行字符串，每行字符串有未知数量的数字（两行数字数量一致），用空格分隔开，输入形如：\n12 34 567 888 99 100 358 74 58454 742 4469 88 并不提前提供每行的数字数量。而是让用户自己切分。\n当时在上机考试时，我没有使用C++实现这一功能，而是使用Java里的split()进行处理。\n后来，考试结束后，我上网查询C++切分字符串的写法，发现C++并没有原生提供类似split(某个字符)的写法。\n那么有什么方法能替代呢？\n方法1：使用string的find等函数()配合substr()进行切分 根据知乎大佬的回答，他提供的第一种解决方案是：\nC++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/36642771/answer/865135551\n#include #include #include void split(const std::string\u0026 s, std::vector\u003cstd::string\u003e\u0026 tokens, const std::string\u0026 delimiters = \" \") { std::string::size_type lastPos = s.find_first_not_of(delimiters, 0); std::string::size_type pos = s.find_first_of(delimiters, lastPos); while (std::string::npos != pos || std::string::npos != lastPos) { tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s.find_first_not_of(delimiters, pos); pos = s.find_first_of(delimiters, lastPos); } } int main() { std::string str = \"12 34 567 888 99 100\"; std::vector\u003cstd::string\u003e res; split(str, res, \" \"); for (auto r: res) { printf(\"%s\\n\", r.c_str()); } return 0; } 输出结果：\n12 34 567 888 99 100 这个split()函数，通过记录两个下标来确定需要裁出的字符串。\n第一个下标lastPos，寻找从字符串开始后，第一个不是分隔符的字符下标； 第二个下标pos，寻找从lastPos之后，第一个是分隔符的字符下标。 如此一来，从lastPos到pos之间的字符串，就是我们需要裁出的字符串。 裁出第一个字符串后，将两个下标按之前的逻辑往后移动，直到两个下标都找不到合适的值（返回string::npos）时，结束。\n函数介绍： find_first_of() string的find_first_of()接收两个参数，第一个参数是要寻找的字符，它可能是string，char*或者char，第二个参数是开始寻找的下标（可以不传，默认传0）。 从第二个参数所指的字符串数组下标开始，往后寻找，直到找到要寻找的字符时，返回找到字符的下标。\nfind_first_not_of() string的find_first_not_of()接收的参数与find_first_of()一致，但它是寻找直到不是寻找字符时，返回不是寻找字符的下标。\nsubstr() 用于切分字符串，接收两个参数pos和len，从pos位置开始，切出往后len个长度的字符。不会修改原字符串。\n具体的C++文档位置：\nfind_first_of()：https://cplusplus.com/reference/string/string/find_first_of/ find_first_not_of()：https://cplusplus.com/reference/string/string/find_first_not_of/ substr()：https://cplusplus.com/reference/string/string/substr/\n方法2：C++11 正则表达式 #include #include #include int main() { std::string str = \"12 34 567 888 99 100\"; std::regex ws_re(\"\\\\s+\"); std::vector\u003cstd::string\u003e res( std::sregex_token_iterator( str.begin(), str.end(), ws_re, -1 ), std::sregex_token_iterator() ); for (auto r: res) { printf(\"%s\\n\", r.c_str()); } return 0; } 这个例子是来自regex_token_iterator的介绍中。\nhttps://en.cppreference.com/w/cpp/regex/regex_token_iterator\n使用sregex_token_iterator()迭代器来进行切分操作（前面的s指代使用字符串类型string）。在这个例子中，9-11行中，构造了一个sregex_token_iterator迭代器，传入了4个参数，分别是：字符串的开始位置的迭代器，字符串结束的迭代器，正则表达式对象，是否使用匹配的部分（0使用，-1不使用）。\n构造sregex_token_iterator()时，确定了要从字符串开始位置，查找到字符串末尾，通过正则表达式匹配，然后查找不匹配的部分。\n该迭代器的末尾，是一个默认构造的sregex_token_iterator()对象。\nvector的构造函数中，可以通过传入两个迭代器，获取迭代器之间的元素。\n方法3：使用stringstream分割字符串（仅支持空格、回车、tab换行） 信息来源：https://www.cnblogs.com/narjaja/p/10044157.html\n#include #include #include int main() { std::string str = \"12 34 567 888 99 100\"; std::vector\u003cstd::string\u003e res; std::istringstream ss(str); std::string word; while(ss\u003e\u003eword) { res.push_back(word); } for (auto r: res) { printf(\"%s\\n\", r.c_str()); } return 0; } 通过C++的 » ，像用户cin一样，将字符串“输入”，从而得到切分的效果。\n如果要支持自定义分隔符，则可以使用getline()进行处理\n#include #include #include using namespace std; int main() { std::string data = \"1_2_3_4_5_6\"; std::stringstream ss(data); std::string item; cout \u003c\u003c data \u003c\u003c endl; while (std::getline(ss, item, '_')) cout \u003c\u003c item \u003c\u003c ' '; } 方法4：通过C语言的strtok()函数实现 第一种错误写法 还有一种做法是通过C语言的strtok()函数进行处理。 在网上能找到类似这样结构的代码：\n#include #include int main() { char str[] = \"A B C D\"; char* p = strtok(str, \" \"); std::cout \u003c\u003c p \u003c\u003c std::endl; while (p != NULL) { p = strtok(NULL, \" \"); std::cout \u003c\u003c p \u003c\u003c std::endl; } return 0; } 也能正常得到结果：\nA B C D 但是，当我打算在第11行进行cout输出时，发现结果并不会正常输出：\n#include #include int main() { char str[] = \"A B C D\"; char* p = strtok(str, \" \"); std::cout \u003c\u003c p \u003c\u003c std::endl; while (p != NULL) { p = strtok(NULL, \" \"); std::cout \u003c\u003c p \u003c\u003c std::endl; } std::cout \u003c\u003c \"abc\" \u003c\u003c std::endl; return 0; } 此时输出的结果还是：\nA B C D 并没有最后的abc。\n问了ChatGPT后，得到的解释是：\n这段C++代码中的问题是在循环输出切割后的子字符串时，先打印p的值再进行下一次循环。这会导致在最后一次循环结束后，p被设置为NULL，然后再尝试打印p的值，导致未定义行为。\n在第8行，你打印了p的值，然后在第9行将其设置为下一个切割后的子字符串。接下来，在第10行的循环开始时，你再次打印p的值，但此时它可能已经为NULL，导致未定义行为。\n为了修复这个问题，你可以将打印语句移到循环的末尾，这样先进行下一次循环再打印p的值，确保p不为NULL。\n以下是修正后的代码：\n#include #include int main() { char str[] = \"A B C D\"; char* p = strtok(str, \" \"); while (p != NULL) { std::cout \u003c\u003c p \u003c\u003c std::endl; p = strtok(NULL, \" \"); } std::cout \u003c\u003c \"abc\" \u003c\u003c std::endl; return 0; } 这样修改后，代码将正常输出切割后的子字符串，然后输出\"abc\"。请注意，std::endl用于在输出后添加换行符，以保证输出结果的正确格式。\n第二种错误写法 #include #include int main() { char s[] = \"A B C D\"; char *p; const char *d = \" \"; p = strtok(s, d); while(p) { printf(\"%s\\n\", p); p = strtok(NULL, \" \"); } printf(\"abc\"); return 0; } 这一次我们在循环体中，先输出上一次切分的p，再读取下一次的p。但字符串“abc”还是没有正常输出。ChatGPT解答如下：\nChatGPT\n这段代码中无法正常输出\"abc\"的原因是因为在使用strtok函数对字符串进行分割时，它会将原字符串中的分隔符替换为’\\0’（空字符）来分割子字符串。这导致原字符串s被修改，后续的printf语句在遇到’\\0’时会提前结束。\n在代码中，原字符串s的内容为\"A B C D\"，而strtok(s, d)会将它分割成\"A\"、“B”、“C\"和\"D\"四个子字符串。因此，循环中的printf语句会输出这四个子字符串，分别为\"A”、“B”、“C\"和\"D”。\n然后，在最后一次调用strtok(NULL, \" “)时，由于已经没有分隔符了，strtok会返回NULL，结束循环。然后，代码中的printf(“abc”)会尝试输出\"abc”，但是由于之前的strtok调用修改了原字符串s，将其中的空格替换为了’\\0’，所以在输出\"abc\"之前，printf函数遇到了’\\0’字符，将其视为字符串的结尾，导致输出提前结束。\n如果你希望能够输出\"abc\"，你可以在printf语句中添加换行符\\n，如下所示：\n#include #include int main() { char s[] = \"A B C D\"; char *p; const char *d = \" \"; p = strtok(s, d); while (p) { printf(\"%s\\n\", p); p = strtok(NULL, \" \"); } printf(\"abc\\n\"); // 在\"abc\"后添加换行符\\n return 0; } 通过上述修改，代码将能够正常输出\"A\"、“B”、“C”、“D\"和\"abc”。\nstrtok()函数 strtok()函数切割后，会在切断的位置上填充\\0，会修改原字符串。所以一定要多加注意，慎用这个函数。\n","wordCount":"523","inLanguage":"zh","datePublished":"2023-07-02T11:54:44+08:00","dateModified":"2023-07-02T11:54:44+08:00","author":{"@type":"Person","name":"JohnathanLin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://windypath.com/posts/how_to_split_a_string_in_cpp/"},"publisher":{"@type":"Organization","name":"风萧古道 - 勤学苦练，年复一年","logo":{"@type":"ImageObject","url":"https://windypath.com/%3Clink%20/%20abs%20url%3E"}}}</script><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ")</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windypath.com/ accesskey=h title="风萧古道 (Alt + H)">风萧古道</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windypath.com/en/ title="Switch to English Page" aria-label="Switch to English Page">En</a></li></ul></div></div><ul id=menu><li><a href=https://windypath.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://windypath.com/categories/ title=分类><span>分类</span></a></li><li><a href=https://windypath.com/about/ title=关于><span>关于</span></a></li><li><a href=https://windypath.com/mybooks/ title=藏书><span>藏书</span></a></li><li><a href=https://windypath.com/myfriends/ title=朋友><span>朋友</span></a></li><li><a href=https://windypath.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>如何用C++分割一个字符串？</h1><div class=post-meta>&lt;span title='2023-07-02 11:54:44 +0800 +0800'>七月 2, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;JohnathanLin&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://windypath.com/en/posts/how_to_split_a_string_in_cpp/>En</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e6%96%b9%e6%b3%951%e4%bd%bf%e7%94%a8string%e7%9a%84find%e7%ad%89%e5%87%bd%e6%95%b0%e9%85%8d%e5%90%88substr%e8%bf%9b%e8%a1%8c%e5%88%87%e5%88%86 aria-label=方法1：使用string的find等函数()配合substr()进行切分>方法1：使用string的find等函数()配合substr()进行切分</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e4%bb%8b%e7%bb%8d aria-label=函数介绍：>函数介绍：</a><ul><li><a href=#find_first_of aria-label=find_first_of()>find_first_of()</a></li><li><a href=#find_first_not_of aria-label=find_first_not_of()>find_first_not_of()</a></li><li><a href=#substr aria-label=substr()>substr()</a></li></ul></li></ul></li><li><a href=#%e6%96%b9%e6%b3%952c11-%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f aria-label="方法2：C++11 正则表达式">方法2：C++11 正则表达式</a></li><li><a href=#%e6%96%b9%e6%b3%953%e4%bd%bf%e7%94%a8stringstream%e5%88%86%e5%89%b2%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%bb%85%e6%94%af%e6%8c%81%e7%a9%ba%e6%a0%bc%e5%9b%9e%e8%bd%a6tab%e6%8d%a2%e8%a1%8c aria-label=方法3：使用stringstream分割字符串（仅支持空格、回车、tab换行）>方法3：使用stringstream分割字符串（仅支持空格、回车、tab换行）</a></li><li><a href=#%e6%96%b9%e6%b3%954%e9%80%9a%e8%bf%87c%e8%af%ad%e8%a8%80%e7%9a%84strtok%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0 aria-label=方法4：通过C语言的strtok()函数实现>方法4：通过C语言的strtok()函数实现</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e7%a7%8d%e9%94%99%e8%af%af%e5%86%99%e6%b3%95 aria-label=第一种错误写法>第一种错误写法</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e7%a7%8d%e9%94%99%e8%af%af%e5%86%99%e6%b3%95 aria-label=第二种错误写法>第二种错误写法</a></li></ul></li><li><a href=#strtok%e5%87%bd%e6%95%b0 aria-label=strtok()函数>strtok()函数</a></li></ul></div></details></div><div class=post-content><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>在上机面试的时候，遇到了一道题，它的输入是两行字符串，每行字符串有未知数量的数字（两行数字数量一致），用空格分隔开，输入形如：</p><pre tabindex=0><code>12 34 567 888 99 100
358 74 58454 742 4469 88
</code></pre><p>并不提前提供每行的数字数量。而是让用户自己切分。</p><p>当时在上机考试时，我没有使用C++实现这一功能，而是使用Java里的split()进行处理。</p><p>后来，考试结束后，我上网查询C++切分字符串的写法，发现C++并没有原生提供类似split(某个字符)的写法。</p><p>那么有什么方法能替代呢？</p><h1 id=方法1使用string的find等函数配合substr进行切分>方法1：使用string的find等函数()配合substr()进行切分<a hidden class=anchor aria-hidden=true href=#方法1使用string的find等函数配合substr进行切分>#</a></h1><p>根据知乎大佬的回答，他提供的第一种解决方案是：</p><p>C++ 的 string 为什么不提供 split 函数？ - 知乎用户的回答 - 知乎
<a href=https://www.zhihu.com/question/36642771/answer/865135551>https://www.zhihu.com/question/36642771/answer/865135551</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>split</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> s, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&amp;</span> tokens, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> delimiters <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; &#34;</span>) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>size_type lastPos <span style=color:#f92672>=</span> s.find_first_not_of(delimiters, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>size_type pos <span style=color:#f92672>=</span> s.find_first_of(delimiters, lastPos);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>npos <span style=color:#f92672>!=</span> pos <span style=color:#f92672>||</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>npos <span style=color:#f92672>!=</span> lastPos) {
</span></span><span style=display:flex><span>        tokens.push_back(s.substr(lastPos, pos <span style=color:#f92672>-</span> lastPos));
</span></span><span style=display:flex><span>        lastPos <span style=color:#f92672>=</span> s.find_first_not_of(delimiters, pos);
</span></span><span style=display:flex><span>        pos <span style=color:#f92672>=</span> s.find_first_of(delimiters, lastPos);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;12 34 567 888 99 100&#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>    split(str, res, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> r: res) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, r.c_str());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>12
34
567
888
99
100
</code></pre><p>这个split()函数，通过记录两个下标来确定需要裁出的字符串。</p><ul><li>第一个下标lastPos，寻找从字符串开始后，第一个不是分隔符的字符下标；</li><li>第二个下标pos，寻找从lastPos之后，第一个是分隔符的字符下标。
如此一来，从lastPos到pos之间的字符串，就是我们需要裁出的字符串。</li></ul><p>裁出第一个字符串后，将两个下标按之前的逻辑往后移动，直到两个下标都找不到合适的值（返回string::npos）时，结束。</p><h2 id=函数介绍>函数介绍：<a hidden class=anchor aria-hidden=true href=#函数介绍>#</a></h2><h3 id=find_first_of>find_first_of()<a hidden class=anchor aria-hidden=true href=#find_first_of>#</a></h3><p>string的find_first_of()接收两个参数，第一个参数是要寻找的字符，它可能是string，char*或者char，第二个参数是开始寻找的下标（可以不传，默认传0）。
从第二个参数所指的字符串数组下标开始，往后寻找，直到找到要寻找的字符时，返回找到字符的下标。</p><h3 id=find_first_not_of>find_first_not_of()<a hidden class=anchor aria-hidden=true href=#find_first_not_of>#</a></h3><p>string的find_first_not_of()接收的参数与find_first_of()一致，但它是寻找直到不是寻找字符时，返回不是寻找字符的下标。</p><h3 id=substr>substr()<a hidden class=anchor aria-hidden=true href=#substr>#</a></h3><p>用于切分字符串，接收两个参数pos和len，从pos位置开始，切出往后len个长度的字符。不会修改原字符串。</p><p>具体的C++文档位置：</p><p>find_first_of()：<a href=https://cplusplus.com/reference/string/string/find_first_of/>https://cplusplus.com/reference/string/string/find_first_of/</a>
find_first_not_of()：<a href=https://cplusplus.com/reference/string/string/find_first_not_of/>https://cplusplus.com/reference/string/string/find_first_not_of/</a>
substr()：<a href=https://cplusplus.com/reference/string/string/substr/>https://cplusplus.com/reference/string/string/substr/</a></p><h1 id=方法2c11-正则表达式>方法2：C++11 正则表达式<a hidden class=anchor aria-hidden=true href=#方法2c11-正则表达式>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;regex&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;12 34 567 888 99 100&#34;</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>regex ws_re(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>s+&#34;</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> res(
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>sregex_token_iterator(
</span></span><span style=display:flex><span>            str.begin(), str.end(), ws_re, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>sregex_token_iterator()
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> r: res) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, r.c_str());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个例子是来自regex_token_iterator的介绍中。</p><p><a href=https://en.cppreference.com/w/cpp/regex/regex_token_iterator>https://en.cppreference.com/w/cpp/regex/regex_token_iterator</a></p><p>使用sregex_token_iterator()迭代器来进行切分操作（前面的s指代使用字符串类型string）。在这个例子中，9-11行中，构造了一个sregex_token_iterator迭代器，传入了4个参数，分别是：字符串的开始位置的迭代器，字符串结束的迭代器，正则表达式对象，是否使用匹配的部分（0使用，-1不使用）。</p><p>构造sregex_token_iterator()时，确定了要从字符串开始位置，查找到字符串末尾，通过正则表达式匹配，然后查找不匹配的部分。</p><p>该迭代器的末尾，是一个默认构造的sregex_token_iterator()对象。</p><p>vector的构造函数中，可以通过传入两个迭代器，获取迭代器之间的元素。</p><h1 id=方法3使用stringstream分割字符串仅支持空格回车tab换行>方法3：使用stringstream分割字符串（仅支持空格、回车、tab换行）<a hidden class=anchor aria-hidden=true href=#方法3使用stringstream分割字符串仅支持空格回车tab换行>#</a></h1><p>信息来源：<a href=https://www.cnblogs.com/narjaja/p/10044157.html>https://www.cnblogs.com/narjaja/p/10044157.html</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;12 34 567 888 99 100&#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>istringstream ss(str);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string word;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(ss<span style=color:#f92672>&gt;&gt;</span>word) {
</span></span><span style=display:flex><span>        res.push_back(word);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> r: res) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, r.c_str());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过C++的 &#187; ，像用户cin一样，将字符串“输入”，从而得到切分的效果。</p><p>如果要支持自定义分隔符，则可以使用getline()进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1_2_3_4_5_6&#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>stringstream ss(data);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string item;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> data <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (std<span style=color:#f92672>::</span>getline(ss, item, <span style=color:#e6db74>&#39;_&#39;</span>)) 
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> item <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=方法4通过c语言的strtok函数实现>方法4：通过C语言的strtok()函数实现<a hidden class=anchor aria-hidden=true href=#方法4通过c语言的strtok函数实现>#</a></h1><h2 id=第一种错误写法>第一种错误写法<a hidden class=anchor aria-hidden=true href=#第一种错误写法>#</a></h2><p>还有一种做法是通过C语言的strtok()函数进行处理。
在网上能找到类似这样结构的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> str[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> strtok(str, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也能正常得到结果：</p><pre tabindex=0><code>A
B
C
D
</code></pre><p>但是，当我打算在第11行进行cout输出时，发现结果并不会正常输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> str[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> strtok(str, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;abc&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此时输出的结果还是：</p><pre tabindex=0><code>A
B
C
D
</code></pre><p>并没有最后的abc。</p><p>问了ChatGPT后，得到的解释是：</p><p>这段C++代码中的问题是在循环输出切割后的子字符串时，先打印p的值再进行下一次循环。这会导致在最后一次循环结束后，p被设置为NULL，然后再尝试打印p的值，导致未定义行为。</p><p>在第8行，你打印了p的值，然后在第9行将其设置为下一个切割后的子字符串。接下来，在第10行的循环开始时，你再次打印p的值，但此时它可能已经为NULL，导致未定义行为。</p><p>为了修复这个问题，你可以将打印语句移到循环的末尾，这样先进行下一次循环再打印p的值，确保p不为NULL。</p><p>以下是修正后的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> str[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> strtok(str, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;abc&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样修改后，代码将正常输出切割后的子字符串，然后输出"abc"。请注意，std::endl用于在输出后添加换行符，以保证输出结果的正确格式。</p><h2 id=第二种错误写法>第二种错误写法<a hidden class=anchor aria-hidden=true href=#第二种错误写法>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;string.h&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> s[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p; 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>d <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>  p <span style=color:#f92672>=</span> strtok(s, d);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span>(p)
</span></span><span style=display:flex><span>  {  
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p);  
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;abc&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这一次我们在循环体中，先输出上一次切分的p，再读取下一次的p。但字符串“abc”还是没有正常输出。ChatGPT解答如下：</p><p>ChatGPT</p><p>这段代码中无法正常输出"abc"的原因是因为在使用strtok函数对字符串进行分割时，它会将原字符串中的分隔符替换为&rsquo;\0&rsquo;（空字符）来分割子字符串。这导致原字符串s被修改，后续的printf语句在遇到&rsquo;\0&rsquo;时会提前结束。</p><p>在代码中，原字符串s的内容为"A B C D"，而strtok(s, d)会将它分割成"A"、&ldquo;B&rdquo;、&ldquo;C"和"D"四个子字符串。因此，循环中的printf语句会输出这四个子字符串，分别为"A&rdquo;、&ldquo;B&rdquo;、&ldquo;C"和"D&rdquo;。</p><p>然后，在最后一次调用strtok(NULL, " &ldquo;)时，由于已经没有分隔符了，strtok会返回NULL，结束循环。然后，代码中的printf(&ldquo;abc&rdquo;)会尝试输出"abc&rdquo;，但是由于之前的strtok调用修改了原字符串s，将其中的空格替换为了&rsquo;\0&rsquo;，所以在输出"abc"之前，printf函数遇到了&rsquo;\0&rsquo;字符，将其视为字符串的结尾，导致输出提前结束。</p><p>如果你希望能够输出"abc"，你可以在printf语句中添加换行符\n，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> s[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A B C D&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>d <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>  p <span style=color:#f92672>=</span> strtok(s, d);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (p)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p);
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;abc</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);  <span style=color:#75715e>// 在&#34;abc&#34;后添加换行符\n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过上述修改，代码将能够正常输出"A"、&ldquo;B&rdquo;、&ldquo;C&rdquo;、&ldquo;D"和"abc&rdquo;。</p><h1 id=strtok函数>strtok()函数<a hidden class=anchor aria-hidden=true href=#strtok函数>#</a></h1><p>strtok()函数切割后，会在切断的位置上填充\0，会修改原字符串。所以一定要多加注意，慎用这个函数。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://windypath.com/posts/java_juc_briefly/><span class=title>« 上一页</span><br><span>Java并发编程中上锁的几种方式</span>
</a><a class=next href=https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/><span class=title>下一页 »</span><br><span>CSAPP第二章-信息的表示与处理</span></a></nav></footer></article></main><footer class=footer><span>Windypath 风萧古道 <strong>For Chinese Software</strong>. <a href=https://beian.miit.gov.cn/>闽ICP备15016446号-3</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>