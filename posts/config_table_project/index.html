<!doctype html><html lang=zh dir=auto><head><style></style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e);const t=document.createElement("link");t.href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&&display=swap",t.type="text/css",t.rel="stylesheet",document.head.appendChild(t)})()</script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>关于游戏服务器配置表功能的探讨 | 风萧古道 - 勤学苦练，年复一年</title>
<meta name=keywords content><meta name=description content="简介 在游戏开发中，配置表是策划与程序员之间针对功能模块开发而搭建的桥梁。配置表在游戏开发中扮演非常重要的角色。策划需要向配置表填入各种数据，以完成功能数值的配置；程序员需要在项目代码中读取配置表，根据配置表和需求决定的业务逻辑来开发功能模块。
本文想探讨接触过的两个项目的配置表功能设计。在本文中，我不会泄露项目相关的具体信息，仅针对方案进行讨论。
两种配置表方案简介 此处先以表格的形式，列举两种方案之间的异同：
条目 大型SLG手游 小型MMO手游 策划配置方式 使用Excel配置 使用Excel配置 代码读取方式 将Excel文件中的内容转换成Csv文件 将Excel文件中的内容转换成Json文件 读取后存储位置 在项目启动前，先读取Csv的内容到内存中，转成二进制文件写入Zookeeper，在项目启动时加载Zookeeper中的配置表信息到内存 在项目加载时读取Json到内存中 热更新方案 修改Zookeeper中的二进制文件，通过Zookeeper发布订阅机制，分布式系统中各个系统从Zookeeper中读取新的配置表信息 先修改Json文件，然后读取Json文件到内存中 配置表检查 在读取Csv到内存后，编写检查代码，检查内存对象之间的相关逻辑依赖 无 大型SLG手游 这是一个比较大型的SLG手游项目，使用了分布式的系统，服务器数量众多，因此需要一个统一的中心服务器来管理所有的配置信息。这个项目使用的是Zookeeper进行配置表的存储。
策划配置方式 策划使用Excel进行配置。每一列包含中文名、英文名、key类型(标记客户端、服务器或是客户端和服务器都用，且标记是否是key)、字段类型（数据data还是文字text）。
一张表最多只能有两个key，一个主key，一个副key。
比如，如果有一个可以领取宝箱的活动类型，活动可能有多个id，以满足不同的活动包装；每个活动都有多个宝箱。那么这张配置表的主key是活动id，副key是宝箱id。
读取配置表 首先将Excel文件中的内容转换成Csv文件，这一步会将客户端的配置列移除，仅保留服务器用到的配置列。然后使用Java代码读取Csv文件，将Csv文件中的数据构造成Java对象，然后再将Java对象序列化成二进制文件，上传到Zookeeper中的某个节点之下。
graph LR A[Excel文件]-->|Python转换|B[Csv文件]-->|Java代码读取|C[Zookeeper节点下]-->|服务器启动读取Zookeeper|D[服务器内存对象] 服务器启动时会从Zookeeper的节点中加载配置表文件。
在后续的开发过程中，发生过因为策划失误，修改了Excel后忘记生成Csv，而导致Excel文件与Csv文件不一致的情况。在这个项目中，Csv并不是读取配置表过程中最后的输出产物，仅仅是一个中间产物，所以内部也讨论过是否可以直接从Excel文件中读取到内存中的可能。
热更新方案 当服务器启动读取完Zookeeper中的配置表后，订阅Zookeeper中配置表节点的变化事件。
当配置表Excel文件被修改后，依次执行读取流程到上传到Zookeeper节点，此时触发节点变化事件，Zookeeper会将变化事件发布给所有订阅此节点的服务器，服务器接收到配置表节点变化后，再次加载新的配置表文件信息。
配置表检查 当Csv读取到内存后，会对每一场表生成一个Java表管理对象，Java表管理对象与配置表一一对应。同时，这个Java表管理对象中，还可以进行多张配置表之间的逻辑校验。比如奖励表中的道具，必须在道具表中有配置，否则就会报错。
小型MMO手游 这是一个比较小的MMO手游，服务器进程数量比较少，配置表的数量也不多。因此它不需要使用类似Zookeeper那样的配置中心，只需要各个服务器进程读取相同内容的Json文件即可。
策划配置方式 策划使用Excel进行配置表的编辑。表头包含中文名，英文名，类型（数字，或者any任意结构）。 一张表必须要有数字id，且必须列在第一列中。其他的部分不做强制要求。
读取配置表 Excel文件会转换为Json文件。 在代码中，服务器会加载所有的Json文件。
程序员一般不需要针对某一张配置表单独编写解析代码。每一张表都有一个id，其他字段都默认读取为Golang的interface{}类型，每一张表都能读取成统一的格式，即：表名-id-其余各列数据。如果这张表是一张只有一个key的表，那么可以直接通过表名+id查找对应的数据。
但如果是不止一个key的表，那么可以在默认加载之后，再新开辟内存空间，使用自定义的结构进行存储。
热更新方案 策划修改配置表Excel文件后，转成Json文件，然后手动上传到服务器中。 通过RPC的方式，向网关服务器发送“重新读取配置表”消息，网关通知服务器集群中的所有服务器进程，重新读取Json文件到内存中，替换之前的配置表内存数据。
配置表检查 没有配置表提前检查，仅在使用配置的时候抛出err错误。
优缺点 类型 大型SLG手游 小型MMO手游 优点 (1)热更新方便，一次发布到Zk上之后，所有服务器都更新
(2)有配置表检查，在加载配置表时校验配置错误信息 (1)所有表都有默认取值的方法，方便开发
(2)Excel转Json后，Json文件方便人类阅读 缺点 (1)Excel生成的Csv可读性差，维护性差，不如XML，Json带有自己的结构信息
(2)开发繁琐，需要为每一张表定义类，并且预测配置表的关联，有可能会因为过度关联导致自由度下降
(3)在这个项目中，一个Excel对应一张配置表，导致Excel表数量过多，难以分类维护 (1)没有配置表校验，配错值只能等业务运行时抛出Error"><meta name=author content="JohnathanLin"><link rel=canonical href=https://windypath.com/posts/config_table_project/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2f177b1b6eb79e1631c2df839a71d75010d40323c2f391bcbd4fa49da11a1334.css integrity="sha256-Lxd7G263nhYxwt+DmnHXUBDUAyPC85G8vU+knaEaEzQ=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://windypath.com/posts/config_table_project/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ",{anonymize_ip:!1})}</script><meta property="og:title" content="关于游戏服务器配置表功能的探讨"><meta property="og:description" content="简介 在游戏开发中，配置表是策划与程序员之间针对功能模块开发而搭建的桥梁。配置表在游戏开发中扮演非常重要的角色。策划需要向配置表填入各种数据，以完成功能数值的配置；程序员需要在项目代码中读取配置表，根据配置表和需求决定的业务逻辑来开发功能模块。
本文想探讨接触过的两个项目的配置表功能设计。在本文中，我不会泄露项目相关的具体信息，仅针对方案进行讨论。
两种配置表方案简介 此处先以表格的形式，列举两种方案之间的异同：
条目 大型SLG手游 小型MMO手游 策划配置方式 使用Excel配置 使用Excel配置 代码读取方式 将Excel文件中的内容转换成Csv文件 将Excel文件中的内容转换成Json文件 读取后存储位置 在项目启动前，先读取Csv的内容到内存中，转成二进制文件写入Zookeeper，在项目启动时加载Zookeeper中的配置表信息到内存 在项目加载时读取Json到内存中 热更新方案 修改Zookeeper中的二进制文件，通过Zookeeper发布订阅机制，分布式系统中各个系统从Zookeeper中读取新的配置表信息 先修改Json文件，然后读取Json文件到内存中 配置表检查 在读取Csv到内存后，编写检查代码，检查内存对象之间的相关逻辑依赖 无 大型SLG手游 这是一个比较大型的SLG手游项目，使用了分布式的系统，服务器数量众多，因此需要一个统一的中心服务器来管理所有的配置信息。这个项目使用的是Zookeeper进行配置表的存储。
策划配置方式 策划使用Excel进行配置。每一列包含中文名、英文名、key类型(标记客户端、服务器或是客户端和服务器都用，且标记是否是key)、字段类型（数据data还是文字text）。
一张表最多只能有两个key，一个主key，一个副key。
比如，如果有一个可以领取宝箱的活动类型，活动可能有多个id，以满足不同的活动包装；每个活动都有多个宝箱。那么这张配置表的主key是活动id，副key是宝箱id。
读取配置表 首先将Excel文件中的内容转换成Csv文件，这一步会将客户端的配置列移除，仅保留服务器用到的配置列。然后使用Java代码读取Csv文件，将Csv文件中的数据构造成Java对象，然后再将Java对象序列化成二进制文件，上传到Zookeeper中的某个节点之下。
graph LR A[Excel文件]-->|Python转换|B[Csv文件]-->|Java代码读取|C[Zookeeper节点下]-->|服务器启动读取Zookeeper|D[服务器内存对象] 服务器启动时会从Zookeeper的节点中加载配置表文件。
在后续的开发过程中，发生过因为策划失误，修改了Excel后忘记生成Csv，而导致Excel文件与Csv文件不一致的情况。在这个项目中，Csv并不是读取配置表过程中最后的输出产物，仅仅是一个中间产物，所以内部也讨论过是否可以直接从Excel文件中读取到内存中的可能。
热更新方案 当服务器启动读取完Zookeeper中的配置表后，订阅Zookeeper中配置表节点的变化事件。
当配置表Excel文件被修改后，依次执行读取流程到上传到Zookeeper节点，此时触发节点变化事件，Zookeeper会将变化事件发布给所有订阅此节点的服务器，服务器接收到配置表节点变化后，再次加载新的配置表文件信息。
配置表检查 当Csv读取到内存后，会对每一场表生成一个Java表管理对象，Java表管理对象与配置表一一对应。同时，这个Java表管理对象中，还可以进行多张配置表之间的逻辑校验。比如奖励表中的道具，必须在道具表中有配置，否则就会报错。
小型MMO手游 这是一个比较小的MMO手游，服务器进程数量比较少，配置表的数量也不多。因此它不需要使用类似Zookeeper那样的配置中心，只需要各个服务器进程读取相同内容的Json文件即可。
策划配置方式 策划使用Excel进行配置表的编辑。表头包含中文名，英文名，类型（数字，或者any任意结构）。 一张表必须要有数字id，且必须列在第一列中。其他的部分不做强制要求。
读取配置表 Excel文件会转换为Json文件。 在代码中，服务器会加载所有的Json文件。
程序员一般不需要针对某一张配置表单独编写解析代码。每一张表都有一个id，其他字段都默认读取为Golang的interface{}类型，每一张表都能读取成统一的格式，即：表名-id-其余各列数据。如果这张表是一张只有一个key的表，那么可以直接通过表名+id查找对应的数据。
但如果是不止一个key的表，那么可以在默认加载之后，再新开辟内存空间，使用自定义的结构进行存储。
热更新方案 策划修改配置表Excel文件后，转成Json文件，然后手动上传到服务器中。 通过RPC的方式，向网关服务器发送“重新读取配置表”消息，网关通知服务器集群中的所有服务器进程，重新读取Json文件到内存中，替换之前的配置表内存数据。
配置表检查 没有配置表提前检查，仅在使用配置的时候抛出err错误。
优缺点 类型 大型SLG手游 小型MMO手游 优点 (1)热更新方便，一次发布到Zk上之后，所有服务器都更新
(2)有配置表检查，在加载配置表时校验配置错误信息 (1)所有表都有默认取值的方法，方便开发
(2)Excel转Json后，Json文件方便人类阅读 缺点 (1)Excel生成的Csv可读性差，维护性差，不如XML，Json带有自己的结构信息
(2)开发繁琐，需要为每一张表定义类，并且预测配置表的关联，有可能会因为过度关联导致自由度下降
(3)在这个项目中，一个Excel对应一张配置表，导致Excel表数量过多，难以分类维护 (1)没有配置表校验，配错值只能等业务运行时抛出Error"><meta property="og:type" content="article"><meta property="og:url" content="https://windypath.com/posts/config_table_project/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-24T16:15:34+08:00"><meta property="article:modified_time" content="2023-12-24T16:15:34+08:00"><meta property="og:site_name" content="Windypath"><meta name=twitter:card content="summary"><meta name=twitter:title content="关于游戏服务器配置表功能的探讨"><meta name=twitter:description content="简介 在游戏开发中，配置表是策划与程序员之间针对功能模块开发而搭建的桥梁。配置表在游戏开发中扮演非常重要的角色。策划需要向配置表填入各种数据，以完成功能数值的配置；程序员需要在项目代码中读取配置表，根据配置表和需求决定的业务逻辑来开发功能模块。
本文想探讨接触过的两个项目的配置表功能设计。在本文中，我不会泄露项目相关的具体信息，仅针对方案进行讨论。
两种配置表方案简介 此处先以表格的形式，列举两种方案之间的异同：
条目 大型SLG手游 小型MMO手游 策划配置方式 使用Excel配置 使用Excel配置 代码读取方式 将Excel文件中的内容转换成Csv文件 将Excel文件中的内容转换成Json文件 读取后存储位置 在项目启动前，先读取Csv的内容到内存中，转成二进制文件写入Zookeeper，在项目启动时加载Zookeeper中的配置表信息到内存 在项目加载时读取Json到内存中 热更新方案 修改Zookeeper中的二进制文件，通过Zookeeper发布订阅机制，分布式系统中各个系统从Zookeeper中读取新的配置表信息 先修改Json文件，然后读取Json文件到内存中 配置表检查 在读取Csv到内存后，编写检查代码，检查内存对象之间的相关逻辑依赖 无 大型SLG手游 这是一个比较大型的SLG手游项目，使用了分布式的系统，服务器数量众多，因此需要一个统一的中心服务器来管理所有的配置信息。这个项目使用的是Zookeeper进行配置表的存储。
策划配置方式 策划使用Excel进行配置。每一列包含中文名、英文名、key类型(标记客户端、服务器或是客户端和服务器都用，且标记是否是key)、字段类型（数据data还是文字text）。
一张表最多只能有两个key，一个主key，一个副key。
比如，如果有一个可以领取宝箱的活动类型，活动可能有多个id，以满足不同的活动包装；每个活动都有多个宝箱。那么这张配置表的主key是活动id，副key是宝箱id。
读取配置表 首先将Excel文件中的内容转换成Csv文件，这一步会将客户端的配置列移除，仅保留服务器用到的配置列。然后使用Java代码读取Csv文件，将Csv文件中的数据构造成Java对象，然后再将Java对象序列化成二进制文件，上传到Zookeeper中的某个节点之下。
graph LR A[Excel文件]-->|Python转换|B[Csv文件]-->|Java代码读取|C[Zookeeper节点下]-->|服务器启动读取Zookeeper|D[服务器内存对象] 服务器启动时会从Zookeeper的节点中加载配置表文件。
在后续的开发过程中，发生过因为策划失误，修改了Excel后忘记生成Csv，而导致Excel文件与Csv文件不一致的情况。在这个项目中，Csv并不是读取配置表过程中最后的输出产物，仅仅是一个中间产物，所以内部也讨论过是否可以直接从Excel文件中读取到内存中的可能。
热更新方案 当服务器启动读取完Zookeeper中的配置表后，订阅Zookeeper中配置表节点的变化事件。
当配置表Excel文件被修改后，依次执行读取流程到上传到Zookeeper节点，此时触发节点变化事件，Zookeeper会将变化事件发布给所有订阅此节点的服务器，服务器接收到配置表节点变化后，再次加载新的配置表文件信息。
配置表检查 当Csv读取到内存后，会对每一场表生成一个Java表管理对象，Java表管理对象与配置表一一对应。同时，这个Java表管理对象中，还可以进行多张配置表之间的逻辑校验。比如奖励表中的道具，必须在道具表中有配置，否则就会报错。
小型MMO手游 这是一个比较小的MMO手游，服务器进程数量比较少，配置表的数量也不多。因此它不需要使用类似Zookeeper那样的配置中心，只需要各个服务器进程读取相同内容的Json文件即可。
策划配置方式 策划使用Excel进行配置表的编辑。表头包含中文名，英文名，类型（数字，或者any任意结构）。 一张表必须要有数字id，且必须列在第一列中。其他的部分不做强制要求。
读取配置表 Excel文件会转换为Json文件。 在代码中，服务器会加载所有的Json文件。
程序员一般不需要针对某一张配置表单独编写解析代码。每一张表都有一个id，其他字段都默认读取为Golang的interface{}类型，每一张表都能读取成统一的格式，即：表名-id-其余各列数据。如果这张表是一张只有一个key的表，那么可以直接通过表名+id查找对应的数据。
但如果是不止一个key的表，那么可以在默认加载之后，再新开辟内存空间，使用自定义的结构进行存储。
热更新方案 策划修改配置表Excel文件后，转成Json文件，然后手动上传到服务器中。 通过RPC的方式，向网关服务器发送“重新读取配置表”消息，网关通知服务器集群中的所有服务器进程，重新读取Json文件到内存中，替换之前的配置表内存数据。
配置表检查 没有配置表提前检查，仅在使用配置的时候抛出err错误。
优缺点 类型 大型SLG手游 小型MMO手游 优点 (1)热更新方便，一次发布到Zk上之后，所有服务器都更新
(2)有配置表检查，在加载配置表时校验配置错误信息 (1)所有表都有默认取值的方法，方便开发
(2)Excel转Json后，Json文件方便人类阅读 缺点 (1)Excel生成的Csv可读性差，维护性差，不如XML，Json带有自己的结构信息
(2)开发繁琐，需要为每一张表定义类，并且预测配置表的关联，有可能会因为过度关联导致自由度下降
(3)在这个项目中，一个Excel对应一张配置表，导致Excel表数量过多，难以分类维护 (1)没有配置表校验，配错值只能等业务运行时抛出Error"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windypath.com/posts/"},{"@type":"ListItem","position":2,"name":"关于游戏服务器配置表功能的探讨","item":"https://windypath.com/posts/config_table_project/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"关于游戏服务器配置表功能的探讨","name":"关于游戏服务器配置表功能的探讨","description":"简介 在游戏开发中，配置表是策划与程序员之间针对功能模块开发而搭建的桥梁。配置表在游戏开发中扮演非常重要的角色。策划需要向配置表填入各种数据，以完成功能数值的配置；程序员需要在项目代码中读取配置表，根据配置表和需求决定的业务逻辑来开发功能模块。 本文想探讨接触过的两个项目的配置表功能设计。在本文中，我不会泄露项目相关的具体信息，仅针对方案进行讨论。 两种配置表方案简介 此处先以表格的形式，列举两种方案之间的异同： 条目 大型SLG手游 小型MMO手游 策划配置方式 使用Excel配置 使用Excel配置 代码读取方式 将Excel文件中的内容转换成Csv文件 将Excel文件中的内容转换成Json文件 读取后存储位置 在项目启动前，先读取Csv的内容到内存中，转成二进制文件写入Zookeeper，在项目启动时加载Zookeeper中的配置表信息到内存 在项目加载时读取Json到内存中 热更新方案 修改Zookeeper中的二进制文件，通过Zookeeper发布订阅机制，分布式系统中各个系统从Zookeeper中读取新的配置表信息 先修改Json文件，然后读取Json文件到内存中 配置表检查 在读取Csv到内存后，编写检查代码，检查内存对象之间的相关逻辑依赖 无 大型SLG手游 这是一个比较大型的SLG手游项目，使用了分布式的系统，服务器数量众多，因此需要一个统一的中心服务器来管理所有的配置信息。这个项目使用的是Zookeeper进行配置表的存储。 策划配置方式 策划使用Excel进行配置。每一列包含中文名、英文名、key类型(标记客户端、服务器或是客户端和服务器都用，且标记是否是key)、字段类型（数据data还是文字text）。 一张表最多只能有两个key，一个主key，一个副key。 比如，如果有一个可以领取宝箱的活动类型，活动可能有多个id，以满足不同的活动包装；每个活动都有多个宝箱。那么这张配置表的主key是活动id，副key是宝箱id。 读取配置表 首先将Excel文件中的内容转换成Csv文件，这一步会将客户端的配置列移除，仅保留服务器用到的配置列。然后使用Java代码读取Csv文件，将Csv文件中的数据构造成Java对象，然后再将Java对象序列化成二进制文件，上传到Zookeeper中的某个节点之下。 graph LR A[Excel文件]--\u003e|Python转换|B[Csv文件]--\u003e|Java代码读取|C[Zookeeper节点下]--\u003e|服务器启动读取Zookeeper|D[服务器内存对象] 服务器启动时会从Zookeeper的节点中加载配置表文件。 在后续的开发过程中，发生过因为策划失误，修改了Excel后忘记生成Csv，而导致Excel文件与Csv文件不一致的情况。在这个项目中，Csv并不是读取配置表过程中最后的输出产物，仅仅是一个中间产物，所以内部也讨论过是否可以直接从Excel文件中读取到内存中的可能。 热更新方案 当服务器启动读取完Zookeeper中的配置表后，订阅Zookeeper中配置表节点的变化事件。 当配置表Excel文件被修改后，依次执行读取流程到上传到Zookeeper节点，此时触发节点变化事件，Zookeeper会将变化事件发布给所有订阅此节点的服务器，服务器接收到配置表节点变化后，再次加载新的配置表文件信息。 配置表检查 当Csv读取到内存后，会对每一场表生成一个Java表管理对象，Java表管理对象与配置表一一对应。同时，这个Java表管理对象中，还可以进行多张配置表之间的逻辑校验。比如奖励表中的道具，必须在道具表中有配置，否则就会报错。 小型MMO手游 这是一个比较小的MMO手游，服务器进程数量比较少，配置表的数量也不多。因此它不需要使用类似Zookeeper那样的配置中心，只需要各个服务器进程读取相同内容的Json文件即可。 策划配置方式 策划使用Excel进行配置表的编辑。表头包含中文名，英文名，类型（数字，或者any任意结构）。 一张表必须要有数字id，且必须列在第一列中。其他的部分不做强制要求。 读取配置表 Excel文件会转换为Json文件。 在代码中，服务器会加载所有的Json文件。 程序员一般不需要针对某一张配置表单独编写解析代码。每一张表都有一个id，其他字段都默认读取为Golang的interface{}类型，每一张表都能读取成统一的格式，即：表名-id-其余各列数据。如果这张表是一张只有一个key的表，那么可以直接通过表名+id查找对应的数据。 但如果是不止一个key的表，那么可以在默认加载之后，再新开辟内存空间，使用自定义的结构进行存储。 热更新方案 策划修改配置表Excel文件后，转成Json文件，然后手动上传到服务器中。 通过RPC的方式，向网关服务器发送“重新读取配置表”消息，网关通知服务器集群中的所有服务器进程，重新读取Json文件到内存中，替换之前的配置表内存数据。 配置表检查 没有配置表提前检查，仅在使用配置的时候抛出err错误。 优缺点 类型 大型SLG手游 小型MMO手游 优点 (1)热更新方便，一次发布到Zk上之后，所有服务器都更新 (2)有配置表检查，在加载配置表时校验配置错误信息 (1)所有表都有默认取值的方法，方便开发 (2)Excel转Json后，Json文件方便人类阅读 缺点 (1)Excel生成的Csv可读性差，维护性差，不如XML，Json带有自己的结构信息 (2)开发繁琐，需要为每一张表定义类，并且预测配置表的关联，有可能会因为过度关联导致自由度下降 (3)在这个项目中，一个Excel对应一张配置表，导致Excel表数量过多，难以分类维护 (1)没有配置表校验，配错值只能等业务运行时抛出Error","keywords":[],"articleBody":"简介 在游戏开发中，配置表是策划与程序员之间针对功能模块开发而搭建的桥梁。配置表在游戏开发中扮演非常重要的角色。策划需要向配置表填入各种数据，以完成功能数值的配置；程序员需要在项目代码中读取配置表，根据配置表和需求决定的业务逻辑来开发功能模块。\n本文想探讨接触过的两个项目的配置表功能设计。在本文中，我不会泄露项目相关的具体信息，仅针对方案进行讨论。\n两种配置表方案简介 此处先以表格的形式，列举两种方案之间的异同：\n条目 大型SLG手游 小型MMO手游 策划配置方式 使用Excel配置 使用Excel配置 代码读取方式 将Excel文件中的内容转换成Csv文件 将Excel文件中的内容转换成Json文件 读取后存储位置 在项目启动前，先读取Csv的内容到内存中，转成二进制文件写入Zookeeper，在项目启动时加载Zookeeper中的配置表信息到内存 在项目加载时读取Json到内存中 热更新方案 修改Zookeeper中的二进制文件，通过Zookeeper发布订阅机制，分布式系统中各个系统从Zookeeper中读取新的配置表信息 先修改Json文件，然后读取Json文件到内存中 配置表检查 在读取Csv到内存后，编写检查代码，检查内存对象之间的相关逻辑依赖 无 大型SLG手游 这是一个比较大型的SLG手游项目，使用了分布式的系统，服务器数量众多，因此需要一个统一的中心服务器来管理所有的配置信息。这个项目使用的是Zookeeper进行配置表的存储。\n策划配置方式 策划使用Excel进行配置。每一列包含中文名、英文名、key类型(标记客户端、服务器或是客户端和服务器都用，且标记是否是key)、字段类型（数据data还是文字text）。\n一张表最多只能有两个key，一个主key，一个副key。\n比如，如果有一个可以领取宝箱的活动类型，活动可能有多个id，以满足不同的活动包装；每个活动都有多个宝箱。那么这张配置表的主key是活动id，副key是宝箱id。\n读取配置表 首先将Excel文件中的内容转换成Csv文件，这一步会将客户端的配置列移除，仅保留服务器用到的配置列。然后使用Java代码读取Csv文件，将Csv文件中的数据构造成Java对象，然后再将Java对象序列化成二进制文件，上传到Zookeeper中的某个节点之下。\ngraph LR A[Excel文件]--\u003e|Python转换|B[Csv文件]--\u003e|Java代码读取|C[Zookeeper节点下]--\u003e|服务器启动读取Zookeeper|D[服务器内存对象] 服务器启动时会从Zookeeper的节点中加载配置表文件。\n在后续的开发过程中，发生过因为策划失误，修改了Excel后忘记生成Csv，而导致Excel文件与Csv文件不一致的情况。在这个项目中，Csv并不是读取配置表过程中最后的输出产物，仅仅是一个中间产物，所以内部也讨论过是否可以直接从Excel文件中读取到内存中的可能。\n热更新方案 当服务器启动读取完Zookeeper中的配置表后，订阅Zookeeper中配置表节点的变化事件。\n当配置表Excel文件被修改后，依次执行读取流程到上传到Zookeeper节点，此时触发节点变化事件，Zookeeper会将变化事件发布给所有订阅此节点的服务器，服务器接收到配置表节点变化后，再次加载新的配置表文件信息。\n配置表检查 当Csv读取到内存后，会对每一场表生成一个Java表管理对象，Java表管理对象与配置表一一对应。同时，这个Java表管理对象中，还可以进行多张配置表之间的逻辑校验。比如奖励表中的道具，必须在道具表中有配置，否则就会报错。\n小型MMO手游 这是一个比较小的MMO手游，服务器进程数量比较少，配置表的数量也不多。因此它不需要使用类似Zookeeper那样的配置中心，只需要各个服务器进程读取相同内容的Json文件即可。\n策划配置方式 策划使用Excel进行配置表的编辑。表头包含中文名，英文名，类型（数字，或者any任意结构）。 一张表必须要有数字id，且必须列在第一列中。其他的部分不做强制要求。\n读取配置表 Excel文件会转换为Json文件。 在代码中，服务器会加载所有的Json文件。\n程序员一般不需要针对某一张配置表单独编写解析代码。每一张表都有一个id，其他字段都默认读取为Golang的interface{}类型，每一张表都能读取成统一的格式，即：表名-id-其余各列数据。如果这张表是一张只有一个key的表，那么可以直接通过表名+id查找对应的数据。\n但如果是不止一个key的表，那么可以在默认加载之后，再新开辟内存空间，使用自定义的结构进行存储。\n热更新方案 策划修改配置表Excel文件后，转成Json文件，然后手动上传到服务器中。 通过RPC的方式，向网关服务器发送“重新读取配置表”消息，网关通知服务器集群中的所有服务器进程，重新读取Json文件到内存中，替换之前的配置表内存数据。\n配置表检查 没有配置表提前检查，仅在使用配置的时候抛出err错误。\n优缺点 类型 大型SLG手游 小型MMO手游 优点 (1)热更新方便，一次发布到Zk上之后，所有服务器都更新\n(2)有配置表检查，在加载配置表时校验配置错误信息 (1)所有表都有默认取值的方法，方便开发\n(2)Excel转Json后，Json文件方便人类阅读 缺点 (1)Excel生成的Csv可读性差，维护性差，不如XML，Json带有自己的结构信息\n(2)开发繁琐，需要为每一张表定义类，并且预测配置表的关联，有可能会因为过度关联导致自由度下降\n(3)在这个项目中，一个Excel对应一张配置表，导致Excel表数量过多，难以分类维护 (1)没有配置表校验，配错值只能等业务运行时抛出Error\n(2)热更新时，需要到所有服务器手动上传配置表json文件，然后再RPC发送到服务器执行配置表json文件的重新读取。\n(3)策划需要多维护一份Excel配置表生成客户端、服务器的不同Json的配置文件 配置表功能的一些思考 接下来是在两个项目中，和不同类型的策划沟通，使用完全不同的编程语言和设计方式开发之中，自己进行的一部分思考。\n所有的值一定要灵活配置吗？ 在SLG游戏中，由于是一个Java项目，团队里开发过程中非常忌讳“魔法数字”，如果功能要求不会改变某个值，领导一般会要求大家在枚举类或者常量中新增这个功能专属的常量。这本身没有什么问题。但是有时候问题出在策划身上，策划设计的时候并不清楚某个值是否有改变的可能。为了规避这种可能，我们开发时几乎将所有的可变的值，都做成了配置表中读取全局变量。\n这会带来一个问题：是否有些值是不存在改变的可能性的，或者说，改变可能很小？ 比如，有一个活动是领取2个宝箱，而且UI设计的时候已经设计好了两个宝箱在游戏屏幕中摆放的位置，那么如果这个值交给策划配置，策划也不敢去修改这个值。那么这个值就属于“没有必要放权给策划配置的值”。\n你可能会说，如果下次开活动，策划要配置3个宝箱，那还是要改代码，不是吗？没错，但是此时客户端，美术UI都要修改，到时候QA还是要统一测，这时候服务器一起跟进修改一个写死的魔法数字，对整条链路上的人都没有影响：策划还是要增加第三个宝箱的奖励配置、美术UI要设计三个宝箱在屏幕中的比例，QA还是要完整跑一遍活动。因此就算这个宝箱数量的值交给策划配置，也不会让这一切有什么优化，而更有可能的是，由于没有服务器开发的参与，策划配错了值，回过头来还是服务器这边查问题。\n配置表的key的约定 我们还是以刚才的例子，一个活动可以配置多个宝箱，并且同时可以开启多个活动。有两个活动，id为1和2，每个活动会开3个宝箱，id为1,2和3。\n在SLG项目中，它的Excel配置表如下： 活动id 宝箱id 宝箱奖励 allmainkey allchildkey all 1 1 xxx 1 2 xxx 1 3 xxx 2 1 xxx 2 2 xxx 2 3 xxx 在这里，allmainkey是指这张表的主key是活动id，allchildkey是指这张表的副key是宝箱id。并且必须要按照这种格式配置，才能导出正确的Csv文件，执行后续的操作。\n如果一张表需要三个key，则在目前的条件下，由于没有类似allthirdkey的约定，所以第三个key无法被标识。\n在MMO项目中，它的Excel配置如下 id 活动id 宝箱id 宝箱奖励 101 1 1 xxx 102 1 2 xxx 103 1 3 xxx 201 2 1 xxx 202 2 2 xxx 203 2 3 xxx 这张表在功能逻辑上，只有一个key: id。这个id的生成逻辑是: 活动id * 100 + 宝箱id。如此依赖，只要活动和宝箱没有重复，则id也不会有重复。并且也解决了上面的那个问题：如果需要三个key，则只需要往后加新的逻辑id列，然后对id的生成规则进行修改即可。\n在SLG项目中，表的结构固定了只能拥有两个key，一主一从，导致大家不得不按照固定的写法去进行配置。但在MMO项目中，它更注重于逻辑上的设计，使用体验也更加灵活。\n配置表需要注释吗？ 先说结论：配置表需要注释，但是不应该写在配置表里。\n在策划的工作过程中，策划不断修改配置表的值，以达到自己的设计目的。在此过程中，存在多次与程序商讨修改表结构/字段含义的过程。由于配置表并不直接完成功能，所以策划很难对配置值的使用方式有清楚的认知。在需求被修改、程序开发时提议修改优化、或是最后测试时遇到问题时，我们可能会急于完成功能而忽略策划表另一页的注释页，导致注释与实际效果不符合的情况。\n我们终究是从代码层面来排查配置表的值是如何被使用的，因此我认为代码中的注释总体优于策划表的注释。\n配置表究竟由程序员设计，还是由策划设计？ 在大部分情况下，由策划设计。原因是功能设计者在设计的时候，对自己设计过程中的敏感数值有深刻的印象。因此配置表应该根据这些数值进行规划和设计。\n但在部分情况下，如在之前的功能上进行所谓的优化，策划无法对旧有功能有全面认知的时候，容易出现新增重复功能的表、或是直接“复用”、“拓展”之前的表。有时这会让程序员感到莫名其妙。因此在这种情况下，程序员需要仔细倾听策划的需求，然后对旧有功能进行整理，商讨出新的解决方案。在这个过程中，可能是程序员进行策划表的设计。\n总结 配置表是游戏开发中不可或缺的一部分，但是目前还找不到比Excel更方便的配置表管理编辑工具。策划可以用Excel做很多方便的计算，但是到了程序员这里，读取Excel之后的步骤，每一步都值得探讨。读取如何更高效、流程如何更健壮，更不容易出现人为的失误、热更如何更方便快捷、结构如何更简单易懂，易于维护。\n我的经验如下：\n从Excel到内存中，最好只有一个中间产物。在SLG项目中，由于存在Excel转Csv和Csv读取后转二进制文件这两个步骤，导致每一次读取出错，都要排查Excel和Csv两个文件。、 热更新的功能，最好只有两个步骤：打包和上传。打包是指将Excel转成最后服务器可读取的文件，上传是指将生成的文件传入Zookeeper或者其他的配置中心，由配置中心通知服务器进行热更新操作。而不是由人工上传，人工执行热更新。 一张表只能有一个key，但是可以有多个逻辑上的id，这样可以保持一定的多key自由度，且可以通过唯一key找到某一行记录，方便客户端-服务器之间通信。 配置表不需要注释，只需要用简短清晰的词汇，对某一列的功能和使用场景表述清楚，但是程序代码中要对使用配置表的具体位置进行一些描述（当某些字段有特殊枚举含义/需要除以100转成小数之类）。、 配置表优先让策划进行设计，只有设计配置表的人，才知道功能的具体效果。（这个过程并不是要求一定要让策划把完整的策划表设计完，而是要求策划要尽可能全面的列出功能中所需要配置的字段。）如此一来，程序员才能对功能开发更有把握，可以从需要的字段中窥探策划的真实设计方向。 ","wordCount":"160","inLanguage":"zh","datePublished":"2023-12-24T16:15:34+08:00","dateModified":"2023-12-24T16:15:34+08:00","author":{"@type":"Person","name":"JohnathanLin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://windypath.com/posts/config_table_project/"},"publisher":{"@type":"Organization","name":"风萧古道 - 勤学苦练，年复一年","logo":{"@type":"ImageObject","url":"https://windypath.com/%3Clink%20/%20abs%20url%3E"}}}</script><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ")</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windypath.com/ accesskey=h title="风萧古道 (Alt + H)">风萧古道</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windypath.com/en/ title="Switch to English Page" aria-label="Switch to English Page">En</a></li></ul></div></div><ul id=menu><li><a href=https://windypath.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://windypath.com/categories/ title=分类><span>分类</span></a></li><li><a href=https://windypath.com/about/ title=关于><span>关于</span></a></li><li><a href=https://windypath.com/mybooks/ title=藏书><span>藏书</span></a></li><li><a href=https://windypath.com/myfriends/ title=朋友><span>朋友</span></a></li><li><a href=https://windypath.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>关于游戏服务器配置表功能的探讨</h1><div class=post-meta>&lt;span title='2023-12-24 16:15:34 +0800 +0800'>十二月 24, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;JohnathanLin</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e7%ae%80%e4%bb%8b aria-label=简介>简介</a></li><li><a href=#%e4%b8%a4%e7%a7%8d%e9%85%8d%e7%bd%ae%e8%a1%a8%e6%96%b9%e6%a1%88%e7%ae%80%e4%bb%8b aria-label=两种配置表方案简介>两种配置表方案简介</a><ul><li><a href=#%e5%a4%a7%e5%9e%8bslg%e6%89%8b%e6%b8%b8 aria-label=大型SLG手游>大型SLG手游</a><ul><li><a href=#%e7%ad%96%e5%88%92%e9%85%8d%e7%bd%ae%e6%96%b9%e5%bc%8f aria-label=策划配置方式>策划配置方式</a></li><li><a href=#%e8%af%bb%e5%8f%96%e9%85%8d%e7%bd%ae%e8%a1%a8 aria-label=读取配置表>读取配置表</a></li><li><a href=#%e7%83%ad%e6%9b%b4%e6%96%b0%e6%96%b9%e6%a1%88 aria-label=热更新方案>热更新方案</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e8%a1%a8%e6%a3%80%e6%9f%a5 aria-label=配置表检查>配置表检查</a></li></ul></li><li><a href=#%e5%b0%8f%e5%9e%8bmmo%e6%89%8b%e6%b8%b8 aria-label=小型MMO手游>小型MMO手游</a><ul><li><a href=#%e7%ad%96%e5%88%92%e9%85%8d%e7%bd%ae%e6%96%b9%e5%bc%8f-1 aria-label=策划配置方式>策划配置方式</a></li><li><a href=#%e8%af%bb%e5%8f%96%e9%85%8d%e7%bd%ae%e8%a1%a8-1 aria-label=读取配置表>读取配置表</a></li><li><a href=#%e7%83%ad%e6%9b%b4%e6%96%b0%e6%96%b9%e6%a1%88-1 aria-label=热更新方案>热更新方案</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e8%a1%a8%e6%a3%80%e6%9f%a5-1 aria-label=配置表检查>配置表检查</a></li></ul></li><li><a href=#%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=优缺点>优缺点</a></li></ul></li><li><a href=#%e9%85%8d%e7%bd%ae%e8%a1%a8%e5%8a%9f%e8%83%bd%e7%9a%84%e4%b8%80%e4%ba%9b%e6%80%9d%e8%80%83 aria-label=配置表功能的一些思考>配置表功能的一些思考</a><ul><li><a href=#%e6%89%80%e6%9c%89%e7%9a%84%e5%80%bc%e4%b8%80%e5%ae%9a%e8%a6%81%e7%81%b5%e6%b4%bb%e9%85%8d%e7%bd%ae%e5%90%97 aria-label=所有的值一定要灵活配置吗？>所有的值一定要灵活配置吗？</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e8%a1%a8%e7%9a%84key%e7%9a%84%e7%ba%a6%e5%ae%9a aria-label=配置表的key的约定>配置表的key的约定</a><ul><li><a href=#%e5%9c%a8slg%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%ae%83%e7%9a%84excel%e9%85%8d%e7%bd%ae%e8%a1%a8%e5%a6%82%e4%b8%8b aria-label=在SLG项目中，它的Excel配置表如下：>在SLG项目中，它的Excel配置表如下：</a></li><li><a href=#%e5%9c%a8mmo%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%ae%83%e7%9a%84excel%e9%85%8d%e7%bd%ae%e5%a6%82%e4%b8%8b aria-label=在MMO项目中，它的Excel配置如下>在MMO项目中，它的Excel配置如下</a></li></ul></li><li><a href=#%e9%85%8d%e7%bd%ae%e8%a1%a8%e9%9c%80%e8%a6%81%e6%b3%a8%e9%87%8a%e5%90%97 aria-label=配置表需要注释吗？>配置表需要注释吗？</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e8%a1%a8%e7%a9%b6%e7%ab%9f%e7%94%b1%e7%a8%8b%e5%ba%8f%e5%91%98%e8%ae%be%e8%ae%a1%e8%bf%98%e6%98%af%e7%94%b1%e7%ad%96%e5%88%92%e8%ae%be%e8%ae%a1 aria-label=配置表究竟由程序员设计，还是由策划设计？>配置表究竟由程序员设计，还是由策划设计？</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h1 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>#</a></h1><p>在游戏开发中，配置表是策划与程序员之间针对功能模块开发而搭建的桥梁。配置表在游戏开发中扮演非常重要的角色。策划需要向配置表填入各种数据，以完成功能数值的配置；程序员需要在项目代码中读取配置表，根据配置表和需求决定的业务逻辑来开发功能模块。</p><p>本文想探讨接触过的两个项目的配置表功能设计。在本文中，我不会泄露项目相关的具体信息，仅针对方案进行讨论。</p><h1 id=两种配置表方案简介>两种配置表方案简介<a hidden class=anchor aria-hidden=true href=#两种配置表方案简介>#</a></h1><p>此处先以表格的形式，列举两种方案之间的异同：</p><table><thead><tr><th style=text-align:left>条目</th><th style=text-align:left>大型SLG手游</th><th style=text-align:left>小型MMO手游</th></tr></thead><tbody><tr><td style=text-align:left>策划配置方式</td><td style=text-align:left>使用Excel配置</td><td style=text-align:left>使用Excel配置</td></tr><tr><td style=text-align:left>代码读取方式</td><td style=text-align:left>将Excel文件中的内容转换成Csv文件</td><td style=text-align:left>将Excel文件中的内容转换成Json文件</td></tr><tr><td style=text-align:left>读取后存储位置</td><td style=text-align:left>在项目启动前，先读取Csv的内容到内存中，转成二进制文件写入Zookeeper，在项目启动时加载Zookeeper中的配置表信息到内存</td><td style=text-align:left>在项目加载时读取Json到内存中</td></tr><tr><td style=text-align:left>热更新方案</td><td style=text-align:left>修改Zookeeper中的二进制文件，通过Zookeeper发布订阅机制，分布式系统中各个系统从Zookeeper中读取新的配置表信息</td><td style=text-align:left>先修改Json文件，然后读取Json文件到内存中</td></tr><tr><td style=text-align:left>配置表检查</td><td style=text-align:left>在读取Csv到内存后，编写检查代码，检查内存对象之间的相关逻辑依赖</td><td style=text-align:left>无</td></tr></tbody></table><h2 id=大型slg手游>大型SLG手游<a hidden class=anchor aria-hidden=true href=#大型slg手游>#</a></h2><p>这是一个比较大型的SLG手游项目，使用了分布式的系统，服务器数量众多，因此需要一个统一的中心服务器来管理所有的配置信息。这个项目使用的是Zookeeper进行配置表的存储。</p><h3 id=策划配置方式>策划配置方式<a hidden class=anchor aria-hidden=true href=#策划配置方式>#</a></h3><p>策划使用Excel进行配置。每一列包含中文名、英文名、key类型(标记客户端、服务器或是客户端和服务器都用，且标记是否是key)、字段类型（数据data还是文字text）。</p><p>一张表最多只能有两个key，一个主key，一个副key。</p><p>比如，如果有一个可以领取宝箱的活动类型，活动可能有多个id，以满足不同的活动包装；每个活动都有多个宝箱。那么这张配置表的主key是活动id，副key是宝箱id。</p><h3 id=读取配置表>读取配置表<a hidden class=anchor aria-hidden=true href=#读取配置表>#</a></h3><p>首先将Excel文件中的内容转换成Csv文件，这一步会将客户端的配置列移除，仅保留服务器用到的配置列。然后使用Java代码读取Csv文件，将Csv文件中的数据构造成Java对象，然后再将Java对象序列化成二进制文件，上传到Zookeeper中的某个节点之下。</p><pre class=mermaid>graph LR
A[Excel文件]-->|Python转换|B[Csv文件]-->|Java代码读取|C[Zookeeper节点下]-->|服务器启动读取Zookeeper|D[服务器内存对象]
  </pre><p>服务器启动时会从Zookeeper的节点中加载配置表文件。</p><blockquote><p>在后续的开发过程中，发生过因为策划失误，修改了Excel后忘记生成Csv，而导致Excel文件与Csv文件不一致的情况。在这个项目中，Csv并不是读取配置表过程中最后的输出产物，仅仅是一个中间产物，所以内部也讨论过是否可以直接从Excel文件中读取到内存中的可能。</p></blockquote><h3 id=热更新方案>热更新方案<a hidden class=anchor aria-hidden=true href=#热更新方案>#</a></h3><p>当服务器启动读取完Zookeeper中的配置表后，订阅Zookeeper中配置表节点的变化事件。</p><p>当配置表Excel文件被修改后，依次执行读取流程到上传到Zookeeper节点，此时触发节点变化事件，Zookeeper会将变化事件发布给所有订阅此节点的服务器，服务器接收到配置表节点变化后，再次加载新的配置表文件信息。</p><h3 id=配置表检查>配置表检查<a hidden class=anchor aria-hidden=true href=#配置表检查>#</a></h3><p>当Csv读取到内存后，会对每一场表生成一个Java表管理对象，Java表管理对象与配置表一一对应。同时，这个Java表管理对象中，还可以进行多张配置表之间的逻辑校验。比如奖励表中的道具，必须在道具表中有配置，否则就会报错。</p><h2 id=小型mmo手游>小型MMO手游<a hidden class=anchor aria-hidden=true href=#小型mmo手游>#</a></h2><p>这是一个比较小的MMO手游，服务器进程数量比较少，配置表的数量也不多。因此它不需要使用类似Zookeeper那样的配置中心，只需要各个服务器进程读取相同内容的Json文件即可。</p><h3 id=策划配置方式-1>策划配置方式<a hidden class=anchor aria-hidden=true href=#策划配置方式-1>#</a></h3><p>策划使用Excel进行配置表的编辑。表头包含中文名，英文名，类型（数字，或者any任意结构）。
一张表必须要有数字id，且必须列在第一列中。其他的部分不做强制要求。</p><h3 id=读取配置表-1>读取配置表<a hidden class=anchor aria-hidden=true href=#读取配置表-1>#</a></h3><p>Excel文件会转换为Json文件。
在代码中，服务器会加载所有的Json文件。</p><p>程序员一般不需要针对某一张配置表单独编写解析代码。每一张表都有一个id，其他字段都默认读取为Golang的interface{}类型，每一张表都能读取成统一的格式，即：表名-id-其余各列数据。如果这张表是一张只有一个key的表，那么可以直接通过表名+id查找对应的数据。</p><p>但如果是不止一个key的表，那么可以在默认加载之后，再新开辟内存空间，使用自定义的结构进行存储。</p><h3 id=热更新方案-1>热更新方案<a hidden class=anchor aria-hidden=true href=#热更新方案-1>#</a></h3><p>策划修改配置表Excel文件后，转成Json文件，然后手动上传到服务器中。
通过RPC的方式，向网关服务器发送“重新读取配置表”消息，网关通知服务器集群中的所有服务器进程，重新读取Json文件到内存中，替换之前的配置表内存数据。</p><h3 id=配置表检查-1>配置表检查<a hidden class=anchor aria-hidden=true href=#配置表检查-1>#</a></h3><p>没有配置表提前检查，仅在使用配置的时候抛出err错误。</p><h2 id=优缺点>优缺点<a hidden class=anchor aria-hidden=true href=#优缺点>#</a></h2><table><thead><tr><th style=text-align:left>类型</th><th style=text-align:left>大型SLG手游</th><th style=text-align:left>小型MMO手游</th></tr></thead><tbody><tr><td style=text-align:left>优点</td><td style=text-align:left>(1)热更新方便，一次发布到Zk上之后，所有服务器都更新<br>(2)有配置表检查，在加载配置表时校验配置错误信息</td><td style=text-align:left>(1)所有表都有默认取值的方法，方便开发<br>(2)Excel转Json后，Json文件方便人类阅读</td></tr><tr><td style=text-align:left>缺点</td><td style=text-align:left>(1)Excel生成的Csv可读性差，维护性差，不如XML，Json带有自己的结构信息<br>(2)开发繁琐，需要为每一张表定义类，并且预测配置表的关联，有可能会因为过度关联导致自由度下降<br>(3)在这个项目中，一个Excel对应一张配置表，导致Excel表数量过多，难以分类维护</td><td style=text-align:left>(1)没有配置表校验，配错值只能等业务运行时抛出Error<br>(2)热更新时，需要到所有服务器手动上传配置表json文件，然后再RPC发送到服务器执行配置表json文件的重新读取。<br>(3)策划需要多维护一份Excel配置表生成客户端、服务器的不同Json的配置文件</td></tr></tbody></table><h1 id=配置表功能的一些思考>配置表功能的一些思考<a hidden class=anchor aria-hidden=true href=#配置表功能的一些思考>#</a></h1><p>接下来是在两个项目中，和不同类型的策划沟通，使用完全不同的编程语言和设计方式开发之中，自己进行的一部分思考。</p><h2 id=所有的值一定要灵活配置吗>所有的值一定要灵活配置吗？<a hidden class=anchor aria-hidden=true href=#所有的值一定要灵活配置吗>#</a></h2><p>在SLG游戏中，由于是一个Java项目，团队里开发过程中非常忌讳“魔法数字”，如果功能要求不会改变某个值，领导一般会要求大家在枚举类或者常量中新增这个功能专属的常量。这本身没有什么问题。但是有时候问题出在策划身上，策划设计的时候并不清楚某个值是否有改变的可能。为了规避这种可能，我们开发时几乎将所有的可变的值，都做成了配置表中读取全局变量。</p><p>这会带来一个问题：是否有些值是不存在改变的可能性的，或者说，改变可能很小？
比如，有一个活动是领取2个宝箱，而且UI设计的时候已经设计好了两个宝箱在游戏屏幕中摆放的位置，那么如果这个值交给策划配置，策划也不敢去修改这个值。那么这个值就属于“没有必要放权给策划配置的值”。</p><p>你可能会说，如果下次开活动，策划要配置3个宝箱，那还是要改代码，不是吗？没错，但是此时客户端，美术UI都要修改，到时候QA还是要统一测，这时候服务器一起跟进修改一个写死的魔法数字，对整条链路上的人都没有影响：策划还是要增加第三个宝箱的奖励配置、美术UI要设计三个宝箱在屏幕中的比例，QA还是要完整跑一遍活动。因此就算这个宝箱数量的值交给策划配置，也不会让这一切有什么优化，而更有可能的是，由于没有服务器开发的参与，策划配错了值，回过头来还是服务器这边查问题。</p><h2 id=配置表的key的约定>配置表的key的约定<a hidden class=anchor aria-hidden=true href=#配置表的key的约定>#</a></h2><p>我们还是以刚才的例子，一个活动可以配置多个宝箱，并且同时可以开启多个活动。有两个活动，id为1和2，每个活动会开3个宝箱，id为1,2和3。</p><h3 id=在slg项目中它的excel配置表如下>在SLG项目中，它的Excel配置表如下：<a hidden class=anchor aria-hidden=true href=#在slg项目中它的excel配置表如下>#</a></h3><table><thead><tr><th style=text-align:left>活动id</th><th style=text-align:left>宝箱id</th><th style=text-align:left>宝箱奖励</th></tr></thead><tbody><tr><td style=text-align:left>allmainkey</td><td style=text-align:left>allchildkey</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>2</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>3</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>1</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>2</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>3</td><td style=text-align:left>xxx</td></tr></tbody></table><p>在这里，<code>allmainkey</code>是指这张表的主key是活动id，<code>allchildkey</code>是指这张表的副key是宝箱id。并且必须要按照这种格式配置，才能导出正确的Csv文件，执行后续的操作。</p><blockquote><p>如果一张表需要三个key，则在目前的条件下，由于没有类似<code>allthirdkey</code>的约定，所以第三个key无法被标识。</p></blockquote><h3 id=在mmo项目中它的excel配置如下>在MMO项目中，它的Excel配置如下<a hidden class=anchor aria-hidden=true href=#在mmo项目中它的excel配置如下>#</a></h3><table><thead><tr><th style=text-align:left>id</th><th style=text-align:left>活动id</th><th style=text-align:left>宝箱id</th><th style=text-align:left>宝箱奖励</th></tr></thead><tbody><tr><td style=text-align:left>101</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>102</td><td style=text-align:left>1</td><td style=text-align:left>2</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>103</td><td style=text-align:left>1</td><td style=text-align:left>3</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>201</td><td style=text-align:left>2</td><td style=text-align:left>1</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>202</td><td style=text-align:left>2</td><td style=text-align:left>2</td><td style=text-align:left>xxx</td></tr><tr><td style=text-align:left>203</td><td style=text-align:left>2</td><td style=text-align:left>3</td><td style=text-align:left>xxx</td></tr></tbody></table><p>这张表在功能逻辑上，只有一个key: id。这个id的生成逻辑是: 活动id * 100 + 宝箱id。如此依赖，只要活动和宝箱没有重复，则id也不会有重复。并且也解决了上面的那个问题：如果需要三个key，则只需要往后加新的逻辑id列，然后对id的生成规则进行修改即可。</p><p>在SLG项目中，表的结构固定了只能拥有两个key，一主一从，导致大家不得不按照固定的写法去进行配置。但在MMO项目中，它更注重于逻辑上的设计，使用体验也更加灵活。</p><h2 id=配置表需要注释吗>配置表需要注释吗？<a hidden class=anchor aria-hidden=true href=#配置表需要注释吗>#</a></h2><p>先说结论：配置表需要注释，但是不应该写在配置表里。</p><p>在策划的工作过程中，策划不断修改配置表的值，以达到自己的设计目的。在此过程中，存在多次与程序商讨修改表结构/字段含义的过程。由于配置表并不直接完成功能，所以策划很难对配置值的使用方式有清楚的认知。在需求被修改、程序开发时提议修改优化、或是最后测试时遇到问题时，我们可能会急于完成功能而忽略策划表另一页的注释页，导致注释与实际效果不符合的情况。</p><p>我们终究是从代码层面来排查配置表的值是如何被使用的，因此我认为代码中的注释总体优于策划表的注释。</p><h2 id=配置表究竟由程序员设计还是由策划设计>配置表究竟由程序员设计，还是由策划设计？<a hidden class=anchor aria-hidden=true href=#配置表究竟由程序员设计还是由策划设计>#</a></h2><p>在大部分情况下，由策划设计。原因是功能设计者在设计的时候，对自己设计过程中的敏感数值有深刻的印象。因此配置表应该根据这些数值进行规划和设计。</p><p>但在部分情况下，如在之前的功能上进行所谓的优化，策划无法对旧有功能有全面认知的时候，容易出现新增重复功能的表、或是直接“复用”、“拓展”之前的表。有时这会让程序员感到莫名其妙。因此在这种情况下，程序员需要仔细倾听策划的需求，然后对旧有功能进行整理，商讨出新的解决方案。在这个过程中，可能是程序员进行策划表的设计。</p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>配置表是游戏开发中不可或缺的一部分，但是目前还找不到比Excel更方便的配置表管理编辑工具。策划可以用Excel做很多方便的计算，但是到了程序员这里，读取Excel之后的步骤，每一步都值得探讨。读取如何更高效、流程如何更健壮，更不容易出现人为的失误、热更如何更方便快捷、结构如何更简单易懂，易于维护。</p><p>我的经验如下：</p><ol><li>从Excel到内存中，最好只有一个中间产物。在SLG项目中，由于存在<code>Excel转Csv</code>和<code>Csv读取后转二进制文件</code>这两个步骤，导致每一次读取出错，都要排查Excel和Csv两个文件。、</li><li>热更新的功能，最好只有两个步骤：打包和上传。打包是指将Excel转成最后服务器可读取的文件，上传是指将生成的文件传入Zookeeper或者其他的配置中心，由配置中心通知服务器进行热更新操作。而不是由人工上传，人工执行热更新。</li><li>一张表只能有一个key，但是可以有多个逻辑上的id，这样可以保持一定的多key自由度，且可以通过唯一key找到某一行记录，方便客户端-服务器之间通信。</li><li>配置表不需要注释，只需要用简短清晰的词汇，对某一列的功能和使用场景表述清楚，但是程序代码中要对使用配置表的具体位置进行一些描述（当某些字段有特殊枚举含义/需要除以100转成小数之类）。、</li><li>配置表优先让策划进行设计，只有设计配置表的人，才知道功能的具体效果。（这个过程并不是要求一定要让策划把完整的策划表设计完，而是要求策划要尽可能全面的列出功能中所需要配置的字段。）如此一来，程序员才能对功能开发更有把握，可以从需要的字段中窥探策划的真实设计方向。</li></ol></div><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://windypath.com/posts/java_juc_briefly/><span class=title>下一页 »</span><br><span>Java并发编程中上锁的几种方式</span></a></nav></footer></article></main><footer class=footer><span>Windypath 风萧古道 <strong>For Chinese Software</strong>. <a href=https://beian.miit.gov.cn/>闽ICP备15016446号-3</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>