<!doctype html><html lang=zh dir=auto><head><style>:root{--sys-font-family:"Noto Serif SC";--zh-font-family:"Noto Serif SC";--base-font-family:"Noto Serif SC";--code-font-family:"Noto Serif SC";--article-font-family:"Noto Serif SC"}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CSAPP第二章-信息的表示与处理 | 风萧古道 - 勤学苦练，年复一年</title><meta name=keywords content="CSAPP"><meta name=description content="23年3月23日，我在公司进行了一次分享会，内容是本文的内容。在分享前，我重新对文章知识点进行了梳理，补充了很多细节。现将补充的细节重新编写到本文中。
什么是二进制数？ 我们日常使用的是十进制，数字包括0,1,2,3,4,5,6,7,8,9 再往下数，就得向前进一位，变成10，然后从个位数开始继续增加11,12,13…19 计算机最底层使用的是二进制，数字包括0和1，再往下数，也是前进一位，变成10。注意，这个10并不是十进制的十，而是十进制的二。 如何用二进制来表示一个整数？ 二进制 十进制（无符号） 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15 二进制如何表示负数？ 原码 我们把最高位(最左边的位)作为符号位，后面剩余的位代表的数作为数值具体的大小。 比如：四位原码二进制表示数字
— 3
1 011
开头的1代表负号，后面的011表示3。这样拼起来就是负3了 但是这么表示可能会有什么问题？
原码表示负数存在的问题 0000和1000，都是表示数字0，但是一个是正0，一个是负0。这显然不符合我们对零的理解。 无法进行加减运算：观察以下式子1(0001) + (-3(1011)) = -4(1100) 0001 +1011 -&mdash;&mdash;- 1100 那么如何用二进制表示一个数字，才能处理加减操作呢？
补码 以时钟为例，拨动时钟理解补码
把红色指针从指向“8”拨动到“6”， 有几种方式？ 有两种方式，如图所示： 以此图为例，如果指针目前指向8(红色指针)，要把它拨到6（绿色指针），有两种方式：
把8往逆时针方向旋转到6（蓝色）这种方式就是进行8-2=6 把8往顺时针方向旋转到6（黄色）这种方式是进行8+10=18，但是时钟只能显示12个数字，所以18-12=6 补码减法的逻辑是：通过加法，给数字加上一个超过表示上限的数，使其最高位“丢失”的方式来实现减法。"><meta name=author content="JohnathanLin"><link rel=canonical href=https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2215af6a28c52331bad04ae84f42d6ac21a53b6982f4d9347e9394a6b1089004.css integrity="sha256-IhWvaijFIzG60EroT0LWrCGlO2mC9Nk0fpOUprEIkAQ=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ",{anonymize_ip:!1})}</script><meta property="og:title" content="CSAPP第二章-信息的表示与处理"><meta property="og:description" content="23年3月23日，我在公司进行了一次分享会，内容是本文的内容。在分享前，我重新对文章知识点进行了梳理，补充了很多细节。现将补充的细节重新编写到本文中。
什么是二进制数？ 我们日常使用的是十进制，数字包括0,1,2,3,4,5,6,7,8,9 再往下数，就得向前进一位，变成10，然后从个位数开始继续增加11,12,13…19 计算机最底层使用的是二进制，数字包括0和1，再往下数，也是前进一位，变成10。注意，这个10并不是十进制的十，而是十进制的二。 如何用二进制来表示一个整数？ 二进制 十进制（无符号） 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15 二进制如何表示负数？ 原码 我们把最高位(最左边的位)作为符号位，后面剩余的位代表的数作为数值具体的大小。 比如：四位原码二进制表示数字
— 3
1 011
开头的1代表负号，后面的011表示3。这样拼起来就是负3了 但是这么表示可能会有什么问题？
原码表示负数存在的问题 0000和1000，都是表示数字0，但是一个是正0，一个是负0。这显然不符合我们对零的理解。 无法进行加减运算：观察以下式子1(0001) + (-3(1011)) = -4(1100) 0001 +1011 -&mdash;&mdash;- 1100 那么如何用二进制表示一个数字，才能处理加减操作呢？
补码 以时钟为例，拨动时钟理解补码
把红色指针从指向“8”拨动到“6”， 有几种方式？ 有两种方式，如图所示： 以此图为例，如果指针目前指向8(红色指针)，要把它拨到6（绿色指针），有两种方式：
把8往逆时针方向旋转到6（蓝色）这种方式就是进行8-2=6 把8往顺时针方向旋转到6（黄色）这种方式是进行8+10=18，但是时钟只能显示12个数字，所以18-12=6 补码减法的逻辑是：通过加法，给数字加上一个超过表示上限的数，使其最高位“丢失”的方式来实现减法。"><meta property="og:type" content="article"><meta property="og:url" content="https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-30T21:08:43+08:00"><meta property="article:modified_time" content="2023-04-30T21:08:43+08:00"><meta property="og:site_name" content="Windypath"><meta name=twitter:card content="summary"><meta name=twitter:title content="CSAPP第二章-信息的表示与处理"><meta name=twitter:description content="23年3月23日，我在公司进行了一次分享会，内容是本文的内容。在分享前，我重新对文章知识点进行了梳理，补充了很多细节。现将补充的细节重新编写到本文中。
什么是二进制数？ 我们日常使用的是十进制，数字包括0,1,2,3,4,5,6,7,8,9 再往下数，就得向前进一位，变成10，然后从个位数开始继续增加11,12,13…19 计算机最底层使用的是二进制，数字包括0和1，再往下数，也是前进一位，变成10。注意，这个10并不是十进制的十，而是十进制的二。 如何用二进制来表示一个整数？ 二进制 十进制（无符号） 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15 二进制如何表示负数？ 原码 我们把最高位(最左边的位)作为符号位，后面剩余的位代表的数作为数值具体的大小。 比如：四位原码二进制表示数字
— 3
1 011
开头的1代表负号，后面的011表示3。这样拼起来就是负3了 但是这么表示可能会有什么问题？
原码表示负数存在的问题 0000和1000，都是表示数字0，但是一个是正0，一个是负0。这显然不符合我们对零的理解。 无法进行加减运算：观察以下式子1(0001) + (-3(1011)) = -4(1100) 0001 +1011 -&mdash;&mdash;- 1100 那么如何用二进制表示一个数字，才能处理加减操作呢？
补码 以时钟为例，拨动时钟理解补码
把红色指针从指向“8”拨动到“6”， 有几种方式？ 有两种方式，如图所示： 以此图为例，如果指针目前指向8(红色指针)，要把它拨到6（绿色指针），有两种方式：
把8往逆时针方向旋转到6（蓝色）这种方式就是进行8-2=6 把8往顺时针方向旋转到6（黄色）这种方式是进行8+10=18，但是时钟只能显示12个数字，所以18-12=6 补码减法的逻辑是：通过加法，给数字加上一个超过表示上限的数，使其最高位“丢失”的方式来实现减法。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windypath.com/posts/"},{"@type":"ListItem","position":2,"name":"CSAPP第二章-信息的表示与处理","item":"https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CSAPP第二章-信息的表示与处理","name":"CSAPP第二章-信息的表示与处理","description":"23年3月23日，我在公司进行了一次分享会，内容是本文的内容。在分享前，我重新对文章知识点进行了梳理，补充了很多细节。现将补充的细节重新编写到本文中。\n什么是二进制数？ 我们日常使用的是十进制，数字包括0,1,2,3,4,5,6,7,8,9 再往下数，就得向前进一位，变成10，然后从个位数开始继续增加11,12,13…19 计算机最底层使用的是二进制，数字包括0和1，再往下数，也是前进一位，变成10。注意，这个10并不是十进制的十，而是十进制的二。 如何用二进制来表示一个整数？ 二进制 十进制（无符号） 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15 二进制如何表示负数？ 原码 我们把最高位(最左边的位)作为符号位，后面剩余的位代表的数作为数值具体的大小。 比如：四位原码二进制表示数字\n— 3\n1 011\n开头的1代表负号，后面的011表示3。这样拼起来就是负3了 但是这么表示可能会有什么问题？\n原码表示负数存在的问题 0000和1000，都是表示数字0，但是一个是正0，一个是负0。这显然不符合我们对零的理解。 无法进行加减运算：观察以下式子1(0001) + (-3(1011)) = -4(1100) 0001 +1011 -\u0026mdash;\u0026mdash;- 1100 那么如何用二进制表示一个数字，才能处理加减操作呢？\n补码 以时钟为例，拨动时钟理解补码\n把红色指针从指向“8”拨动到“6”， 有几种方式？ 有两种方式，如图所示： 以此图为例，如果指针目前指向8(红色指针)，要把它拨到6（绿色指针），有两种方式：\n把8往逆时针方向旋转到6（蓝色）这种方式就是进行8-2=6 把8往顺时针方向旋转到6（黄色）这种方式是进行8+10=18，但是时钟只能显示12个数字，所以18-12=6 补码减法的逻辑是：通过加法，给数字加上一个超过表示上限的数，使其最高位“丢失”的方式来实现减法。","keywords":["CSAPP"],"articleBody":" 23年3月23日，我在公司进行了一次分享会，内容是本文的内容。在分享前，我重新对文章知识点进行了梳理，补充了很多细节。现将补充的细节重新编写到本文中。\n什么是二进制数？ 我们日常使用的是十进制，数字包括0,1,2,3,4,5,6,7,8,9 再往下数，就得向前进一位，变成10，然后从个位数开始继续增加11,12,13…19 计算机最底层使用的是二进制，数字包括0和1，再往下数，也是前进一位，变成10。注意，这个10并不是十进制的十，而是十进制的二。 如何用二进制来表示一个整数？ 二进制 十进制（无符号） 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15 二进制如何表示负数？ 原码 我们把最高位(最左边的位)作为符号位，后面剩余的位代表的数作为数值具体的大小。 比如：四位原码二进制表示数字\n— 3\n1 011\n开头的1代表负号，后面的011表示3。这样拼起来就是负3了 但是这么表示可能会有什么问题？\n原码表示负数存在的问题 0000和1000，都是表示数字0，但是一个是正0，一个是负0。这显然不符合我们对零的理解。 无法进行加减运算：观察以下式子1(0001) + (-3(1011)) = -4(1100) 0001 +1011 -——- 1100 那么如何用二进制表示一个数字，才能处理加减操作呢？\n补码 以时钟为例，拨动时钟理解补码\n把红色指针从指向“8”拨动到“6”， 有几种方式？ 有两种方式，如图所示： 以此图为例，如果指针目前指向8(红色指针)，要把它拨到6（绿色指针），有两种方式：\n把8往逆时针方向旋转到6（蓝色）这种方式就是进行8-2=6 把8往顺时针方向旋转到6（黄色）这种方式是进行8+10=18，但是时钟只能显示12个数字，所以18-12=6 补码减法的逻辑是：通过加法，给数字加上一个超过表示上限的数，使其最高位“丢失”的方式来实现减法。\n如同我们调整时钟的时针，如果调整时针的转轴只能向顺时针方向调整，那么我们可以通过多转大半圈的方式来实现任意小时的调整。\n尝试用补码进行运算 考虑求解一个方程: 1 + x = 0\n0001\n+ x\n-——–\n0000\nX只能表示正数的话，那么这是一个无解的方程。 但是如果我们假设答案存在第五位的1，那么就可以进行运算\n0001\n+ x\n-——–\n10000\n计算结果 x = 1111。 由此，我们可以推断一件事：十进制的-1 ，可以用二进制的1111表示。\n让我们再做一题： 2 + x = -1 (十进制)\n0010\n+ x\n-——–\n1111\n对于二进制数，1111 \u003e 0010， 所以我们不需要假设有“第5位”的存在，直接运算得到x = 1101,而其十进制答案为-3。\n找到规律了吗？ 至此我们发现了以下4个数的十进制和二进制的表示：\n二进制 十进制 1111 -1 0001 1 1101 -3 0011 3 我们发现，对负数的二进制，取反，再加1，就能得到负数的数值。\n如-3的二进制数1101取反为0010, 0010再加1得到0011，0011是3。\n解决问题的关键是我们人为划定了二进制表示整数的范围仅有4位，对于更高的第5位自然舍弃。\n提问：在四位二进制下，所有数字的相反数都能被表示吗？\n答：不是的，二进制1000这个数字，在四位二进制时没有办法被表示。\n至此，我们可以总结得到四位二进制下表示十进制（无符号）和十进制（补码）的情况：\n二进制 十进制（无符号） 十进制（补码） 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 -8 1001 9 -7 1010 10 -6 1011 11 -5 1100 12 -4 1101 13 -3 1110 14 -2 1111 15 -1 补码表示的新理解 关于补码，为了计算某个正数的相反数，可以用过取反+1的方式计算得到负数的补码表示。但是还有另一种方式能够更好的理解补码。 如果用5位来表示一个数：\n下标 4 3 2 1 0 代表的十进制数 每个下标的数值 -16 8 4 2 1 二进制数1 0 1 1 0 1 13 二进制数2 1 1 1 0 1 -3 二进制数3 1 1 1 1 1 -1 二进制数3 0 1 1 1 1 15 可以看到其实如果按照补码的逻辑，当使用5个位来存储数字时，最高位第5位作为符号位，它的数值为-16，其他第1到4位的数值为1、2、4、8，然后再对二进制数的各个位，乘以其对应的数值，再累加，就能得到十进制数的大小。 比如二进制数1，其十进制数=0*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = 13。 而负数二进制2，其十进制数=1*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = -3。\n我们现在已经知道-3的二进制补码表示是：11101，很容易能通过这个数值表得到正3的二进制补码表示是00011。 使用上面的“取反后+1”的公式，也可以将-3转为正3：~11101 + 1 = 00010 + 1 = 00011\n另外，还有两个比较有意思的内容：\n想获得某个二进制补码表示的最小的数，只需要让其符号位为1，其他位为0即可。 比如在5位表示数的情况下，最小的数是-16，即10000。 想获取-1，只需要让所有位都为1即可，那么想获得-1，可以直接用0按位取反。 二进制数的加法和乘法 二进制数的加法 二进制的加法与十进制的计算规则是一样的，当某一位的数大于1时，往前进一位。 对于无符号二进制数和补码二进制数，将数的每一位进行加法运算。 在不溢出的情况下，考虑两个4位无符号二进制数的加法：4+6=10： 0100\n+0110\n-——–\n1010\n加法溢出 再考虑两个四位无符号二进制数的加法\n1000\n+1000\n-——–\n10000\n但是最高位的1要被舍去，得到的二进制结果是0000，所以计算机在经过运算后，得到的结果是0。\n二进制数的乘法 二进制的乘法与十进制数的乘法的计算规则是一样的。\n十进制乘法 12\nx 34\n-——–\n48\n36\n-——–\n408\n二进制乘法 0011\nx 0101\n-——–\n0011\n0011\n-——–\n001111\n发生溢出，开头的00被舍弃。\n二进制按位左移和右移 按位左移 按位左移运算符 ( «) 将其第一个操作数的位向左移动其第二个操作数中指定的位数。它还负责插入足够的零位以填充新位模式右边缘出现的间隙： 如图所示，100111 « 1, 按位左移后，在最右侧补0，得到1001110\n对于无符号二进制数，左移n位，可以视为其乘以2的n次方(不考虑溢出情况)\n左移后，最高位丢失 但是一个数的位数是有限的，比如之前我们在讨论补码的时候，认为规定了是四位二进制数。 按位左移会丢失那些超过左边界的位，如图： 在这个由8个位组成的二进制数中，左移1位后， 最左边的1丢失，在最右边补0。\n逻辑右移 逻辑右移，也称为无符号右移或零填充右移，移动整个二进制序列，包括符号位，并用零填充左边的结果间隙：\n算数右移 算数右移，有时称为有符号右移运算符，通过在向右移动位之前复制其符号位来保持数字的符号： 在右移一位后，左边的符号位被复制之后保留下来。原来是负数的数，现在依旧还是负数 对于补码二进制数，算数右移n位，视为除以2的n次方（整除）。如1100(-4) » 1 = 1110(-2)；1100 » 2 = 1111(-1) 按位移动位的数量，系统默认帮你取模 来源：https://www.jianshu.com/p/304bfdda6b6a 控制硬件时，常涉及打开/关闭特定的位或查看他们的状态，一般都会使用到按位运算符技术。\n一个面试题：\nint a = 1, b = 32; print(\"%d, %d\", a\u003c\u003cb, 1\u003c\u003c32); 答案是 1，0\na « b 的结果是1，是因为运行时会将操作数b对32取模，然后在进行移位操作。\n布尔代数 所谓布尔代数，就是按位与（\u0026），或（|），非（~），异或（^）。 需要注意和强调的是（应该已经强调无数遍了），\u0026和\u0026\u0026不一样，|和||不一样，~和负号-不一样。\n按位与 一假即假\n0 \u0026 0 = 0；1 \u0026 0 = 0；0 \u0026 1 = 0；1 \u0026 1 = 1。\n按位或 一真即真\n0 | 0 = 0；1 | 0 = 1；0 | 1 = 1；1 | 1 = 1。\n按位非 ~1 = 0；~0 = 1。\n按位异或 相同为假，不同为真\n0 ^ 0 = 0；1 ^ 0 = 1; 0 ^ 1 = 1; 1 ^ 1 = 0。\n比较有意思性质：\n异或有一个性质是：a ^ a = 0， (a ^ b) ^ a = b（因为0 ^ b = b） (x | -x) » 31 ，当x为0时依旧为0，当x不为0时，为-1 小端和大端字节序 简单记的话，就记一个数 0x12345678 存储地址从小到大依次从左到右（有语病，但意思是那个意思） 大端存的是12 34 56 78 小端存的是78 56 34 12\nC语言unsigned int，会导致问题 一般来说数组的长度是大于等于0的，所以在设计过程中，为了能多获得一位存储空间，有的人会设计使用unsigned int存储。在C语言有一个size_t类型，其定义就是long unsigned int 但在遍历过程中，有可能会出现肉眼难以察觉的bug。\n正常的代码：\nint a[5] = { 1, 2, 3, 4, 5 }; int cnt = 5; printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } int i; printf(\"start loop\\n\"); for (i = cnt -2;i \u003e= 0;i--) { printf(\"in loop,%u %u\\n\", i, cnt); a[i] += a[i+1]; } printf(\"end loop\\n\"); printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } 此段代码给出一个数组a，该数组有5个元素。然后进行的操作是从数组的后面往前累加，最终a数组的第一个元素是之前a数组各元素的总和。\n其运行结果如下：\nshow values a[0]=1 a[1]=2 a[2]=3 a[3]=4 a[4]=5 start loop in loop,3 5 in loop,2 5 in loop,1 5 in loop,0 5 end loop show values a[0]=15 a[1]=14 a[2]=12 a[3]=9 a[4]=5 如果我们把代码“int i”改成“size_t i”会如何呢？ 需要修改的错误代码：\nint a[5] = { 1, 2, 3, 4, 5 }; int cnt = 5; printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } size_t i; printf(\"start loop\\n\"); for (i = cnt -2;i \u003e= 0;i--) { printf(\"in loop,%u %u\\n\", i, cnt); a[i] += a[i+1]; } printf(\"end loop\\n\"); printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } 输出结果：\nshow values a[0]=1 a[1]=2 a[2]=3 a[3]=4 a[4]=5 start loop in loop,3 5 in loop,2 5 in loop,1 5 in loop,0 5 in loop,4294967295 5 in loop,4294967294 5 Segmentation fault (core dumped) 根据文章https://blog.csdn.net/wang93IT/article/details/72782379所说：\n有些时候我们在一段 C/C++ 代码的时候，由于对一个非法内存进行了操作，在程序运行的过程中，出现了“Segmentation fault (core dumped)”——段错误。\n可以看到当i为0的时候，i–操作使i变成了一个特别大的数字，然后取a[i]时没有找到了非法内存，于是报错。 解决办法就是不要用size_t，也就是不要用无符号类型去作为下标索引。但如果a数组本身非常大呢？因为sizeof()函数的返回值类型就是size_t。\n不要担心，在CSAPP课上，老教授给出了一种解决方案，虽然不是很符合正常逻辑： 修改后的正常代码：\nint a[5] = { 1, 2, 3, 4, 5 }; int cnt = 5; printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } size_t i; printf(\"start loop\\n\"); for (i = cnt -2;i \u003c cnt;i--) { printf(\"in loop,%u %u\\n\", i, cnt); a[i] += a[i+1]; } printf(\"end loop\\n\"); printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } 仔细对比可以发现，在第二个for循环for (i = cnt -2;i \u003c cnt;i--)中，其第二格判断条件从i \u003e= 0改成了i \u003c cnt。\n运行结果：\nshow values a[0]=1 a[1]=2 a[2]=3 a[3]=4 a[4]=5 start loop in loop,3 5 in loop,2 5 in loop,1 5 in loop,0 5 end loop show values a[0]=15 a[1]=14 a[2]=12 a[3]=9 a[4]=5 输出结果正常了。这是因为它借助了“无符号数减到（有符号数意义下的）负数时，会变成一个非常大的数”的性质。\n为什么无符号的0再减一个正数就会变成很大的数呢？ 以无符号0减去1为例： 假设有一个5位表示的数00000，如果这个数是二进制补码，则当00000减去1时，会得到11111。 11111在二进制补码中，指的是-1，但如果在无符号数中，它指的是UMax，也就是无符号数能表示的最大数。\n浮点数 浮点数，翻译自英文floating point，中文意思是漂浮不定的点。这里的“点”是“小数点”的意思。与浮点数相对应的是定点数。\n什么是定点数？ 定点数，也就是固定好小数点的位置，然后小数点前的位都用来表示整数部分，小数点后的位都用来表示小数部分。\n假设我们有1个字节，里面有8个二进制位：\n二进制位的数字 0 1 1 0 0 1 0 0 对应十进制的值 8 4 2 1 0.5 0.25 0.125 0.0625 现在，我用八位二进制表示了一个小数: 6.25\n十进制的科学计数法 浮点数表示小数的方式，使用了和十进制的科学计数法相似的思路，让我们先来复习一下十进制的科学计数法： 1234 -\u003e 1.234 * 103 87.65 -\u003e 8.765 * 101 -214.748 -\u003e -2.14748 * 102 0.00314 -\u003e 3.14 * 10-3\n可以看到通过乘以10的n次方，小数点被移动，可以被规范化的定义为：\na * 10b\nIEEE754规范下的浮点数 在IEEE754规范中，二进制小数也被定义为类似科学计数法的形式。 (-1)s * M * 2E\n其中：\ns是符号位，0为正数，1为负数 M是尾数，是一个二进制小数。在规格化的浮点数中，1\u003c=M\u003c2；在非规格化的浮点数中，0\u003c=M\u003c1。 E是阶码，是一个有符号整数 十进制与二进制对比 十进制 公式： a * 10b 要求：1≤|a|\u003c10，a不为分数形式，n为整数\n二进制 公式：(-1)s * M * 2E 要求： s 用来表示符号，0正1负 M 尾数，是二进制小数，规格化浮点数下，1 ≤ M \u003c2 E 阶码 是一个整数 二进制表示 将浮点数的位表示划分为三个字段，分别对这些值进行编码：\n一个单独的符号位s直接编码符号s n位的小数字段frac编码尾数M，但编码出来的值也依赖于解码字段的值是否等于0 k位的阶码字段exp编码阶码E 符号位s 公式：(-1)s * M * 2E\n当s为0时，此浮点数为正数；当s为1时，此浮点数为负数。\n因为M≥0，所以表示正负的特征就转移到s上。\n尾数M 在规格化浮点数下，1 ≤M\u003c2，即M是一个1.xxxxx(2)的数，其中xxxxx代表小数部分。\nIEEE754规定，在计算机内部保存M时，默认这个数的整数部分总是1，所以可以被舍去，只保留后面的xxxxx小数部分。\n比如当M=1.01(2)时，只需要保存01(2)，等到读取的时候再把1加上去。\n这么做是为了节省一个位的空间。\n尾数M具体怎么表示？ M在二进制中存储在frac区域，其读数方式，是假定在frac位部分前已经有一个固定的小数点。\n由此读出下图绿色部分，frac位部分的小数的数值。\n最后在计算M时，将1 +frac部分代表的小数。\n比如，当M = 1.75(10)时，frac部分为110000…..00(2)\nfrac为110000…00(2) ，计算 .110000..00(2) 的十进制值为0.75(10),再加上1，为1.75(10)\n二进制位 符号位s 阶码位exp Frac位 Frac位 Frac位 Frac位 对应十进制小数的值 …… …… 0.5 0.25 0.125 0.0625 阶码E 阶码E可能是正数、0和负数。\n在IEEE754规定，计算机内部保存E时，存储的区域exp是表示一个无符号二进制数。\n如果exp的位数为8位，那么exp能表示的十进制值在0-255之间。为了能表示负数，IEEE754规定，exp的值需要减去一个中间数。\n对于8位exp，这个中间数是127。\n阶码E具体怎么表示？ E在二进制中存在exp区域，其读数方式是将其作为一个无符号二进制数读出数值。\n之后再减去一个“中间数”，也叫偏置(bias)。\nBias = 2k-1 – 1 , 其中k是exp区域的位数。当k为8时，bias=127\nE = exp – bias\n比如，当E=10时，exp区域有8位，bias=127，则exp要存储的十进制数位137(10), 对应的无符号二进制数为10001001\n阶码E的几种情况 exp部分表示的位，在以下几种不同的情况，表示的数和计算方式略有不同。\nexp不全为0也不全为1时，浮点数采用之前的读数方式，减去bias得到E。（规格化的数） exp全为0时，这时候的计算E的公式变为E=1-bias，与此同时，计算M的公式也改为M=frac。这么做是为了表示0，和数值非常接近于0的数。（非规格化的数） exp全为1时，当frac部分全为0时，表示无穷大；当frac部分不全为0时，表示“不是一个数” 无穷大 IEEE754浮点数可以表示无穷大，当exp 的所有位全为1，frac的所有位全为0时即可表示无穷大。\n如果s为0则表示正无穷大，s为1为负无穷大。\n通常用于处理一些无法用实数表示的结果，比如 1/0 = 无穷大。\n不是一个数（NaN） 当exp 的所有位全为1，frac的所有位不全为0时表示“不是一个数”。用于表示一个无法表示的数，如“根号下的-1” 或者 “无穷 - 无穷”。\n为什么会有非规格化的数？ 规格化的数无法表示0\n浮点数公式：(-1)s * M * 2E\n其中， 1 ≤ M \u003c2，M不会等于0，因此IEEE754另外定义了非规格化的数，M=frac，使M的区间为0 ≤ M s\u003c 1。如此一来，M就可以等于0了。\n接着，在二进制补码中，我们做到了用00000…000来代表0。因此我们希望在s和exp都为0时，浮点数的00000…000也代表0\n因此，在IEEE754有两种计算浮点数的规则，非规格化和规格化。\n在这两种数中，规格化的最小数为，exp为00000001，E为-126，M为1.0，即 1.0 * 2-126\n在非规格化的数中，M的最大值为0.11111(2)。如果按照规格化的数来计算阶码E，那么exp为00000000，E为-127，这样得到的值为\n0.111…111* 2-127\n比较0.111…111* 2-127 和1.0 * 2-126 ，我们发现这两个数如果不看E，只看M的话，是非常接近的。如果非规格化的数的E是-126的话，在最大的非规格化数与最小的规格化数之间，可以实现比较平滑的过渡。因此，IEEE754规定非规格化数的E=1-bias\n关于浮点数，非常形象的一张图 浮点数有五部分：\n0 非规格化部分 规格化部分 无穷 不是一个正数（NaN） 图片来自《深入理解计算机系统》第三版第80页。\n举个例子计算浮点数 计算规格化的值 前提：当exp的位模式既不全为0，也不全为1时。（既不是0000….0000，也不是1111….1111） 此时：\n尾数M=1+frac 阶码E=exp-Bias 其中偏置Bias = 2k-1 - 1 ， 注意，这里的k是指exp阶码位的位数 如0.875在8位浮点数（s符号-1位 exp阶码位-4位 frac尾数位-3位）中，如下表可查二进制位表示为： 00110110\n以下是计算过程： 列出公式：\n(-1)s * M * 2E\n第一部分，符号位s 符号位直接从二进制中读取：\ns=0\n第二部分：尾数M 尾数计算公式：\n尾数M=1+frac\n其中需要计算frac的具体数值：\nfrac位=110。我们假设在110前方有一个二进制的小数点，那么frac为 .110\n1 1 0 0.5 0.25 0.125 frac 二进制.110=十进制0.5+0.25=0.75 M = 1 + frac = 1 + 0.75 = 1.75\n第三部分：阶码E 阶码计算公式：\nE=exp-Bias\nk = 4（因为exp阶码是4位）；\nBias = 2k-1 - 1 = 2 4-1 -1 = 8-1=7\nexp = 0110 = 6\nE = exp - Bias = 6 - 7 = -1\n进行计算 至此，对于公式\n(-1)s * M * 2E\n我们有：\ns = 0 M = 1.75 E = -1 代入计算，V = (-1)^0 * 1.75 * 2 ^(-1) = 1.75 * 0.5 = 1.75 / 2 = 0.875\n计算非规格化的值 前提：当exp的位模式全为0时 此时：\n尾数M=frac 阶码E=1-Bias 偏置Bias = 2^（k-1） - 1 如0.005859在8位浮点数（s符号-1位 exp阶码位-4位 frac尾数位-3位）中，如下表可查二进制位表示为：\n00000011\n以下是计算过程：\n列出公式：\n(-1)s * M * 2E\n第一部分，符号位s 符号位直接从二进制中读取： s=0\n第二部分：尾数M 在非规格化的值中，尾数计算公式： 尾数M=frac 需要计算frac的具体数值： frac位=011。我们假设在011前方有一个二进制的小数点，那么frac为 .011\n0 1 1 0.5 0.25 0.125 frac 二进制.110=十进制0.25+0.125=0.375\nM = frac = 0.375\n第三部分：阶码E 非规格化数中，exp部分为0。\n公式为：\n阶码E=1-Bias\nk = 4（因为exp阶码是4位）；\nBias = 2k-1 - 1 = 2 4-1 -1 = 8-1=7\n因此：\nE = 1-7 = -6\n进行计算\n至此，对于公式\n(-1)s * M * 2E 我们有：\ns = 0 M = 0.375 E = -6 代入计算，V = (-1)^0 * 0.375 * 2 ^(-6) =0.375 * 0.015625 = 0.005859375。\n浮点数的“舍入” 因为浮点数有精度限制，所以在运算中，需要进行一定的舍入，从而用有限的位来表示最接近目标实数的浮点数。 IEEE标准要求使用“向偶数舍入”，不是我们常说的四舍五入，而是四舍六入，五向偶数舍入。 四舍六入下： 1.4 -\u003e 1 1.6 -\u003e 2\n向偶数舍入下： 1.5 -\u003e 2 -1.5 -\u003e -2 因为1.5两边的数字是1和2，要向偶数舍入，所以取2；同理，-1.5两边的数字是-1和-2，向偶数舍入，取-2。 关于二进制向偶数舍入，书上描述为：\n图片来自《深入理解计算机系统》第三版第84页。\n之所以这么做，是因为如果全部向上舍入/向下舍入，会出现统计偏差。而向偶数/奇数舍入，则有50%的几率向上舍入，50%向下舍入，从而避免统计偏差。\n关于溢出 不管是二进制补码、无符号数或者浮点数，都会存在溢出的情况。而溢出这个行为本身，C语言不会给出任何警告。所以只能通过良好的编程习惯和思维去避免。\n溢出部分在计算机中会舍去。这带来了一些问题。比如加法和乘法，很有可能超过了Tmax或者Umax。\n关于除法 除法运算是十分消耗资源和时间的。计算机发展到现在，除法依旧需要消耗大量的CPU时钟。 但由于我们存储整数使用的是二进制补码/无符号数，所以如果我们的除数是2的幂，则可以通过位移来进行除法运算。\n当负数需要进行除2的幂的时候，需要加上偏移量，来保证舍入正确。\n","wordCount":"1244","inLanguage":"zh","datePublished":"2023-04-30T21:08:43+08:00","dateModified":"2023-04-30T21:08:43+08:00","author":{"@type":"Person","name":"JohnathanLin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/"},"publisher":{"@type":"Organization","name":"风萧古道 - 勤学苦练，年复一年","logo":{"@type":"ImageObject","url":"https://windypath.com/%3Clink%20/%20abs%20url%3E"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MLYM2PFRSJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MLYM2PFRSJ",{anonymize_ip:!1})}</script><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windypath.com/ accesskey=h title="风萧古道 (Alt + H)">风萧古道</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windypath.com/en/ title="Switch to English Page" aria-label="Switch to English Page">En</a></li></ul></div></div><ul id=menu><li><a href=https://windypath.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://windypath.com/categories/ title=分类><span>分类</span></a></li><li><a href=https://windypath.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://windypath.com/about/ title=关于><span>关于</span></a></li><li><a href=https://windypath.com/mybooks/ title=藏书><span>藏书</span></a></li><li><a href=https://windypath.com/myfriends/ title=朋友><span>朋友</span></a></li><li><a href=https://windypath.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>CSAPP第二章-信息的表示与处理</h1><div class=post-meta><span title='2023-04-30 21:08:43 +0800 +0800'>四月 30, 2023</span>&nbsp;·&nbsp;JohnathanLin</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0 aria-label=什么是二进制数？>什么是二进制数？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e7%94%a8%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%9d%a5%e8%a1%a8%e7%a4%ba%e4%b8%80%e4%b8%aa%e6%95%b4%e6%95%b0 aria-label=如何用二进制来表示一个整数？>如何用二进制来表示一个整数？</a></li><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%a6%82%e4%bd%95%e8%a1%a8%e7%a4%ba%e8%b4%9f%e6%95%b0 aria-label=二进制如何表示负数？>二进制如何表示负数？</a><ul><li><a href=#%e5%8e%9f%e7%a0%81 aria-label=原码>原码</a><ul><li><a href=#%e5%8e%9f%e7%a0%81%e8%a1%a8%e7%a4%ba%e8%b4%9f%e6%95%b0%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=原码表示负数存在的问题>原码表示负数存在的问题</a></li></ul></li><li><a href=#%e8%a1%a5%e7%a0%81 aria-label=补码>补码</a><ul><li><a href=#%e5%b0%9d%e8%af%95%e7%94%a8%e8%a1%a5%e7%a0%81%e8%bf%9b%e8%a1%8c%e8%bf%90%e7%ae%97 aria-label=尝试用补码进行运算>尝试用补码进行运算</a></li><li><a href=#%e6%89%be%e5%88%b0%e8%a7%84%e5%be%8b%e4%ba%86%e5%90%97 aria-label=找到规律了吗？>找到规律了吗？</a></li><li><a href=#%e8%a1%a5%e7%a0%81%e8%a1%a8%e7%a4%ba%e7%9a%84%e6%96%b0%e7%90%86%e8%a7%a3 aria-label=补码表示的新理解>补码表示的新理解</a></li></ul></li></ul></li><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0%e7%9a%84%e5%8a%a0%e6%b3%95%e5%92%8c%e4%b9%98%e6%b3%95 aria-label=二进制数的加法和乘法>二进制数的加法和乘法</a><ul><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0%e7%9a%84%e5%8a%a0%e6%b3%95 aria-label=二进制数的加法>二进制数的加法</a></li><li><a href=#%e5%8a%a0%e6%b3%95%e6%ba%a2%e5%87%ba aria-label=加法溢出>加法溢出</a></li><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0%e7%9a%84%e4%b9%98%e6%b3%95 aria-label=二进制数的乘法>二进制数的乘法</a><ul><li><a href=#%e5%8d%81%e8%bf%9b%e5%88%b6%e4%b9%98%e6%b3%95 aria-label=十进制乘法>十进制乘法</a></li><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%b9%98%e6%b3%95 aria-label=二进制乘法>二进制乘法</a></li></ul></li></ul></li><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%8c%89%e4%bd%8d%e5%b7%a6%e7%a7%bb%e5%92%8c%e5%8f%b3%e7%a7%bb aria-label=二进制按位左移和右移>二进制按位左移和右移</a><ul><li><a href=#%e6%8c%89%e4%bd%8d%e5%b7%a6%e7%a7%bb aria-label=按位左移>按位左移</a></li><li><a href=#%e5%b7%a6%e7%a7%bb%e5%90%8e%e6%9c%80%e9%ab%98%e4%bd%8d%e4%b8%a2%e5%a4%b1 aria-label=左移后，最高位丢失>左移后，最高位丢失</a></li><li><a href=#%e9%80%bb%e8%be%91%e5%8f%b3%e7%a7%bb aria-label=逻辑右移>逻辑右移</a></li><li><a href=#%e7%ae%97%e6%95%b0%e5%8f%b3%e7%a7%bb aria-label=算数右移>算数右移</a></li><li><a href=#%e6%8c%89%e4%bd%8d%e7%a7%bb%e5%8a%a8%e4%bd%8d%e7%9a%84%e6%95%b0%e9%87%8f%e7%b3%bb%e7%bb%9f%e9%bb%98%e8%ae%a4%e5%b8%ae%e4%bd%a0%e5%8f%96%e6%a8%a1 aria-label=按位移动位的数量，系统默认帮你取模>按位移动位的数量，系统默认帮你取模</a></li></ul></li><li><a href=#%e5%b8%83%e5%b0%94%e4%bb%a3%e6%95%b0 aria-label=布尔代数>布尔代数</a></li><li><a href=#%e5%b0%8f%e7%ab%af%e5%92%8c%e5%a4%a7%e7%ab%af%e5%ad%97%e8%8a%82%e5%ba%8f aria-label=小端和大端字节序>小端和大端字节序</a></li><li><a href=#c%e8%af%ad%e8%a8%80unsigned-int%e4%bc%9a%e5%af%bc%e8%87%b4%e9%97%ae%e9%a2%98 aria-label="C语言unsigned int，会导致问题">C语言unsigned int，会导致问题</a></li><li><a href=#%e6%b5%ae%e7%82%b9%e6%95%b0 aria-label=浮点数>浮点数</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%9a%e7%82%b9%e6%95%b0 aria-label=什么是定点数？>什么是定点数？</a></li><li><a href=#%e5%8d%81%e8%bf%9b%e5%88%b6%e7%9a%84%e7%a7%91%e5%ad%a6%e8%ae%a1%e6%95%b0%e6%b3%95 aria-label=十进制的科学计数法>十进制的科学计数法</a></li><li><a href=#ieee754%e8%a7%84%e8%8c%83%e4%b8%8b%e7%9a%84%e6%b5%ae%e7%82%b9%e6%95%b0 aria-label=IEEE754规范下的浮点数>IEEE754规范下的浮点数</a></li><li><a href=#%e5%8d%81%e8%bf%9b%e5%88%b6%e4%b8%8e%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%af%b9%e6%af%94 aria-label=十进制与二进制对比>十进制与二进制对比</a></li><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e8%a1%a8%e7%a4%ba aria-label=二进制表示>二进制表示</a></li><li><a href=#%e7%ac%a6%e5%8f%b7%e4%bd%8ds aria-label=符号位s>符号位s</a></li><li><a href=#%e5%b0%be%e6%95%b0m aria-label=尾数M>尾数M</a><ul><li><a href=#%e5%b0%be%e6%95%b0m%e5%85%b7%e4%bd%93%e6%80%8e%e4%b9%88%e8%a1%a8%e7%a4%ba aria-label=尾数M具体怎么表示？>尾数M具体怎么表示？</a></li></ul></li><li><a href=#%e9%98%b6%e7%a0%81e aria-label=阶码E>阶码E</a><ul><li><a href=#%e9%98%b6%e7%a0%81e%e5%85%b7%e4%bd%93%e6%80%8e%e4%b9%88%e8%a1%a8%e7%a4%ba aria-label=阶码E具体怎么表示？>阶码E具体怎么表示？</a></li><li><a href=#%e9%98%b6%e7%a0%81e%e7%9a%84%e5%87%a0%e7%a7%8d%e6%83%85%e5%86%b5 aria-label=阶码E的几种情况>阶码E的几种情况</a><ul><li><a href=#%e6%97%a0%e7%a9%b7%e5%a4%a7 aria-label=无穷大>无穷大</a></li><li><a href=#%e4%b8%8d%e6%98%af%e4%b8%80%e4%b8%aa%e6%95%b0nan aria-label=不是一个数（NaN）>不是一个数（NaN）</a></li></ul></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89%e9%9d%9e%e8%a7%84%e6%a0%bc%e5%8c%96%e7%9a%84%e6%95%b0 aria-label=为什么会有非规格化的数？>为什么会有非规格化的数？</a></li></ul></li><li><a href=#%e5%85%b3%e4%ba%8e%e6%b5%ae%e7%82%b9%e6%95%b0%e9%9d%9e%e5%b8%b8%e5%bd%a2%e8%b1%a1%e7%9a%84%e4%b8%80%e5%bc%a0%e5%9b%be aria-label=关于浮点数，非常形象的一张图>关于浮点数，非常形象的一张图</a></li><li><a href=#%e4%b8%be%e4%b8%aa%e4%be%8b%e5%ad%90%e8%ae%a1%e7%ae%97%e6%b5%ae%e7%82%b9%e6%95%b0 aria-label=举个例子计算浮点数>举个例子计算浮点数</a><ul><li><a href=#%e8%ae%a1%e7%ae%97%e8%a7%84%e6%a0%bc%e5%8c%96%e7%9a%84%e5%80%bc aria-label=计算规格化的值>计算规格化的值</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%e7%ac%a6%e5%8f%b7%e4%bd%8ds aria-label=第一部分，符号位s>第一部分，符号位s</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86%e5%b0%be%e6%95%b0m aria-label=第二部分：尾数M>第二部分：尾数M</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e9%83%a8%e5%88%86%e9%98%b6%e7%a0%81e aria-label=第三部分：阶码E>第三部分：阶码E</a></li><li><a href=#%e8%bf%9b%e8%a1%8c%e8%ae%a1%e7%ae%97 aria-label=进行计算>进行计算</a></li></ul></li></ul></li><li><a href=#%e8%ae%a1%e7%ae%97%e9%9d%9e%e8%a7%84%e6%a0%bc%e5%8c%96%e7%9a%84%e5%80%bc aria-label=计算非规格化的值>计算非规格化的值</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%e7%ac%a6%e5%8f%b7%e4%bd%8ds-1 aria-label=第一部分，符号位s>第一部分，符号位s</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86%e5%b0%be%e6%95%b0m-1 aria-label=第二部分：尾数M>第二部分：尾数M</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e9%83%a8%e5%88%86%e9%98%b6%e7%a0%81e-1 aria-label=第三部分：阶码E>第三部分：阶码E</a></li></ul></li><li><a href=#%e6%b5%ae%e7%82%b9%e6%95%b0%e7%9a%84%e8%88%8d%e5%85%a5 aria-label=浮点数的“舍入”>浮点数的“舍入”</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e6%ba%a2%e5%87%ba aria-label=关于溢出>关于溢出</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e9%99%a4%e6%b3%95 aria-label=关于除法>关于除法</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>23年3月23日，我在公司进行了一次分享会，内容是本文的内容。在分享前，我重新对文章知识点进行了梳理，补充了很多细节。现将补充的细节重新编写到本文中。</p></blockquote><h1 id=什么是二进制数>什么是二进制数？<a hidden class=anchor aria-hidden=true href=#什么是二进制数>#</a></h1><ul><li>我们日常使用的是十进制，数字包括0,1,2,3,4,5,6,7,8,9 再往下数，就得向前进一位，变成10，然后从个位数开始继续增加11,12,13…19</li><li>计算机最底层使用的是二进制，数字包括0和1，再往下数，也是前进一位，变成10。注意，这个10并不是十进制的十，而是十进制的二。</li></ul><h1 id=如何用二进制来表示一个整数>如何用二进制来表示一个整数？<a hidden class=anchor aria-hidden=true href=#如何用二进制来表示一个整数>#</a></h1><table><thead><tr><th style=text-align:left>二进制</th><th style=text-align:left>十进制（无符号）</th></tr></thead><tbody><tr><td style=text-align:left>0000</td><td style=text-align:left>0</td></tr><tr><td style=text-align:left>0001</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left>0010</td><td style=text-align:left>2</td></tr><tr><td style=text-align:left>0011</td><td style=text-align:left>3</td></tr><tr><td style=text-align:left>0100</td><td style=text-align:left>4</td></tr><tr><td style=text-align:left>0101</td><td style=text-align:left>5</td></tr><tr><td style=text-align:left>0110</td><td style=text-align:left>6</td></tr><tr><td style=text-align:left>0111</td><td style=text-align:left>7</td></tr><tr><td style=text-align:left>1000</td><td style=text-align:left>8</td></tr><tr><td style=text-align:left>1001</td><td style=text-align:left>9</td></tr><tr><td style=text-align:left>1010</td><td style=text-align:left>10</td></tr><tr><td style=text-align:left>1011</td><td style=text-align:left>11</td></tr><tr><td style=text-align:left>1100</td><td style=text-align:left>12</td></tr><tr><td style=text-align:left>1101</td><td style=text-align:left>13</td></tr><tr><td style=text-align:left>1110</td><td style=text-align:left>14</td></tr><tr><td style=text-align:left>1111</td><td style=text-align:left>15</td></tr></tbody></table><h1 id=二进制如何表示负数>二进制如何表示负数？<a hidden class=anchor aria-hidden=true href=#二进制如何表示负数>#</a></h1><h2 id=原码>原码<a hidden class=anchor aria-hidden=true href=#原码>#</a></h2><p>我们把最高位(最左边的位)作为符号位，后面剩余的位代表的数作为数值具体的大小。
比如：四位原码二进制表示数字</p><p><span style=color:red>—</span> 3</p><p><span style=color:red>1</span> 011</p><p>开头的1代表负号，后面的011表示3。这样拼起来就是负3了
但是这么表示可能会有什么问题？</p><h3 id=原码表示负数存在的问题>原码表示负数存在的问题<a hidden class=anchor aria-hidden=true href=#原码表示负数存在的问题>#</a></h3><ol><li>0000和1000，都是表示数字0，但是一个是正0，一个是负0。这显然不符合我们对零的理解。</li><li>无法进行加减运算：观察以下式子1(0001) + (-3(1011)) = -4(1100)
  0001
+1011
-&mdash;&mdash;-
  1100</li></ol><p>那么如何用二进制表示一个数字，才能处理加减操作呢？</p><h2 id=补码>补码<a hidden class=anchor aria-hidden=true href=#补码>#</a></h2><p>以时钟为例，拨动时钟理解补码</p><p>把红色指针从指向“8”拨动到“6”，
有几种方式？
<img loading=lazy src=/images/csapp_chapter2_clock1.png alt>
有两种方式，如图所示：
<img loading=lazy src=/images/csapp_chapter2_clock2.png alt>
以此图为例，如果指针目前指向8(红色指针)，要把它拨到6（绿色指针），有两种方式：</p><ol><li>把8往逆时针方向旋转到6（蓝色）这种方式就是进行8-2=6</li><li>把8往顺时针方向旋转到6（黄色）这种方式是进行8+10=18，但是时钟只能显示12个数字，所以18-12=6</li></ol><p>补码减法的逻辑是：<strong>通过加法，给数字加上一个超过表示上限的数，使其最高位“丢失”的方式来实现减法。</strong></p><p>如同我们调整时钟的时针，如果调整时针的转轴只能向顺时针方向调整，那么我们可以通过多转大半圈的方式来实现任意小时的调整。</p><h3 id=尝试用补码进行运算>尝试用补码进行运算<a hidden class=anchor aria-hidden=true href=#尝试用补码进行运算>#</a></h3><p>考虑求解一个方程: 1 + x = 0</p><p>  0001</p><p>+      x</p><p>-&mdash;&mdash;&ndash;</p><p>  0000</p><p>X只能表示正数的话，那么这是一个无解的方程。
但是如果我们假设答案存在第五位的1，那么就可以进行运算</p><p>  0001</p><p>+      x</p><p>-&mdash;&mdash;&ndash;</p><p><span style=color:blue>1</span>0000</p><p>计算结果 x = 1111。
由此，我们可以推断一件事：<strong>十进制的-1 ，可以用二进制的1111表示。</strong></p><p>让我们再做一题：
2 + x = -1 (十进制)</p><p>  0010</p><p>+      x</p><p>-&mdash;&mdash;&ndash;</p><p>  1111</p><p>对于二进制数，1111 > 0010，
所以我们不需要假设有“第5位”的存在，直接运算得到x = 1101,而其十进制答案为-3。</p><h3 id=找到规律了吗>找到规律了吗？<a hidden class=anchor aria-hidden=true href=#找到规律了吗>#</a></h3><p>至此我们发现了以下4个数的十进制和二进制的表示：</p><table><thead><tr><th style=text-align:left>二进制</th><th style=text-align:left>十进制</th></tr></thead><tbody><tr><td style=text-align:left>1111</td><td style=text-align:left>-1</td></tr><tr><td style=text-align:left>0001</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left>1101</td><td style=text-align:left>-3</td></tr><tr><td style=text-align:left>0011</td><td style=text-align:left>3</td></tr></tbody></table><p>我们发现，<strong>对负数的二进制，取反，再加1，就能得到负数的数值。</strong></p><p>如-3的二进制数1101取反为0010, 0010再加1得到0011，0011是3。</p><p>解决问题的关键是我们人为划定了二进制表示整数的范围仅有4位，对于更高的第5位自然舍弃。</p><blockquote><p>提问：在四位二进制下，所有数字的相反数都能被表示吗？</p><p>答：不是的，二进制1000这个数字，在四位二进制时没有办法被表示。</p></blockquote><p>至此，我们可以总结得到四位二进制下表示十进制（无符号）和十进制（补码）的情况：</p><table><thead><tr><th style=text-align:left>二进制</th><th style=text-align:left>十进制（无符号）</th><th style=text-align:left>十进制（补码）</th></tr></thead><tbody><tr><td style=text-align:left>0000</td><td style=text-align:left>0</td><td style=text-align:left>0</td></tr><tr><td style=text-align:left>0001</td><td style=text-align:left>1</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left>0010</td><td style=text-align:left>2</td><td style=text-align:left>2</td></tr><tr><td style=text-align:left>0011</td><td style=text-align:left>3</td><td style=text-align:left>3</td></tr><tr><td style=text-align:left>0100</td><td style=text-align:left>4</td><td style=text-align:left>4</td></tr><tr><td style=text-align:left>0101</td><td style=text-align:left>5</td><td style=text-align:left>5</td></tr><tr><td style=text-align:left>0110</td><td style=text-align:left>6</td><td style=text-align:left>6</td></tr><tr><td style=text-align:left>0111</td><td style=text-align:left>7</td><td style=text-align:left>7</td></tr><tr><td style=text-align:left>1000</td><td style=text-align:left>8</td><td style=text-align:left>-8</td></tr><tr><td style=text-align:left>1001</td><td style=text-align:left>9</td><td style=text-align:left>-7</td></tr><tr><td style=text-align:left>1010</td><td style=text-align:left>10</td><td style=text-align:left>-6</td></tr><tr><td style=text-align:left>1011</td><td style=text-align:left>11</td><td style=text-align:left>-5</td></tr><tr><td style=text-align:left>1100</td><td style=text-align:left>12</td><td style=text-align:left>-4</td></tr><tr><td style=text-align:left>1101</td><td style=text-align:left>13</td><td style=text-align:left>-3</td></tr><tr><td style=text-align:left>1110</td><td style=text-align:left>14</td><td style=text-align:left>-2</td></tr><tr><td style=text-align:left>1111</td><td style=text-align:left>15</td><td style=text-align:left>-1</td></tr></tbody></table><h3 id=补码表示的新理解>补码表示的新理解<a hidden class=anchor aria-hidden=true href=#补码表示的新理解>#</a></h3><p>关于补码，为了计算某个正数的相反数，可以用过取反+1的方式计算得到负数的补码表示。但是还有另一种方式能够更好的理解补码。
如果用5位来表示一个数：</p><table><thead><tr><th style=text-align:left>下标</th><th style=text-align:left>4</th><th style=text-align:left>3</th><th style=text-align:left>2</th><th style=text-align:left>1</th><th style=text-align:left>0</th><th style=text-align:left>代表的十进制数</th></tr></thead><tbody><tr><td style=text-align:left>每个下标的数值</td><td style=text-align:left>-16</td><td style=text-align:left>8</td><td style=text-align:left>4</td><td style=text-align:left>2</td><td style=text-align:left>1</td><td></td></tr><tr><td style=text-align:left>二进制数1</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>13</td></tr><tr><td style=text-align:left>二进制数2</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>-3</td></tr><tr><td style=text-align:left>二进制数3</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>-1</td></tr><tr><td style=text-align:left>二进制数3</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>15</td></tr></tbody></table><p>可以看到其实如果按照补码的逻辑，当使用5个位来存储数字时，最高位第5位作为符号位，它的数值为-16，其他第1到4位的数值为1、2、4、8，然后再对二进制数的各个位，乘以其对应的数值，再累加，就能得到十进制数的大小。
比如二进制数1，其十进制数=0*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = 13。
而负数二进制2，其十进制数=1*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = -3。</p><p>我们现在已经知道-3的二进制补码表示是：11101，很容易能通过这个数值表得到正3的二进制补码表示是00011。
使用上面的“取反后+1”的公式，也可以将-3转为正3：~11101 + 1 = 00010 + 1 = 00011</p><p>另外，还有两个比较有意思的内容：</p><ol><li>想获得某个二进制补码表示的最小的数，只需要让其符号位为1，其他位为0即可。
比如在5位表示数的情况下，最小的数是-16，即10000。</li><li>想获取-1，只需要让所有位都为1即可，那么想获得-1，可以直接用0按位取反。</li></ol><h1 id=二进制数的加法和乘法>二进制数的加法和乘法<a hidden class=anchor aria-hidden=true href=#二进制数的加法和乘法>#</a></h1><h2 id=二进制数的加法>二进制数的加法<a hidden class=anchor aria-hidden=true href=#二进制数的加法>#</a></h2><ul><li>二进制的加法与十进制的计算规则是一样的，当某一位的数大于1时，往前进一位。</li><li>对于无符号二进制数和补码二进制数，将数的每一位进行加法运算。</li><li>在不溢出的情况下，考虑两个4位无符号二进制数的加法：4+6=10：</li></ul><p>  0100</p><p>+0110</p><p>-&mdash;&mdash;&ndash;</p><p>  1010</p><h2 id=加法溢出>加法溢出<a hidden class=anchor aria-hidden=true href=#加法溢出>#</a></h2><p>再考虑两个四位无符号二进制数的加法</p><p>  1000</p><p>+1000</p><p>-&mdash;&mdash;&ndash;</p><p> 10000</p><p>但是最高位的1要被舍去，得到的二进制结果是0000，所以计算机在经过运算后，得到的结果是0。</p><h2 id=二进制数的乘法>二进制数的乘法<a hidden class=anchor aria-hidden=true href=#二进制数的乘法>#</a></h2><p>二进制的乘法与十进制数的乘法的计算规则是一样的。</p><h3 id=十进制乘法>十进制乘法<a hidden class=anchor aria-hidden=true href=#十进制乘法>#</a></h3><p>  12</p><p>x 34</p><p>-&mdash;&mdash;&ndash;</p><p>  48</p><p>36</p><p>-&mdash;&mdash;&ndash;</p><p> 408</p><h3 id=二进制乘法>二进制乘法<a hidden class=anchor aria-hidden=true href=#二进制乘法>#</a></h3><p>   0011</p><p>x 0101</p><p>-&mdash;&mdash;&ndash;</p><p>   0011</p><p>0011</p><p>-&mdash;&mdash;&ndash;</p><p> 001111</p><p>发生溢出，开头的00被舍弃。</p><h1 id=二进制按位左移和右移>二进制按位左移和右移<a hidden class=anchor aria-hidden=true href=#二进制按位左移和右移>#</a></h1><h2 id=按位左移>按位左移<a hidden class=anchor aria-hidden=true href=#按位左移>#</a></h2><p>按位左移运算符 ( &#171;) 将其第一个操作数的位向左移动其第二个操作数中指定的位数。它还负责插入足够的零位以填充新位模式右边缘出现的间隙：
<img loading=lazy src=/images/csapp_lshift.gif alt>
如图所示，100111 &#171; 1, 按位左移后，在最右侧补0，得到1001110</p><p>对于无符号二进制数，左移n位，可以视为其乘以2的n次方(不考虑溢出情况)</p><h2 id=左移后最高位丢失>左移后，最高位丢失<a hidden class=anchor aria-hidden=true href=#左移后最高位丢失>#</a></h2><p>但是一个数的位数是有限的，比如之前我们在讨论补码的时候，认为规定了是四位二进制数。
按位左移会丢失那些超过左边界的位，如图：
<img loading=lazy src=/images/csapp_lshift_masked.gif alt></p><p>在这个由8个位组成的二进制数中，左移1位后，
最左边的1丢失，在最右边补0。</p><h2 id=逻辑右移>逻辑右移<a hidden class=anchor aria-hidden=true href=#逻辑右移>#</a></h2><p>逻辑右移，也称为无符号右移或零填充右移，移动整个二进制序列，包括符号位，并用零填充左边的结果间隙：</p><p><img loading=lazy src=/images/csapp_rshift_logical.gif alt></p><h2 id=算数右移>算数右移<a hidden class=anchor aria-hidden=true href=#算数右移>#</a></h2><p>算数右移，有时称为有符号右移运算符，通过在向右移动位之前复制其符号位来保持数字的符号：
<img loading=lazy src=/images/csapp_rshift_arithmetic.gif alt></p><ul><li>在右移一位后，左边的符号位被复制之后保留下来。原来是负数的数，现在依旧还是负数</li><li>对于补码二进制数，算数右移n位，视为除以2的n次方（整除）。如1100(-4) &#187; 1 = 1110(-2)；1100 &#187; 2 = 1111(-1)</li></ul><h2 id=按位移动位的数量系统默认帮你取模>按位移动位的数量，系统默认帮你取模<a hidden class=anchor aria-hidden=true href=#按位移动位的数量系统默认帮你取模>#</a></h2><p>来源：<a href=https://www.jianshu.com/p/304bfdda6b6a>https://www.jianshu.com/p/304bfdda6b6a</a>
控制硬件时，常涉及打开/关闭特定的位或查看他们的状态，一般都会使用到按位运算符技术。</p><p>一个面试题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;%d, %d&#34;</span>, a<span style=color:#f92672>&lt;&lt;</span>b, <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>32</span>);
</span></span></code></pre></div><p>答案是 1，0</p><p>a &#171; b 的结果是1，是因为运行时会将操作数b对32取模，然后在进行移位操作。</p><h1 id=布尔代数>布尔代数<a hidden class=anchor aria-hidden=true href=#布尔代数>#</a></h1><p>所谓布尔代数，就是按位与（&），或（|），非（~），异或（^）。
需要注意和强调的是（应该已经强调无数遍了），&和&&不一样，|和||不一样，~和负号-不一样。</p><ul><li>按位与</li></ul><p>一假即假</p><p>0 & 0 = 0；1 & 0 = 0；0 & 1 = 0；1 & 1 = 1。</p><ul><li>按位或</li></ul><p>一真即真</p><p>0 | 0 = 0；1 | 0 = 1；0 | 1 = 1；1 | 1 = 1。</p><ul><li>按位非</li></ul><p>~1 = 0；~0 = 1。</p><ul><li>按位异或</li></ul><p>相同为假，不同为真</p><p>0 ^ 0 = 0；1 ^ 0 = 1; 0 ^ 1 = 1; 1 ^ 1 = 0。</p><p>比较有意思性质：</p><ol><li>异或有一个性质是：a ^ a = 0， (a ^ b) ^ a = b（因为0 ^ b = b）</li><li>(x | -x) &#187; 31 ，当x为0时依旧为0，当x不为0时，为-1</li></ol><h1 id=小端和大端字节序>小端和大端字节序<a hidden class=anchor aria-hidden=true href=#小端和大端字节序>#</a></h1><p>简单记的话，就记一个数 0x12345678
存储地址从小到大依次从左到右（有语病，但意思是那个意思）
大端存的是12 34 56 78
小端存的是78 56 34 12</p><h1 id=c语言unsigned-int会导致问题>C语言unsigned int，会导致问题<a hidden class=anchor aria-hidden=true href=#c语言unsigned-int会导致问题>#</a></h1><p>一般来说数组的长度是大于等于0的，所以在设计过程中，为了能多获得一位存储空间，有的人会设计使用unsigned int存储。在C语言有一个size_t类型，其定义就是long unsigned int
但在遍历过程中，有可能会出现肉眼难以察觉的bug。</p><p>正常的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;start loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> cnt <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>;i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>;i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;in loop,%u %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, cnt);
</span></span><span style=display:flex><span>        a[i] <span style=color:#f92672>+=</span> a[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;end loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>此段代码给出一个数组a，该数组有5个元素。然后进行的操作是从数组的后面往前累加，最终a数组的第一个元素是之前a数组各元素的总和。</p><p>其运行结果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>start loop
</span></span><span style=display:flex><span>in loop,3 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,2 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,1 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,0 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>end loop
</span></span><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span></code></pre></div><p>如果我们把代码“int i”改成“size_t i”会如何呢？
需要修改的错误代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> i;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;start loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> cnt <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>;i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>;i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;in loop,%u %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, cnt);
</span></span><span style=display:flex><span>        a[i] <span style=color:#f92672>+=</span> a[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;end loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>输出结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>start loop
</span></span><span style=display:flex><span>in loop,3 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,2 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,1 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,0 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,4294967295 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,4294967294 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>Segmentation fault <span style=color:#f92672>(</span>core dumped<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>根据文章<a href=https://blog.csdn.net/wang93IT/article/details/72782379>https://blog.csdn.net/wang93IT/article/details/72782379</a>所说：</p><blockquote><p>有些时候我们在一段 C/C++ 代码的时候，由于对一个非法内存进行了操作，在程序运行的过程中，出现了“Segmentation fault (core dumped)”——段错误。</p></blockquote><p>可以看到当i为0的时候，i&ndash;操作使i变成了一个特别大的数字，然后取a[i]时没有找到了非法内存，于是报错。
解决办法就是不要用size_t，也就是不要用无符号类型去作为下标索引。但如果a数组本身非常大呢？因为sizeof()函数的返回值类型就是size_t。</p><p>不要担心，在CSAPP课上，老教授给出了一种解决方案，虽然不是很符合正常逻辑：
修改后的正常代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> i;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;start loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> cnt <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>;i <span style=color:#f92672>&lt;</span> cnt;i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;in loop,%u %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, cnt);
</span></span><span style=display:flex><span>        a[i] <span style=color:#f92672>+=</span> a[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;end loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>仔细对比可以发现，在第二个for循环<code>for (i = cnt -2;i &lt; cnt;i--)</code>中，其第二格判断条件从<code>i >= 0</code>改成了<code>i &lt; cnt</code>。</p><p>运行结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>start loop
</span></span><span style=display:flex><span>in loop,3 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,2 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,1 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,0 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>end loop
</span></span><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span></code></pre></div><p>输出结果正常了。这是因为它借助了“无符号数减到（有符号数意义下的）负数时，会变成一个非常大的数”的性质。</p><p>为什么无符号的0再减一个正数就会变成很大的数呢？
以无符号0减去1为例：
假设有一个5位表示的数00000，如果这个数是二进制补码，则当00000减去1时，会得到11111。
11111在二进制补码中，指的是-1，但如果在无符号数中，它指的是UMax，也就是无符号数能表示的最大数。</p><h1 id=浮点数>浮点数<a hidden class=anchor aria-hidden=true href=#浮点数>#</a></h1><p>浮点数，翻译自英文floating point，中文意思是漂浮不定的点。这里的“点”是“小数点”的意思。与浮点数相对应的是定点数。</p><h2 id=什么是定点数>什么是定点数？<a hidden class=anchor aria-hidden=true href=#什么是定点数>#</a></h2><p>定点数，也就是固定好小数点的位置，然后小数点前的位都用来表示整数部分，小数点后的位都用来表示小数部分。</p><p>假设我们有1个字节，里面有8个二进制位：</p><table><thead><tr><th style=text-align:left>二进制位的数字</th><th style=text-align:left>0</th><th style=text-align:left>1</th><th style=text-align:left>1</th><th style=text-align:left>0</th><th style=text-align:left>0</th><th style=text-align:left>1</th><th style=text-align:left>0</th><th style=text-align:left>0</th><th></th></tr></thead><tbody><tr><td style=text-align:left>对应十进制的值</td><td style=text-align:left>8</td><td style=text-align:left>4</td><td style=text-align:left>2</td><td style=text-align:left>1</td><td style=text-align:left>0.5</td><td style=text-align:left>0.25</td><td style=text-align:left>0.125</td><td style=text-align:left>0.0625</td><td></td></tr></tbody></table><p>现在，我用八位二进制表示了一个小数: 6.25</p><h2 id=十进制的科学计数法>十进制的科学计数法<a hidden class=anchor aria-hidden=true href=#十进制的科学计数法>#</a></h2><p>浮点数表示小数的方式，使用了和十进制的科学计数法相似的思路，让我们先来复习一下十进制的科学计数法：
1234 -> 1.234 * 10<sup>3</sup>
87.65 -> 8.765 * 10<sup>1</sup>
-214.748 -> -2.14748 * 10<sup>2</sup>
0.00314 -> 3.14 * 10<sup>-3</sup></p><p>可以看到通过乘以10的n次方，小数点被移动，可以被规范化的定义为：</p><p>a * 10<sup>b</sup></p><h2 id=ieee754规范下的浮点数>IEEE754规范下的浮点数<a hidden class=anchor aria-hidden=true href=#ieee754规范下的浮点数>#</a></h2><p>在IEEE754规范中，二进制小数也被定义为类似科学计数法的形式。
(-1)<sup>s</sup> * M * 2<sup>E</sup></p><p>其中：</p><ul><li>s是符号位，0为正数，1为负数</li><li>M是尾数，是一个二进制小数。在规格化的浮点数中，1&lt;=M&lt;2；在非规格化的浮点数中，0&lt;=M&lt;1。</li><li>E是阶码，是一个有符号整数</li></ul><h2 id=十进制与二进制对比>十进制与二进制对比<a hidden class=anchor aria-hidden=true href=#十进制与二进制对比>#</a></h2><ul><li>十进制</li></ul><p>公式： a * 10<sup>b</sup>
要求：1≤|a|&lt;10，a不为分数形式，n为整数</p><ul><li>二进制
公式：(-1)<sup>s</sup> * M * 2<sup>E</sup>
要求：<ul><li>s 用来表示符号，0正1负</li><li>M 尾数，是二进制小数，规格化浮点数下，1 ≤ M &lt;2</li><li>E 阶码 是一个整数</li></ul></li></ul><h2 id=二进制表示>二进制表示<a hidden class=anchor aria-hidden=true href=#二进制表示>#</a></h2><p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p><ul><li>一个单独的符号位s直接编码符号s</li><li>n位的小数字段frac编码尾数M，但编码出来的值也依赖于解码字段的值是否等于0</li><li>k位的阶码字段exp编码阶码E</li></ul><p><img loading=lazy src=/images/csapp_float_bit.png alt></p><h2 id=符号位s>符号位s<a hidden class=anchor aria-hidden=true href=#符号位s>#</a></h2><p>公式：(-1)<sup>s</sup> * M * 2<sup>E</sup></p><p>当s为0时，此浮点数为正数；当s为1时，此浮点数为负数。</p><p>因为M≥0，所以表示正负的特征就转移到s上。</p><h2 id=尾数m>尾数M<a hidden class=anchor aria-hidden=true href=#尾数m>#</a></h2><p>在规格化浮点数下，1 ≤M&lt;2，即M是一个1.xxxxx(2)的数，其中xxxxx代表小数部分。</p><p>IEEE754规定，在计算机内部保存M时，默认这个数的整数部分总是1，所以可以被舍去，只保留后面的xxxxx小数部分。</p><p>比如当M=1.01(2)时，只需要保存01(2)，等到读取的时候再把1加上去。</p><p>这么做是为了节省一个位的空间。</p><h3 id=尾数m具体怎么表示>尾数M具体怎么表示？<a hidden class=anchor aria-hidden=true href=#尾数m具体怎么表示>#</a></h3><p>M在二进制中存储在frac区域，其读数方式，是假定在frac位部分前已经有一个固定的小数点。</p><p>由此读出下图绿色部分，frac位部分的小数的数值。</p><p>最后在计算M时，将1 +frac部分代表的小数。</p><p>比如，当M = 1.75<sub>(10)</sub>时，frac部分为110000…..00<sub>(2)</sub></p><p>frac为110000…00<sub>(2)</sub> ，计算 .110000..00<sub>(2)</sub> 的十进制值为0.75<sub>(10)</sub>,再加上1，为1.75<sub>(10)</sub></p><table><thead><tr><th style=text-align:left>二进制位</th><th style=text-align:left>符号位s</th><th style=text-align:left>阶码位exp</th><th style=text-align:left>Frac位</th><th style=text-align:left>Frac位</th><th style=text-align:left>Frac位</th><th style=text-align:left>Frac位</th></tr></thead><tbody><tr><td style=text-align:left>对应十进制小数的值</td><td style=text-align:left>&mldr;&mldr;</td><td style=text-align:left>&mldr;&mldr;</td><td style=text-align:left>0.5</td><td style=text-align:left>0.25</td><td style=text-align:left>0.125</td><td style=text-align:left>0.0625</td></tr></tbody></table><h2 id=阶码e>阶码E<a hidden class=anchor aria-hidden=true href=#阶码e>#</a></h2><p>阶码E可能是正数、0和负数。</p><p>在IEEE754规定，计算机内部保存E时，存储的区域exp是表示一个无符号二进制数。</p><p>如果exp的位数为8位，那么exp能表示的十进制值在0-255之间。为了能表示负数，IEEE754规定，exp的值需要减去一个中间数。</p><p>对于8位exp，这个中间数是127。</p><h3 id=阶码e具体怎么表示>阶码E具体怎么表示？<a hidden class=anchor aria-hidden=true href=#阶码e具体怎么表示>#</a></h3><p>E在二进制中存在exp区域，其读数方式是将其作为一个无符号二进制数读出数值。</p><p>之后再减去一个“中间数”，也叫偏置(bias)。</p><p>Bias = 2<sup>k-1</sup> – 1 , 其中k是exp区域的位数。当k为8时，bias=127</p><p>E = exp – bias</p><p>比如，当E=10时，exp区域有8位，bias=127，则exp要存储的十进制数位137(10), 对应的无符号二进制数为10001001</p><h3 id=阶码e的几种情况>阶码E的几种情况<a hidden class=anchor aria-hidden=true href=#阶码e的几种情况>#</a></h3><p>exp部分表示的位，在以下几种不同的情况，表示的数和计算方式略有不同。</p><ol><li>exp不全为0也不全为1时，浮点数采用之前的读数方式，减去bias得到E。（规格化的数）</li><li>exp全为0时，这时候的计算E的公式变为E=1-bias，与此同时，计算M的公式也改为M=frac。这么做是为了表示0，和数值非常接近于0的数。（非规格化的数）</li><li>exp全为1时，当frac部分全为0时，表示无穷大；当frac部分不全为0时，表示“不是一个数”</li></ol><h4 id=无穷大>无穷大<a hidden class=anchor aria-hidden=true href=#无穷大>#</a></h4><p>IEEE754浮点数可以表示无穷大，当exp 的所有位全为1，frac的所有位全为0时即可表示无穷大。</p><p>如果s为0则表示正无穷大，s为1为负无穷大。</p><p>通常用于处理一些无法用实数表示的结果，比如 1/0 = 无穷大。</p><h4 id=不是一个数nan>不是一个数（NaN）<a hidden class=anchor aria-hidden=true href=#不是一个数nan>#</a></h4><p>当exp 的所有位全为1，frac的所有位不全为0时表示“不是一个数”。用于表示一个无法表示的数，如“根号下的-1” 或者 “无穷 - 无穷”。</p><h3 id=为什么会有非规格化的数>为什么会有非规格化的数？<a hidden class=anchor aria-hidden=true href=#为什么会有非规格化的数>#</a></h3><p>规格化的数无法表示0</p><p>浮点数公式：(-1)<sup>s</sup> * M * 2<sup>E</sup></p><p>其中， 1 ≤ M &lt;2，M不会等于0，因此IEEE754另外定义了非规格化的数，M=frac，使M的区间为0 ≤ M s&lt; 1。如此一来，M就可以等于0了。</p><p>接着，在二进制补码中，我们做到了用00000…000来代表0。因此我们希望在s和exp都为0时，浮点数的00000…000也代表0</p><p>因此，在IEEE754有两种计算浮点数的规则，非规格化和规格化。</p><p>在这两种数中，规格化的最小数为，exp为00000001，E为-126，M为1.0，即 1.0 * 2<sup>-126</sup></p><p>在非规格化的数中，M的最大值为0.11111(2)。如果按照规格化的数来计算阶码E，那么exp为00000000，E为-127，这样得到的值为</p><p>0.111…111* 2<sup>-127</sup></p><p>比较0.111…111* 2<sup>-127</sup> 和1.0 * 2<sup>-126</sup> ，我们发现这两个数如果不看E，只看M的话，是非常接近的。如果非规格化的数的E是-126的话，在最大的非规格化数与最小的规格化数之间，可以实现比较平滑的过渡。因此，IEEE754规定非规格化数的E=1-bias</p><h2 id=关于浮点数非常形象的一张图>关于浮点数，非常形象的一张图<a hidden class=anchor aria-hidden=true href=#关于浮点数非常形象的一张图>#</a></h2><p>浮点数有五部分：</p><ol><li>0</li><li>非规格化部分</li><li>规格化部分</li><li>无穷</li><li>不是一个正数（NaN）</li></ol><p><img loading=lazy src=/images/float_number_table.png alt>
图片来自《深入理解计算机系统》第三版第80页。</p><h2 id=举个例子计算浮点数>举个例子计算浮点数<a hidden class=anchor aria-hidden=true href=#举个例子计算浮点数>#</a></h2><h3 id=计算规格化的值>计算规格化的值<a hidden class=anchor aria-hidden=true href=#计算规格化的值>#</a></h3><p>前提：当exp的位模式既不全为0，也不全为1时。（既不是0000&mldr;.0000，也不是1111&mldr;.1111）
此时：</p><ul><li>尾数M=1+frac</li><li>阶码E=exp-Bias</li><li>其中偏置Bias = 2<sup>k-1</sup> - 1 ， 注意，这里的k是指exp阶码位的位数
如0.875在8位浮点数（s符号-1位 exp阶码位-4位 frac尾数位-3位）中，如下表可查二进制位表示为：</li></ul><p>00110110</p><p>以下是计算过程：
列出公式：</p><p>(-1)<sup>s</sup> * M * 2<sup>E</sup></p><h4 id=第一部分符号位s>第一部分，符号位s<a hidden class=anchor aria-hidden=true href=#第一部分符号位s>#</a></h4><p>符号位直接从二进制中读取：</p><p>s=0</p><h4 id=第二部分尾数m>第二部分：尾数M<a hidden class=anchor aria-hidden=true href=#第二部分尾数m>#</a></h4><p>尾数计算公式：</p><p>尾数M=1+frac</p><p>其中需要计算frac的具体数值：</p><p>frac位=110。我们假设在110前方有一个二进制的小数点，那么frac为 .110</p><table><thead><tr><th style=text-align:left>1</th><th style=text-align:left>1</th><th style=text-align:left>0</th></tr></thead><tbody><tr><td style=text-align:left>0.5</td><td style=text-align:left>0.25</td><td style=text-align:left>0.125</td></tr></tbody></table><p>frac 二进制.110=十进制0.5+0.25=0.75
M = 1 + frac = 1 + 0.75 = 1.75</p><h4 id=第三部分阶码e>第三部分：阶码E<a hidden class=anchor aria-hidden=true href=#第三部分阶码e>#</a></h4><p>阶码计算公式：</p><p>E=exp-Bias</p><p>k = 4（因为exp阶码是4位）；</p><p>Bias = 2<sup>k-1</sup> - 1 = 2 <sup>4-1</sup> -1 = 8-1=7</p><p>exp = 0110 = 6</p><p>E = exp - Bias = 6 - 7 = -1</p><h4 id=进行计算>进行计算<a hidden class=anchor aria-hidden=true href=#进行计算>#</a></h4><p>至此，对于公式</p><p>(-1)<sup>s</sup> * M * 2<sup>E</sup></p><p>我们有：</p><ul><li>s = 0</li><li>M = 1.75</li><li>E = -1</li></ul><p>代入计算，V = (-1)^0 * 1.75 * 2 ^(-1) = 1.75 * 0.5 = 1.75 / 2 = 0.875</p><h2 id=计算非规格化的值>计算非规格化的值<a hidden class=anchor aria-hidden=true href=#计算非规格化的值>#</a></h2><p>前提：当exp的位模式全为0时
此时：</p><ul><li>尾数M=frac</li><li>阶码E=1-Bias</li><li>偏置Bias = 2^（k-1） - 1</li></ul><p>如0.005859在8位浮点数（s符号-1位 exp阶码位-4位 frac尾数位-3位）中，如下表可查二进制位表示为：</p><p>00000011</p><p>以下是计算过程：</p><p>列出公式：</p><p>(-1)<sup>s</sup> * M * 2<sup>E</sup></p><h3 id=第一部分符号位s-1>第一部分，符号位s<a hidden class=anchor aria-hidden=true href=#第一部分符号位s-1>#</a></h3><p>符号位直接从二进制中读取：
s=0</p><h3 id=第二部分尾数m-1>第二部分：尾数M<a hidden class=anchor aria-hidden=true href=#第二部分尾数m-1>#</a></h3><p>在非规格化的值中，尾数计算公式：
尾数M=frac
需要计算frac的具体数值：
frac位=011。我们假设在011前方有一个二进制的小数点，那么frac为 .011</p><table><thead><tr><th style=text-align:left>0</th><th style=text-align:left>1</th><th style=text-align:left>1</th></tr></thead><tbody><tr><td style=text-align:left>0.5</td><td style=text-align:left>0.25</td><td style=text-align:left>0.125</td></tr></tbody></table><p>frac 二进制.110=十进制0.25+0.125=0.375</p><p>M = frac = 0.375</p><h3 id=第三部分阶码e-1>第三部分：阶码E<a hidden class=anchor aria-hidden=true href=#第三部分阶码e-1>#</a></h3><p>非规格化数中，exp部分为0。</p><p>公式为：</p><p>阶码E=1-Bias</p><p>k = 4（因为exp阶码是4位）；</p><p>Bias = 2<sup>k-1</sup> - 1 = 2 <sup>4-1</sup> -1 = 8-1=7</p><p>因此：</p><p>E = 1-7 = -6</p><p>进行计算</p><p>至此，对于公式</p><p>(-1)<sup>s</sup> * M * 2<sup>E</sup>
我们有：</p><ul><li>s = 0</li><li>M = 0.375</li><li>E = -6</li></ul><p>代入计算，V = (-1)^0 * 0.375 * 2 ^(-6) =0.375 * 0.015625 = 0.005859375。</p><h2 id=浮点数的舍入>浮点数的“舍入”<a hidden class=anchor aria-hidden=true href=#浮点数的舍入>#</a></h2><p>因为浮点数有精度限制，所以在运算中，需要进行一定的舍入，从而用有限的位来表示最接近目标实数的浮点数。
IEEE标准要求使用“向偶数舍入”，不是我们常说的四舍五入，而是四舍六入，五向偶数舍入。
四舍六入下：
1.4 -> 1
1.6 -> 2</p><p>向偶数舍入下：
1.5 -> 2
-1.5 -> -2
因为1.5两边的数字是1和2，要向偶数舍入，所以取2；同理，-1.5两边的数字是-1和-2，向偶数舍入，取-2。
关于二进制向偶数舍入，书上描述为：</p><p><img loading=lazy src=/images/round_to_even.png alt>
图片来自《深入理解计算机系统》第三版第84页。</p><p>之所以这么做，是因为如果全部向上舍入/向下舍入，会出现统计偏差。而向偶数/奇数舍入，则有50%的几率向上舍入，50%向下舍入，从而避免统计偏差。</p><h2 id=关于溢出>关于溢出<a hidden class=anchor aria-hidden=true href=#关于溢出>#</a></h2><p>不管是二进制补码、无符号数或者浮点数，都会存在溢出的情况。而溢出这个行为本身，C语言不会给出任何警告。所以只能通过良好的编程习惯和思维去避免。</p><p>溢出部分在计算机中会舍去。这带来了一些问题。比如加法和乘法，很有可能超过了Tmax或者Umax。</p><h2 id=关于除法>关于除法<a hidden class=anchor aria-hidden=true href=#关于除法>#</a></h2><p>除法运算是十分消耗资源和时间的。计算机发展到现在，除法依旧需要消耗大量的CPU时钟。
但由于我们存储整数使用的是二进制补码/无符号数，所以如果我们的除数是2的幂，则可以通过位移来进行除法运算。</p><p>当负数需要进行除2的幂的时候，需要加上偏移量，来保证舍入正确。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://windypath.com/tags/csapp/>CSAPP</a></li></ul><nav class=paginav><a class=prev href=https://windypath.com/posts/how_to_split_a_string_in_cpp/><span class=title>« 上一页</span><br><span>如何用C++分割一个字符串？</span></a>
<a class=next href=https://windypath.com/posts/about_myself/><span class=title>下一页 »</span><br><span>我的自我介绍</span></a></nav></footer></article></main><footer class=footer><span>Windypath 风萧古道 <strong>For Chinese Software</strong>. <a href=https://beian.miit.gov.cn/>闽ICP备15016446号-3</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>