<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CSAPP第二章-信息的表示与处理-随手记 | 风萧古道 - 勤学苦练，年复一年</title><meta name=keywords content="CSAPP"><meta name=description content="仅作为学习《深入理解计算机系统》第二章时的笔记，仅记录对自己有启发的部分，不作为知识整理。（直接看电子书就可以了）。
因为这本书知识点非常多，所以我会抽时间多次阅读，本文也会经常更新。
原码和反码会有两个0：正0和负0 原码：用第一个位来表示正负，后面的位来表示数的大小 反码：用一个正数取反来表示这个正数的相反数
这两种表示法都会存在两个0：+0和-0。
而使用补码就只有一个0了。
补码表示的新理解 关于补码，为了计算某个正数的相反数，可以用过取反+1的方式计算得到负数的补码表示。但是还有另一种方式能够更好的理解补码。 如果用5位来表示一个数：
下标 4 3 2 1 0 代表的十进制数 每个下标的数值 -16 8 4 2 1 二进制数1 0 1 1 0 1 13 二进制数2 1 1 1 0 1 -3 二进制数3 1 1 1 1 1 -1 二进制数3 0 1 1 1 1 15 可以看到其实如果按照补码的逻辑，当使用5个位来存储数字时，最高位第5位作为符号位，它的数值为-16，其他第1到4位的数值为1、2、4、8，然后再对二进制数的各个位，乘以其对应的数值，再累加，就能得到十进制数的大小。 比如二进制数1，其十进制数=0*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = 13。 而负数二进制2，其十进制数=1*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = -3。"><meta name=author content="JohnathanLin"><link rel=canonical href=https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://windypath.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="CSAPP第二章-信息的表示与处理-随手记"><meta property="og:description" content="仅作为学习《深入理解计算机系统》第二章时的笔记，仅记录对自己有启发的部分，不作为知识整理。（直接看电子书就可以了）。
因为这本书知识点非常多，所以我会抽时间多次阅读，本文也会经常更新。
原码和反码会有两个0：正0和负0 原码：用第一个位来表示正负，后面的位来表示数的大小 反码：用一个正数取反来表示这个正数的相反数
这两种表示法都会存在两个0：+0和-0。
而使用补码就只有一个0了。
补码表示的新理解 关于补码，为了计算某个正数的相反数，可以用过取反+1的方式计算得到负数的补码表示。但是还有另一种方式能够更好的理解补码。 如果用5位来表示一个数：
下标 4 3 2 1 0 代表的十进制数 每个下标的数值 -16 8 4 2 1 二进制数1 0 1 1 0 1 13 二进制数2 1 1 1 0 1 -3 二进制数3 1 1 1 1 1 -1 二进制数3 0 1 1 1 1 15 可以看到其实如果按照补码的逻辑，当使用5个位来存储数字时，最高位第5位作为符号位，它的数值为-16，其他第1到4位的数值为1、2、4、8，然后再对二进制数的各个位，乘以其对应的数值，再累加，就能得到十进制数的大小。 比如二进制数1，其十进制数=0*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = 13。 而负数二进制2，其十进制数=1*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = -3。"><meta property="og:type" content="article"><meta property="og:url" content="https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-05T17:53:43+08:00"><meta property="article:modified_time" content="2022-05-05T17:53:43+08:00"><meta property="og:site_name" content="Windypath"><meta name=twitter:card content="summary"><meta name=twitter:title content="CSAPP第二章-信息的表示与处理-随手记"><meta name=twitter:description content="仅作为学习《深入理解计算机系统》第二章时的笔记，仅记录对自己有启发的部分，不作为知识整理。（直接看电子书就可以了）。
因为这本书知识点非常多，所以我会抽时间多次阅读，本文也会经常更新。
原码和反码会有两个0：正0和负0 原码：用第一个位来表示正负，后面的位来表示数的大小 反码：用一个正数取反来表示这个正数的相反数
这两种表示法都会存在两个0：+0和-0。
而使用补码就只有一个0了。
补码表示的新理解 关于补码，为了计算某个正数的相反数，可以用过取反+1的方式计算得到负数的补码表示。但是还有另一种方式能够更好的理解补码。 如果用5位来表示一个数：
下标 4 3 2 1 0 代表的十进制数 每个下标的数值 -16 8 4 2 1 二进制数1 0 1 1 0 1 13 二进制数2 1 1 1 0 1 -3 二进制数3 1 1 1 1 1 -1 二进制数3 0 1 1 1 1 15 可以看到其实如果按照补码的逻辑，当使用5个位来存储数字时，最高位第5位作为符号位，它的数值为-16，其他第1到4位的数值为1、2、4、8，然后再对二进制数的各个位，乘以其对应的数值，再累加，就能得到十进制数的大小。 比如二进制数1，其十进制数=0*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = 13。 而负数二进制2，其十进制数=1*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = -3。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windypath.com/posts/"},{"@type":"ListItem","position":2,"name":"CSAPP第二章-信息的表示与处理-随手记","item":"https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CSAPP第二章-信息的表示与处理-随手记","name":"CSAPP第二章-信息的表示与处理-随手记","description":"仅作为学习《深入理解计算机系统》第二章时的笔记，仅记录对自己有启发的部分，不作为知识整理。（直接看电子书就可以了）。\n因为这本书知识点非常多，所以我会抽时间多次阅读，本文也会经常更新。\n原码和反码会有两个0：正0和负0 原码：用第一个位来表示正负，后面的位来表示数的大小 反码：用一个正数取反来表示这个正数的相反数\n这两种表示法都会存在两个0：+0和-0。\n而使用补码就只有一个0了。\n补码表示的新理解 关于补码，为了计算某个正数的相反数，可以用过取反+1的方式计算得到负数的补码表示。但是还有另一种方式能够更好的理解补码。 如果用5位来表示一个数：\n下标 4 3 2 1 0 代表的十进制数 每个下标的数值 -16 8 4 2 1 二进制数1 0 1 1 0 1 13 二进制数2 1 1 1 0 1 -3 二进制数3 1 1 1 1 1 -1 二进制数3 0 1 1 1 1 15 可以看到其实如果按照补码的逻辑，当使用5个位来存储数字时，最高位第5位作为符号位，它的数值为-16，其他第1到4位的数值为1、2、4、8，然后再对二进制数的各个位，乘以其对应的数值，再累加，就能得到十进制数的大小。 比如二进制数1，其十进制数=0*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = 13。 而负数二进制2，其十进制数=1*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = -3。","keywords":["CSAPP"],"articleBody":" 仅作为学习《深入理解计算机系统》第二章时的笔记，仅记录对自己有启发的部分，不作为知识整理。（直接看电子书就可以了）。\n因为这本书知识点非常多，所以我会抽时间多次阅读，本文也会经常更新。\n原码和反码会有两个0：正0和负0 原码：用第一个位来表示正负，后面的位来表示数的大小 反码：用一个正数取反来表示这个正数的相反数\n这两种表示法都会存在两个0：+0和-0。\n而使用补码就只有一个0了。\n补码表示的新理解 关于补码，为了计算某个正数的相反数，可以用过取反+1的方式计算得到负数的补码表示。但是还有另一种方式能够更好的理解补码。 如果用5位来表示一个数：\n下标 4 3 2 1 0 代表的十进制数 每个下标的数值 -16 8 4 2 1 二进制数1 0 1 1 0 1 13 二进制数2 1 1 1 0 1 -3 二进制数3 1 1 1 1 1 -1 二进制数3 0 1 1 1 1 15 可以看到其实如果按照补码的逻辑，当使用5个位来存储数字时，最高位第5位作为符号位，它的数值为-16，其他第1到4位的数值为1、2、4、8，然后再对二进制数的各个位，乘以其对应的数值，再累加，就能得到十进制数的大小。 比如二进制数1，其十进制数=0*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = 13。 而负数二进制2，其十进制数=1*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = -3。\n我们现在已经知道-3的二进制补码表示是：11101，很容易能通过这个数值表得到正3的二进制补码表示是00011。 使用上面的“取反后+1”的公式，也可以将-3转为正3：~11101 + 1 = 00010 + 1 = 00011\n另外，还有两个比较有意思的内容：\n想获得某个二进制补码表示的最小的数，只需要让其符号位为1，其他位为0即可。 比如在5位表示数的情况下，最小的数是-16，即10000。 想获取-1，只需要让所有位都为1即可，那么想获得-1，可以直接用0按位取反。 按位左移和右移 左移无所谓，左移几位就往右边补0即可。 右移有两种，一种是算数右移，就是右移之后在左边补的位为符号位的那个数字；另一种是逻辑右移，右移之后在左边补0\n按位移动位的数量，系统默认帮你取模 来源：https://www.jianshu.com/p/304bfdda6b6a 控制硬件时，常涉及打开/关闭特定的位或查看他们的状态，一般都会使用到按位运算符技术。\n一个面试题：\nint a = 1, b = 32; print(\"%d, %d\", a\u003c\u003cb, 1\u003c\u003c32); 答案是 1，0\na « b 的结果是1，是因为运行时会将操作数b对32取模，然后在进行移位操作。\n布尔代数 所谓布尔代数，就是按位与（\u0026），或（|），非（~），异或（^）。 需要注意和强调的是（应该已经强调无数遍了），\u0026和\u0026\u0026不一样，|和||不一样，~和负号-不一样。\n比较有意思的是：\n异或有一个性质是：a ^ a = 0， (a ^ b) ^ a = b（因为0 ^ b = b） (x | -x) » 31 ，当x为0时依旧为0，当x不为0时，为-1 小端和大端 简单记的话，就记一个数 0x12345678 存储地址从小到大依次从左到右（有语病，但意思是那个意思） 大端存的是12 34 56 78 小端存的是78 56 34 12\nC语言unsigned int，会导致问题 一般来说数组的长度是大于等于0的，所以在设计过程中，为了能多获得一位存储空间，有的人会设计使用unsigned int存储。在C语言有一个size_t类型，其定义就是long unsigned int 但在遍历过程中，有可能会出现肉眼难以察觉的bug。\n正常的代码：\nint a[5] = { 1, 2, 3, 4, 5 }; int cnt = 5; printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } int i; printf(\"start loop\\n\"); for (i = cnt -2;i \u003e= 0;i--) { printf(\"in loop,%u %u\\n\", i, cnt); a[i] += a[i+1]; } printf(\"end loop\\n\"); printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } 此段代码给出一个数组a，该数组有5个元素。然后进行的操作是从数组的后面往前累加，最终a数组的第一个元素是之前a数组各元素的总和。\n其运行结果如下：\nshow values a[0]=1 a[1]=2 a[2]=3 a[3]=4 a[4]=5 start loop in loop,3 5 in loop,2 5 in loop,1 5 in loop,0 5 end loop show values a[0]=15 a[1]=14 a[2]=12 a[3]=9 a[4]=5 如果我们把代码“int i”改成“size_t i”会如何呢？ 需要修改的错误代码：\nint a[5] = { 1, 2, 3, 4, 5 }; int cnt = 5; printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } size_t i; printf(\"start loop\\n\"); for (i = cnt -2;i \u003e= 0;i--) { printf(\"in loop,%u %u\\n\", i, cnt); a[i] += a[i+1]; } printf(\"end loop\\n\"); printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } 输出结果：\nshow values a[0]=1 a[1]=2 a[2]=3 a[3]=4 a[4]=5 start loop in loop,3 5 in loop,2 5 in loop,1 5 in loop,0 5 in loop,4294967295 5 in loop,4294967294 5 Segmentation fault (core dumped) 根据文章https://blog.csdn.net/wang93IT/article/details/72782379所说：\n有些时候我们在一段 C/C++ 代码的时候，由于对一个非法内存进行了操作，在程序运行的过程中，出现了“Segmentation fault (core dumped)”——段错误。\n可以看到当i为0的时候，i–操作使i变成了一个特别大的数字，然后取a[i]时没有找到了非法内存，于是报错。 解决办法就是不要用size_t，也就是不要用无符号类型去作为下标索引。但如果a数组本身非常大呢？因为sizeof()函数的返回值类型就是size_t。\n不要担心，在CSAPP课上，老教授给出了一种解决方案，虽然不是很符合正常逻辑： 修改后的正常代码：\nint a[5] = { 1, 2, 3, 4, 5 }; int cnt = 5; printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } size_t i; printf(\"start loop\\n\"); for (i = cnt -2;i \u003c cnt;i--) { printf(\"in loop,%u %u\\n\", i, cnt); a[i] += a[i+1]; } printf(\"end loop\\n\"); printf(\"show values\\n\"); for (int j = 0;j \u003c cnt;j++) { printf(\"a[%d]=%d\\n\", j, a[j]); } 仔细对比可以发现，在第二个for循环for (i = cnt -2;i \u003c cnt;i--)中，其第二格判断条件从i \u003e= 0改成了i \u003c cnt。\n运行结果：\nshow values a[0]=1 a[1]=2 a[2]=3 a[3]=4 a[4]=5 start loop in loop,3 5 in loop,2 5 in loop,1 5 in loop,0 5 end loop show values a[0]=15 a[1]=14 a[2]=12 a[3]=9 a[4]=5 输出结果正常了。这是因为它借助了“无符号数减到（有符号数意义下的）负数时，会变成一个非常大的数”的性质。\n为什么无符号的0再减一个正数就会变成很大的数呢？ 以无符号0减去1为例： 假设有一个5位表示的数00000，如果这个数是二进制补码，则当00000减去1时，会得到11111。 11111在二进制补码中，指的是-1，但如果在无符号数中，它指的是UMax，也就是无符号数能表示的最大数。\n二进制补码下，所有数字都有相反数吗？ 不是的，TMin 100…000那个数字没有，也就是我们int下最小的数：-2147483648。 这个数字取反+1后会变成它自己，而不是正的2147483647。\n但这也是为了在二进制补码中只有唯一的0作出的牺牲。\n关于浮点数，非常形象的一张图 浮点数有五部分：\n0 非规格化部分 规格化部分 无穷 不是一个正数（NaN） 图片来自《深入理解计算机系统》第三版第80页。\n浮点数的“舍入” 因为浮点数有精度限制，所以在运算中，需要进行一定的舍入，从而用有限的位来表示最接近目标实数的浮点数。 IEEE标准要求使用“向偶数舍入”，不是我们常说的四舍五入，而是四舍六入，五向偶数舍入。 四舍六入下： 1.4 -\u003e 1 1.6 -\u003e 2\n向偶数舍入下： 1.5 -\u003e 2 -1.5 -\u003e -2 因为1.5两边的数字是1和2，要向偶数舍入，所以取2；同理，-1.5两边的数字是-1和-2，向偶数舍入，取-2。 关于二进制向偶数舍入，书上描述为：\n图片来自《深入理解计算机系统》第三版第84页。\n之所以这么做，是因为如果全部向上舍入/向下舍入，会出现统计偏差。而向偶数/奇数舍入，则有50%的几率向上舍入，50%向下舍入，从而避免统计偏差。\n关于溢出 不管是二进制补码、无符号数或者浮点数，都会存在溢出的情况。而溢出这个行为本身，C语言不会给出任何警告。所以只能通过良好的编程习惯和思维去避免。\n溢出部分在计算机中会舍去。这带来了一些问题。比如加法和乘法，很有可能超过了Tmax或者Umax。\n关于除法 除法运算是十分消耗资源和时间的。计算机发展到现在，除法依旧需要消耗大量的CPU时钟。 但由于我们存储整数使用的是二进制补码/无符号数，所以如果我们的除数是2的幂，则可以通过位移来进行除法运算。\n当负数需要进行除2的幂的时候，需要加上偏移量，来保证舍入正确。\n仅做记录，还未研究。\n","wordCount":"521","inLanguage":"en","datePublished":"2022-05-05T17:53:43+08:00","dateModified":"2022-05-05T17:53:43+08:00","author":{"@type":"Person","name":"JohnathanLin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://windypath.com/posts/csapp_chapter2_representing_manipulating_info/"},"publisher":{"@type":"Organization","name":"风萧古道 - 勤学苦练，年复一年","logo":{"@type":"ImageObject","url":"https://windypath.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windypath.com/ accesskey=h title="Windypath (Alt + H)">Windypath</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://windypath.com/about/ title=About><span>About</span></a></li><li><a href=https://windypath.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://windypath.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://windypath.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://windypath.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://windypath.com/>Home</a>&nbsp;»&nbsp;<a href=https://windypath.com/posts/>Posts</a></div><h1 class=post-title>CSAPP第二章-信息的表示与处理-随手记</h1><div class=post-meta><span title='2022-05-05 17:53:43 +0800 +0800'>May 5, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;JohnathanLin</div></header><div class=post-content><blockquote><p>仅作为学习《深入理解计算机系统》第二章时的笔记，仅记录对自己有启发的部分，不作为知识整理。（直接看电子书就可以了）。</p></blockquote><blockquote><p>因为这本书知识点非常多，所以我会抽时间多次阅读，本文也会经常更新。</p></blockquote><h2 id=原码和反码会有两个0正0和负0>原码和反码会有两个0：正0和负0<a hidden class=anchor aria-hidden=true href=#原码和反码会有两个0正0和负0>#</a></h2><p>原码：用第一个位来表示正负，后面的位来表示数的大小
反码：用一个正数取反来表示这个正数的相反数</p><p>这两种表示法都会存在两个0：+0和-0。</p><p>而使用补码就只有一个0了。</p><h2 id=补码表示的新理解>补码表示的新理解<a hidden class=anchor aria-hidden=true href=#补码表示的新理解>#</a></h2><p>关于补码，为了计算某个正数的相反数，可以用过取反+1的方式计算得到负数的补码表示。但是还有另一种方式能够更好的理解补码。
如果用5位来表示一个数：</p><table><thead><tr><th style=text-align:left>下标</th><th style=text-align:left>4</th><th style=text-align:left>3</th><th style=text-align:left>2</th><th style=text-align:left>1</th><th style=text-align:left>0</th><th style=text-align:left>代表的十进制数</th></tr></thead><tbody><tr><td style=text-align:left>每个下标的数值</td><td style=text-align:left>-16</td><td style=text-align:left>8</td><td style=text-align:left>4</td><td style=text-align:left>2</td><td style=text-align:left>1</td><td></td></tr><tr><td style=text-align:left>二进制数1</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>13</td></tr><tr><td style=text-align:left>二进制数2</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>-3</td></tr><tr><td style=text-align:left>二进制数3</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>-1</td></tr><tr><td style=text-align:left>二进制数3</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>15</td></tr></tbody></table><p>可以看到其实如果按照补码的逻辑，当使用5个位来存储数字时，最高位第5位作为符号位，它的数值为-16，其他第1到4位的数值为1、2、4、8，然后再对二进制数的各个位，乘以其对应的数值，再累加，就能得到十进制数的大小。
比如二进制数1，其十进制数=0*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = 13。
而负数二进制2，其十进制数=1*(-16) + 1*8 + 1*4 + 0*2 + 1*1 = -3。</p><p>我们现在已经知道-3的二进制补码表示是：11101，很容易能通过这个数值表得到正3的二进制补码表示是00011。
使用上面的“取反后+1”的公式，也可以将-3转为正3：~11101 + 1 = 00010 + 1 = 00011</p><p>另外，还有两个比较有意思的内容：</p><ol><li>想获得某个二进制补码表示的最小的数，只需要让其符号位为1，其他位为0即可。
比如在5位表示数的情况下，最小的数是-16，即10000。</li><li>想获取-1，只需要让所有位都为1即可，那么想获得-1，可以直接用0按位取反。</li></ol><h2 id=按位左移和右移>按位左移和右移<a hidden class=anchor aria-hidden=true href=#按位左移和右移>#</a></h2><p>左移无所谓，左移几位就往右边补0即可。
右移有两种，一种是算数右移，就是右移之后在左边补的位为符号位的那个数字；另一种是逻辑右移，右移之后在左边补0</p><h2 id=按位移动位的数量系统默认帮你取模>按位移动位的数量，系统默认帮你取模<a hidden class=anchor aria-hidden=true href=#按位移动位的数量系统默认帮你取模>#</a></h2><p>来源：<a href=https://www.jianshu.com/p/304bfdda6b6a>https://www.jianshu.com/p/304bfdda6b6a</a>
控制硬件时，常涉及打开/关闭特定的位或查看他们的状态，一般都会使用到按位运算符技术。</p><p>一个面试题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;%d, %d&#34;</span>, a<span style=color:#f92672>&lt;&lt;</span>b, <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>32</span>);
</span></span></code></pre></div><p>答案是 1，0</p><p>a &#171; b 的结果是1，是因为运行时会将操作数b对32取模，然后在进行移位操作。</p><h2 id=布尔代数>布尔代数<a hidden class=anchor aria-hidden=true href=#布尔代数>#</a></h2><p>所谓布尔代数，就是按位与（&），或（|），非（~），异或（^）。
需要注意和强调的是（应该已经强调无数遍了），&和&&不一样，|和||不一样，~和负号-不一样。</p><p>比较有意思的是：</p><ol><li>异或有一个性质是：a ^ a = 0， (a ^ b) ^ a = b（因为0 ^ b = b）</li><li>(x | -x) &#187; 31 ，当x为0时依旧为0，当x不为0时，为-1</li></ol><h2 id=小端和大端>小端和大端<a hidden class=anchor aria-hidden=true href=#小端和大端>#</a></h2><p>简单记的话，就记一个数 0x12345678
存储地址从小到大依次从左到右（有语病，但意思是那个意思）
大端存的是12 34 56 78
小端存的是78 56 34 12</p><h2 id=c语言unsigned-int会导致问题>C语言unsigned int，会导致问题<a hidden class=anchor aria-hidden=true href=#c语言unsigned-int会导致问题>#</a></h2><p>一般来说数组的长度是大于等于0的，所以在设计过程中，为了能多获得一位存储空间，有的人会设计使用unsigned int存储。在C语言有一个size_t类型，其定义就是long unsigned int
但在遍历过程中，有可能会出现肉眼难以察觉的bug。</p><p>正常的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>      printf(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;start loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> cnt <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>;i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>;i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;in loop,%u %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, cnt);
</span></span><span style=display:flex><span>        a[i] <span style=color:#f92672>+=</span> a[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;end loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>此段代码给出一个数组a，该数组有5个元素。然后进行的操作是从数组的后面往前累加，最终a数组的第一个元素是之前a数组各元素的总和。</p><p>其运行结果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>start loop
</span></span><span style=display:flex><span>in loop,3 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,2 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,1 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,0 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>end loop
</span></span><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span></code></pre></div><p>如果我们把代码“int i”改成“size_t i”会如何呢？
需要修改的错误代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>      printf(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    size_t i;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;start loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> cnt <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>;i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>;i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;in loop,%u %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, cnt);
</span></span><span style=display:flex><span>        a[i] <span style=color:#f92672>+=</span> a[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;end loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>输出结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>start loop
</span></span><span style=display:flex><span>in loop,3 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,2 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,1 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,0 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,4294967295 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,4294967294 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>Segmentation fault <span style=color:#f92672>(</span>core dumped<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>根据文章<a href=https://blog.csdn.net/wang93IT/article/details/72782379>https://blog.csdn.net/wang93IT/article/details/72782379</a>所说：</p><blockquote><p>有些时候我们在一段 C/C++ 代码的时候，由于对一个非法内存进行了操作，在程序运行的过程中，出现了“Segmentation fault (core dumped)”——段错误。</p></blockquote><p>可以看到当i为0的时候，i&ndash;操作使i变成了一个特别大的数字，然后取a[i]时没有找到了非法内存，于是报错。
解决办法就是不要用size_t，也就是不要用无符号类型去作为下标索引。但如果a数组本身非常大呢？因为sizeof()函数的返回值类型就是size_t。</p><p>不要担心，在CSAPP课上，老教授给出了一种解决方案，虽然不是很符合正常逻辑：
修改后的正常代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>      printf(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    size_t i;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;start loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> cnt <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>;i <span style=color:#f92672>&lt;</span> cnt;i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;in loop,%u %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, cnt);
</span></span><span style=display:flex><span>        a[i] <span style=color:#f92672>+=</span> a[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;end loop</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;show values</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> cnt;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;a[%d]=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, j, a[j]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>仔细对比可以发现，在第二个for循环<code>for (i = cnt -2;i &lt; cnt;i--)</code>中，其第二格判断条件从<code>i >= 0</code>改成了<code>i &lt; cnt</code>。</p><p>运行结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>start loop
</span></span><span style=display:flex><span>in loop,3 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,2 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,1 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>in loop,0 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>end loop
</span></span><span style=display:flex><span>show values
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span><span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span><span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>2<span style=color:#f92672>]=</span><span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>[</span>4<span style=color:#f92672>]=</span><span style=color:#ae81ff>5</span>
</span></span></code></pre></div><p>输出结果正常了。这是因为它借助了“无符号数减到（有符号数意义下的）负数时，会变成一个非常大的数”的性质。</p><p>为什么无符号的0再减一个正数就会变成很大的数呢？
以无符号0减去1为例：
假设有一个5位表示的数00000，如果这个数是二进制补码，则当00000减去1时，会得到11111。
11111在二进制补码中，指的是-1，但如果在无符号数中，它指的是UMax，也就是无符号数能表示的最大数。</p><h2 id=二进制补码下所有数字都有相反数吗>二进制补码下，所有数字都有相反数吗？<a hidden class=anchor aria-hidden=true href=#二进制补码下所有数字都有相反数吗>#</a></h2><p>不是的，TMin 100&mldr;000那个数字没有，也就是我们int下最小的数：-2147483648。
这个数字取反+1后会变成它自己，而不是正的2147483647。</p><p>但这也是为了在二进制补码中只有唯一的0作出的牺牲。</p><h2 id=关于浮点数非常形象的一张图>关于浮点数，非常形象的一张图<a hidden class=anchor aria-hidden=true href=#关于浮点数非常形象的一张图>#</a></h2><p>浮点数有五部分：</p><ol><li>0</li><li>非规格化部分</li><li>规格化部分</li><li>无穷</li><li>不是一个正数（NaN）</li></ol><p><img loading=lazy src=/images/float_number_table.png alt>
图片来自《深入理解计算机系统》第三版第80页。</p><h2 id=浮点数的舍入>浮点数的“舍入”<a hidden class=anchor aria-hidden=true href=#浮点数的舍入>#</a></h2><p>因为浮点数有精度限制，所以在运算中，需要进行一定的舍入，从而用有限的位来表示最接近目标实数的浮点数。
IEEE标准要求使用“向偶数舍入”，不是我们常说的四舍五入，而是四舍六入，五向偶数舍入。
四舍六入下：
1.4 -> 1
1.6 -> 2</p><p>向偶数舍入下：
1.5 -> 2
-1.5 -> -2
因为1.5两边的数字是1和2，要向偶数舍入，所以取2；同理，-1.5两边的数字是-1和-2，向偶数舍入，取-2。
关于二进制向偶数舍入，书上描述为：</p><p><img loading=lazy src=/images/round_to_even.png alt>
图片来自《深入理解计算机系统》第三版第84页。</p><p>之所以这么做，是因为如果全部向上舍入/向下舍入，会出现统计偏差。而向偶数/奇数舍入，则有50%的几率向上舍入，50%向下舍入，从而避免统计偏差。</p><h2 id=关于溢出>关于溢出<a hidden class=anchor aria-hidden=true href=#关于溢出>#</a></h2><p>不管是二进制补码、无符号数或者浮点数，都会存在溢出的情况。而溢出这个行为本身，C语言不会给出任何警告。所以只能通过良好的编程习惯和思维去避免。</p><p>溢出部分在计算机中会舍去。这带来了一些问题。比如加法和乘法，很有可能超过了Tmax或者Umax。</p><h2 id=关于除法>关于除法<a hidden class=anchor aria-hidden=true href=#关于除法>#</a></h2><p>除法运算是十分消耗资源和时间的。计算机发展到现在，除法依旧需要消耗大量的CPU时钟。
但由于我们存储整数使用的是二进制补码/无符号数，所以如果我们的除数是2的幂，则可以通过位移来进行除法运算。</p><p>当负数需要进行除2的幂的时候，需要加上偏移量，来保证舍入正确。</p><blockquote><p>仅做记录，还未研究。</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://windypath.com/tags/csapp/>CSAPP</a></li></ul><nav class=paginav><a class=prev href=https://windypath.com/posts/about_java_treeset/><span class=title>« Prev Page</span><br><span>Java TreeSet的一些用法和特性</span></a>
<a class=next href=https://windypath.com/posts/linux_socket_programming/><span class=title>Next Page »</span><br><span>Linux C++ Socket实战</span></a></nav></footer></article></main><footer class=footer><span>Windypath 风萧古道 <strong>For Chinese Software</strong>. <a href=https://beian.miit.gov.cn/>闽ICP备15016446号-3</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>