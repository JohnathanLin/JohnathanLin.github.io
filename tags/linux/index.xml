<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Linux on 风萧古道 - 勤学苦练，年复一年</title>
    <link>https://windypath.com/tags/linux/</link>
    <description>Recent content in Linux on 风萧古道 - 勤学苦练，年复一年</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Windypath 风萧古道 [闽ICP备15016446号-3](https://beian.miit.gov.cn/)</copyright>
    <lastBuildDate>Sat, 30 Apr 2022 23:23:49 +0800</lastBuildDate><atom:link href="https://windypath.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux C&#43;&#43; Socket实战</title>
      <link>https://windypath.com/posts/linux_socket_programming/</link>
      <pubDate>Sat, 30 Apr 2022 23:23:49 +0800</pubDate>
      
      <guid>https://windypath.com/posts/linux_socket_programming/</guid>
      <description>本文主要介绍Linux C++ 基础Socket网络编程。 大部分知识来自于网站：https://www.geeksforgeeks.org/socket-programming-cc/
 Socket编程状态图 从图中可以看到，服务端这边需要处理四步才能进入等待连接的状态，而客户端只要两步。
Socket编程中各函数简单解析 本解析仅为自己理解所用，可能有些纰漏，有则改之。 原文中的知识总结得比我更好，尽量参考原文，我的理解仅做辅助之用。
服务端 先说服务端。服务端需要指定好端口并监听，所以需要bind()绑定好端口，需要listen()进入监听状态，然后通过accept()阻塞等待客户端的消息。
引用表：
 #include &amp;lt;sys/socket&amp;gt;  socket() setsockopt() bind() listen() accept()   #include &amp;lt;netinet/in.h&amp;gt;  struct sockaddr_in   #include &amp;lt;unistd.h&amp;gt;  read()   #include &amp;lt;arpa/inet.h&amp;gt;  inet_pton()    socket() 这个函数是用来创建一个socket，3个参数中，需要特别传的就是前两个。返回一个socket编号，是个int值。
 int sockfd = socket(domain, type, protocol)
 domain: IPV4 用 AF_INET， IPV6 用 AF_INET6 type: TCP 用 SOCK_STREAM, UDP 用 SOCK_UGRAM
setsockopt() 这个函数用来给上面那个socket()函数返回的socket设置属性，作为服务端，为了方便？ 可以设置重用地址和端口号。</description>
    </item>
    
  </channel>
</rss>
