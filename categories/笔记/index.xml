<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>笔记 on 风萧古道 - 勤学苦练，年复一年</title>
    <link>https://windypath.com/categories/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记 on 风萧古道 - 勤学苦练，年复一年</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>© Windypath 风萧古道 **For Chinese Software**. [闽ICP备15016446号-3](https://beian.miit.gov.cn/)</copyright>
    <lastBuildDate>Mon, 04 Dec 2023 17:27:44 +0800</lastBuildDate><atom:link href="https://windypath.com/categories/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java并发编程中上锁的几种方式</title>
      <link>https://windypath.com/posts/java_juc_briefly/</link>
      <pubDate>Mon, 04 Dec 2023 17:27:44 +0800</pubDate>
      
      <guid>https://windypath.com/posts/java_juc_briefly/</guid>
      <description>前言：本文想要介绍Synchronized，ReentrantLock和ReentrantLock的Condition的相关用法。
Synchronized上锁 Synchronized可以修饰实例方法、静态方法和代码块。修饰代码块时，可以对具体的对象上锁，也可以对某个类(.class)上锁。
Synchronized是非公平锁 以下代码是通过给一个多线程能访问到的变量使用synchronized进行上锁，实现有序打印数字的功能。并且在最后会统计不同线程打印数字的次数：
package com.windypath.lockcondition; public class Syn { int count = 0; final Object sth = new Object(); void play() { int loopTimes = 1000; SynThread t1 = new SynThread(loopTimes, &amp;#34;t1&amp;#34;); SynThread t2 = new SynThread(loopTimes, &amp;#34;t2&amp;#34;); SynThread t3 = new SynThread(loopTimes, &amp;#34;t3&amp;#34;); SynThread t4 = new SynThread(loopTimes, &amp;#34;t4&amp;#34;); t1.start(); t2.start(); t3.start(); t4.start(); } public static void main(String[] args) { Syn syn = new Syn(); syn.play(); } class SynThread extends Thread { int loopTimes; public SynThread(int loopTimes, String threadName) { super(threadName); this.</description>
    </item>
    
  </channel>
</rss>
